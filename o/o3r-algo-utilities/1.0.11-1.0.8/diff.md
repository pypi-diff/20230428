# Comparing `tmp/o3r_algo_utilities-1.0.11-py3-none-any.whl.zip` & `tmp/o3r_algo_utilities-1.0.8-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,18 +1,15 @@
-Zip file size: 36280 bytes, number of entries: 16
--rw-rw-rw-  2.0 fat      152 b- defN 23-Apr-11 16:12 o3r_algo_utilities/__init__.py
--rw-rw-rw-  2.0 fat     9623 b- defN 23-Apr-11 16:12 o3r_algo_utilities/o3r_uncompress_di.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-11 16:12 o3r_algo_utilities/calib/__init__.py
--rw-rw-rw-  2.0 fat    27657 b- defN 23-Apr-11 16:12 o3r_algo_utilities/calib/calibration.py
--rw-rw-rw-  2.0 fat    11458 b- defN 23-Apr-11 16:12 o3r_algo_utilities/calib/point_correspondences.py
--rw-rw-rw-  2.0 fat    11230 b- defN 23-Apr-11 16:12 o3r_algo_utilities/calib/sources.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-11 16:12 o3r_algo_utilities/calib/vpu/__init__.py
--rw-rw-rw-  2.0 fat    16515 b- defN 23-Apr-11 16:12 o3r_algo_utilities/calib/vpu/vpu_extrinsic_calibration.py
--rw-rw-rw-  2.0 fat    40776 b- defN 23-Apr-11 16:12 o3r_algo_utilities/calib/vpu/vpu_misalignment_estimation.py
--rw-rw-rw-  2.0 fat    11357 b- defN 23-Apr-11 16:19 o3r_algo_utilities-1.0.11.dist-info/LICENSE
--rw-rw-rw-  2.0 fat      779 b- defN 23-Apr-11 16:19 o3r_algo_utilities-1.0.11.dist-info/METADATA
--rw-rw-rw-  2.0 fat       57 b- defN 23-Apr-11 16:19 o3r_algo_utilities-1.0.11.dist-info/NOTICE
--rw-rw-rw-  2.0 fat       97 b- defN 23-Apr-11 16:19 o3r_algo_utilities-1.0.11.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       83 b- defN 23-Apr-11 16:19 o3r_algo_utilities-1.0.11.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat       19 b- defN 23-Apr-11 16:19 o3r_algo_utilities-1.0.11.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1545 b- defN 23-Apr-11 16:19 o3r_algo_utilities-1.0.11.dist-info/RECORD
-16 files, 131348 bytes uncompressed, 33648 bytes compressed:  74.4%
+Zip file size: 24322 bytes, number of entries: 13
+-rw-rw-rw-  2.0 fat      152 b- defN 23-Feb-28 16:51 o3r_algo_utilities/__init__.py
+-rw-rw-rw-  2.0 fat     9623 b- defN 23-Feb-28 16:51 o3r_algo_utilities/o3r_uncompress_di.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Feb-28 16:51 o3r_algo_utilities/calib/__init__.py
+-rw-rw-rw-  2.0 fat    26875 b- defN 23-Feb-28 16:51 o3r_algo_utilities/calib/calibration.py
+-rw-rw-rw-  2.0 fat    11458 b- defN 23-Feb-28 16:51 o3r_algo_utilities/calib/point_correspondences.py
+-rw-rw-rw-  2.0 fat     8891 b- defN 23-Feb-28 16:51 o3r_algo_utilities/calib/sources.py
+-rw-rw-rw-  2.0 fat    11357 b- defN 23-Feb-28 16:59 o3r_algo_utilities-1.0.8.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat      778 b- defN 23-Feb-28 16:59 o3r_algo_utilities-1.0.8.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       57 b- defN 23-Feb-28 16:59 o3r_algo_utilities-1.0.8.dist-info/NOTICE
+-rw-rw-rw-  2.0 fat       97 b- defN 23-Feb-28 16:59 o3r_algo_utilities-1.0.8.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       83 b- defN 23-Feb-28 16:59 o3r_algo_utilities-1.0.8.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat       19 b- defN 23-Feb-28 16:59 o3r_algo_utilities-1.0.8.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     1211 b- defN 23-Feb-28 16:59 o3r_algo_utilities-1.0.8.dist-info/RECORD
+13 files, 70601 bytes uncompressed, 22244 bytes compressed:  68.5%
```

## zipnote {}

```diff
@@ -12,38 +12,29 @@
 
 Filename: o3r_algo_utilities/calib/point_correspondences.py
 Comment: 
 
 Filename: o3r_algo_utilities/calib/sources.py
 Comment: 
 
-Filename: o3r_algo_utilities/calib/vpu/__init__.py
+Filename: o3r_algo_utilities-1.0.8.dist-info/LICENSE
 Comment: 
 
-Filename: o3r_algo_utilities/calib/vpu/vpu_extrinsic_calibration.py
+Filename: o3r_algo_utilities-1.0.8.dist-info/METADATA
 Comment: 
 
-Filename: o3r_algo_utilities/calib/vpu/vpu_misalignment_estimation.py
+Filename: o3r_algo_utilities-1.0.8.dist-info/NOTICE
 Comment: 
 
-Filename: o3r_algo_utilities-1.0.11.dist-info/LICENSE
+Filename: o3r_algo_utilities-1.0.8.dist-info/WHEEL
 Comment: 
 
-Filename: o3r_algo_utilities-1.0.11.dist-info/METADATA
+Filename: o3r_algo_utilities-1.0.8.dist-info/entry_points.txt
 Comment: 
 
-Filename: o3r_algo_utilities-1.0.11.dist-info/NOTICE
+Filename: o3r_algo_utilities-1.0.8.dist-info/top_level.txt
 Comment: 
 
-Filename: o3r_algo_utilities-1.0.11.dist-info/WHEEL
-Comment: 
-
-Filename: o3r_algo_utilities-1.0.11.dist-info/entry_points.txt
-Comment: 
-
-Filename: o3r_algo_utilities-1.0.11.dist-info/top_level.txt
-Comment: 
-
-Filename: o3r_algo_utilities-1.0.11.dist-info/RECORD
+Filename: o3r_algo_utilities-1.0.8.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## o3r_algo_utilities/calib/calibration.py

```diff
@@ -296,15 +296,15 @@
         logger.error('Mean error is bigger than `max_allowed_error`: {} > {}'.format(np.nanmean(error), max_allowed_error))
         raise RuntimeError("Validation did not succeed.")
     else:
         logger.info('Error is within tolerance')
         logger.debug('Calibration done')
 
 
-def findChessboardCorners(ampl, pattern_size,enhanced=True):
+def findChessboardCorners(ampl, pattern_size):
     '''
     detects chessboard corners in an amplitude image. The chessboard will be aligned such that the first corner is
     above the last corner in the image
     
     :param ampl: amplitude image as outputted by O3R
     :param pattern_size: number of inner corners in the chessboard directions
     :return: corners, gray if the chessboard corners could be detected; otherwise None, gray
@@ -312,22 +312,14 @@
     criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
 
     # rescaled amplitude image for coner detection
     gray = np.interp(ampl, (np.nanpercentile(ampl, 20), np.nanpercentile(ampl, 80)), (40, 215)).astype(np.uint8)
 
     # Find the chess board corners
     ret, corners = cv2.findChessboardCorners(gray, pattern_size, None)
-    if ret is not True:
-        if (enhanced):
-            gray = np.interp(ampl, (np.min(ampl),np.nanpercentile(ampl, 50), np.nanpercentile(ampl, 90),np.max(ampl)), (0, 40, 215, 255)).astype(np.uint8)
-            ret, corners = cv2.findChessboardCorners(gray, pattern_size, None)
-            if ret is not True:
-                gray = np.interp(ampl, (np.min(ampl),np.nanpercentile(ampl, 10), np.nanpercentile(ampl, 50),np.max(ampl)), (0, 40, 215, 255)).astype(np.uint8)
-                ret, corners = cv2.findChessboardCorners(gray, pattern_size, None)
-
     # If found, add object points, image points (after refining them)
     if ret == True:
         # subpixel refinement
         corners = cv2.cornerSubPix(gray, corners, (3, 3), (-1, -1), criteria)
         corners = np.array(corners).squeeze().T
         if corners[1,0] > corners[1,-1]:
             # this might happen, see here:
@@ -433,15 +425,15 @@
     cC = C - AC*frameSize + CD * frameSize
     cD = D - AC*frameSize - CD * frameSize
     return cA, cB, cC, cD
 
 def calib(source, pattern_corner_coordinates, target_width, target_height,
           frame_size=0.0, fixed_translation=None, verbosity="INFO", graphical=True,
           max_allowed_validation_error=0.06, max_allowed_reconstruction_error=0.4, opt_mode="min",
-          image_selection="amplitude", mode="standard_range4m"):
+          image_selection="amplitude"):
     logging.basicConfig(level=verbosity)
 
     cc = eval("dict(" + pattern_corner_coordinates + ")")
     A, B, C, D = cc_to_coordinates(**cc)
     logger.info("Target coordinates parsed successfully. Target size [m]: AB=%.3f CD=%.3f AC=%.3f BD=%.3f ",
                 np.linalg.norm(A-B), np.linalg.norm(C-D), np.linalg.norm(A-C), np.linalg.norm(B-D))
     derr = np.linalg.norm(A + (B-A) + (C-A) - D)
@@ -459,15 +451,15 @@
     if np.abs(derr) > 0.01:
         logger.error("The target coordinates are inconsistent.")
         return 1
     
     #A, B, C, D = [np.array(coordinate, dtype=float) for coordinate in eval(args.pattern_corner_coordinates)]
     fixed_translation = np.array(eval(fixed_translation)).squeeze() if fixed_translation is not None else None
     
-    frame = sources.getFrame(source, mode)
+    frame = sources.getFrame(source)
 
     if ((not np.all(np.abs(frame["camRefToOpticalSystem"]["trans"]) < 0.08)) or
         (not np.all(np.abs(frame["camRefToOpticalSystem"]["rot"]) < 5*np.pi/180))):
         logger.error("Cam ref to optical system seems to be non-plausible. Please make sure that you have reset the extrinsic calibration before applying the calibration.")
         raise RuntimeError("Calibration is not resetted (trans=%s rot=%s)." % (frame["camRefToOpticalSystem"]["trans"], 
                                                                                frame["camRefToOpticalSystem"]["rot"]))
     try:
@@ -505,20 +497,20 @@
     parser.add_argument('-g', '--graphical', action="store_true", default=False, help="Show plots.")
     parser.add_argument('-tw', '--target_width', default=6, type=int, help="number of inner corners per chessboard row (i.e. in AB direction).")
     parser.add_argument('-th', '--target_height', default=4, type=int, help="number of inner corners per chessboard column (i.e. in AC direction).")
     parser.add_argument('-mve', '--max_allowed_validation_error', default=0.06, type=float, help='Maximum allowed validation error (default: %(default).2f) [m]')
     parser.add_argument('-mre', '--max_allowed_reconstruction_error', default=0.4, type=float, help='Maximum allowed reconstruction error (default: %(default).2f) [px]')
     parser.add_argument('-om', '--opt_mode', default="min", choices=["min", "lsq", "minabs"], help='"min" uses scipy.optimize.minimize and in a least squares setting, "lsq" uses scipy.optimize.least_squares, "minabs" uses scipy.minimize in a mean absolute error setting.')
     parser.add_argument('-is', '--image_selection', default="amplitude", choices=["amplitude", "reflectivity"], help="choose whether to use amplitude or reflectivity image.")
-    parser.add_argument("-m", "--mode", default="standard_range4m", choices=["standard_range4m", "standard_range2m", "extrinsic_calib"], help="choose the mode of the port.")
     parser.add_argument("source", type=str, default="ad://192.168.0.69/port2",
                         help="The source to be used. Currently supported schemes: "
                              "'adlive://<ip>/port<C>' use algo debug input with specified ip address and camera port number C=0..5 (requires imeas)."
                              "'adrec://<h5path> use algo debug input stored in a h5 file."
                              "'ifm3dpy://<ip>/port<C>' use ifm3d library input with specified ip address and camera port number C=0..5 (requires ifm3dpy)."
+
                         )
     # TODO: add vision assist h5 file mode
     args = parser.parse_args()
     calib(**vars(args))
 
 if __name__ == "__main__":
     main()
```

## o3r_algo_utilities/calib/sources.py

```diff
@@ -1,14 +1,13 @@
 """
 This module encapsulates the different sources which might be used by the calibration.
 """
 import logging
 import struct
 import numpy as np
-import scipy.ndimage as ndi
 import h5py
 from o3r_algo_utilities import o3r_uncompress_di
 import ifm3dpy
 
 try:
     from ifm_imeas.imeas_tools import unpack_imeas
 except ImportError:
@@ -19,15 +18,15 @@
     from ifm_o3r_algodebug.Receiver import ADReceiver
 except ImportError:
     # Optional algo debug live input is not supported.
     ADReceiver = None
 
 logger = logging.getLogger(__name__)
     
-def getFrame(source, mode):
+def getFrame(source):
     """
     :param source: Specifies the source the following formats are supported:
         'adrec://<pathToFile>' use an algo debug hdf5 recording stored in <pathToFile> 
             (requires the ifm proprietary library imeas)
         'adlive://<ip>/port<camPort>' use a live connection to the camera specified 
             by <ip> and <camPort> (0..5)
         'ifm3dpy://<ip>/port<camPort>' use a live connection to the camera specified 
@@ -43,35 +42,26 @@
         if ADReceiver is None:
             raise RuntimeError("The tool ifm_o3r_algodebug is required for algo debug live input.")
         ip_port = source[len("adlive://"):]
         ip, port = ip_port.split("/")
         if port.startswith("port"):
             port = port[len("port"):]
         port = int(port)
-        frame = grab_algo_debug(ip, port, mode)
+        frame = grab_algo_debug(ip, port)
     elif source.startswith("ifm3dpy://"):
         ip_port = source[len("ifm3dpy://"):]
         ip, port = ip_port.split("/")
         if port.startswith("port"):
             port = port[len("port"):]
         port = int(port)
 
-        frame = grab_ifm3d_frame(ip, port, mode)
+        frame = grab_ifm3d_frame(ip,port)
         
     else:
-        raise RuntimeError("cannot interpret source.")
-
-    conf = frame["C"]
-    img = frame["A"]
-    # replace suspect pixel and invalid amplitudes with a median-ed version
-    M = np.logical_or((conf & 128) == 128, img < 0)
-    if np.sum(M) > 0:
-        img[M] = (ndi.median_filter(img, (3, 3)))[M]
-    img[img < 0] = 0
-
+        raise RuntimeError("cannot interpret source.")    
     return frame
     
 def load_algo_debug_recording(h5file):
     """
     Parses the last frame of an algo debug measurement while ignoring the referenced calibration.
     
     :param h5file: The path of the h5 file to be read.
@@ -88,151 +78,110 @@
     d,_ = unpack_imeas(f["streams"]["o3r_di_0"][-1][0].tobytes(), add_toplevel_wrapper=False)
     f.close()
     
     ifout_compr = d["irs2381/ifout_compr"]
 
     return proc_algo_debug(calib, ifout_compr)
 
-def grab_algo_debug(ip, port, mode):
+def grab_algo_debug(ip, port):
     calib = None
     ifout_compr = None
-    o3r = ifm3dpy.O3R(ip=ip)
-    oldConfig=o3r.get([f"/ports/port{port}"])
-    try:
-        # setting extrinsic to zero is not strictly necessary for the algo debug frames, but we do it nevertheless to
-        # be similar to ifm3d grabbing
-        o3r=set_extrinsic_zero(o3r, port, mode)
-        with ADReceiver(ip, "port%d"%port, autoInterpret=True, xmlrpcTimeout=3, autostart=True) as rcv:
-            logger.debug("receiving frame ...")
-            cnt = 0
-            ifout_compr = None
-            while cnt < 10:
-                data = rcv.get(timeout=3)
-                cnt += 1
-                if "irs2381/calib" in data:
-                    calib = data["irs2381/calib"]
-                if "irs2381/ifout_compr" in data:
-                    # use 2m mode if available
-                    if ifout_compr is None or data["irs2381/ifout_compr"].measurementRangeMax < ifout_compr.measurementRangeMax:
-                        ifout_compr = data["irs2381/ifout_compr"]
-            if calib is None or ifout_compr is None:
-                raise RuntimeError("Could not grab algo debug frame from specified address.")
-            frame = proc_algo_debug(calib, ifout_compr)
-        
-        # need to grab another frame with "normal" mode for validation purpose
-        o3r=set_extrinsic_zero(o3r, port, "standard_range4m")
-        with ADReceiver(ip, "port%d"%port, autoInterpret=True, xmlrpcTimeout=3, autostart=True) as rcv:
-            logger.debug("receiving frame ...")
-            cnt = 0
-            ifout_compr = None
-            while cnt < 10:
-                data = rcv.get(timeout=3)
-                cnt += 1
-                if "irs2381/calib" in data:
-                    calib = data["irs2381/calib"]
-                if "irs2381/ifout_compr" in data:
-                    # use 2m mode if available
-                    if ifout_compr is None or data["irs2381/ifout_compr"].measurementRangeMax < ifout_compr.measurementRangeMax:
-                        ifout_compr = data["irs2381/ifout_compr"]
-            if calib is None or ifout_compr is None:
-                raise RuntimeError("Could not grab algo debug frame from specified address.")
-            f2 = proc_algo_debug(calib, ifout_compr)
-            frame.update({
-                'D': f2["D"],
-                'X': f2["X"],
-                'Y': f2["Y"],
-                'Z': f2["Z"],
-            })
-        
-    finally:
-        o3r.set(oldConfig)
-    return frame 
+    with ADReceiver(ip, "port%d"%port, autoInterpret=True, xmlrpcTimeout=3, autostart=True) as rcv:
+        logger.debug("receiving frame ...")
+        cnt = 0
+        ifout_compr = None
+        while cnt < 10:
+            data = rcv.get(timeout=3)
+            cnt += 1
+            if "irs2381/calib" in data:
+                calib = data["irs2381/calib"]
+            if "irs2381/ifout_compr" in data:
+                # use 2m mode if available
+                if ifout_compr is None or data["irs2381/ifout_compr"].measurementRangeMax < ifout_compr.measurementRangeMax:
+                    ifout_compr = data["irs2381/ifout_compr"]
+        if calib is None or ifout_compr is None:
+            raise RuntimeError("Could not grab algo debug frame from specified address.")
+
+    return proc_algo_debug(calib, ifout_compr)
 
 def proc_algo_debug(calib, ifout_compr):
     # ignore the currently parametrized calibration
     opticToUserTrans = np.array([getattr(calib.intrinsicCalibration.camRefToOpticalSystem, "trans"+a) for a in "XYZ"])
     opticToUserRot = np.array([getattr(calib.intrinsicCalibration.camRefToOpticalSystem, "rot"+a) for a in "XYZ"])
     X,Y,Z,D = o3r_uncompress_di.xyzdFromDistance(np.array(ifout_compr.distance), ifout_compr.distanceResolution, 
                                                  opticToUserTrans, opticToUserRot,
                                                  ifout_compr.intrinsicCalib.modelID,
                                                  ifout_compr.intrinsicCalib.modelParameters,
                                                  ifout_compr.width, ifout_compr.height)
     A = o3r_uncompress_di.convertAmplitude(np.array(ifout_compr.amplitude), ifout_compr.amplitudeResolution, ifout_compr.width, ifout_compr.height)
     R = np.reshape(ifout_compr.reflectivity, (ifout_compr.height, ifout_compr.width))
-    res = dict(X=X,Y=Y,Z=Z,D=D,A=A,R=R,C=np.reshape(ifout_compr.confidence[:A.size], A.shape),
+    res = dict(X=X,Y=Y,Z=Z,D=D,A=A,R=R,
                camRefToOpticalSystem=dict(trans=opticToUserTrans,rot=opticToUserRot),
                intrinsic=dict(modelID=ifout_compr.intrinsicCalib.modelID,modelParameters=np.array(ifout_compr.intrinsicCalib.modelParameters)),
                inverseIntrinsic=dict(modelID=ifout_compr.inverseIntrinsicCalib.modelID,modelParameters=np.array(ifout_compr.inverseIntrinsicCalib.modelParameters)),
                )
     return res
 
-def set_extrinsic_zero(o3r_object, port, mode):
+def set_extrinsic_zero(o3r_object,port):
     port=f"port{port}"
-    logger.info("Resetting /ports/%s", port)
-    o3r_object.reset("/ports/%s" % port)
-    o3r_object.set({'ports':{port:{'state':'CONF', 'mode': mode}}})
+    o3r_object.set({'ports':{port:{'state':'CONF'}}})
     o3r_object.set({'ports':{port:{'processing':{'extrinsicHeadToUser': {'rotX': 0.0,'rotY': 0.0, 'rotZ': 0.0, 'transX': 0.0, 'transY': 0.0, 'transZ': 0.0}}}}})
     o3r_object.set({'ports':{port:{'state':'RUN'}}})
 
     return o3r_object
 
-def grab_ifm3d_frame(ip, port, mode):
+def grab_ifm3d_frame(ip,port):
     ifm3dpy_version = tuple(int(x) for x in ifm3dpy.__version__.split("."))
-    if ifm3dpy_version <= (1,0,0):
-        raise RuntimeError("Need a later version due to issues in ifm3dpy 1.0.0")
-    if mode == "extrinsic_calib" and ifm3dpy_version <= (1,2,2):
-        raise RuntimeError("Need a later version of ifm3dpy for using extrinsic_calib mode")
-    # updated API
-    o3r = ifm3dpy.O3R(ip=ip)
-    final_port = o3r.get([f"/ports/port{port}/data/pcicTCPPort"])["ports"][f"port{port}"]["data"]["pcicTCPPort"]
-    oldConfig=o3r.get([f"/ports/port{port}"])
-    try:
-        o3r=set_extrinsic_zero(o3r, port, mode)
-        frame_grabber=ifm3dpy.FrameGrabber(o3r,pcic_port=final_port)
-        frame_grabber.start()
-        ok, frame = frame_grabber.wait_for_frame().wait_for(timeout_ms=10000)
-        if not ok:
-            raise ValueError #Exception('fg-timeout on ' + port + ' reached')
-        xyz=frame.get_buffer(ifm3dpy.buffer_id.XYZ)
-        ampl=frame.get_buffer(ifm3dpy.buffer_id.NORM_AMPLITUDE_IMAGE)
-        conf=frame.get_buffer(ifm3dpy.buffer_id.CONFIDENCE_IMAGE)
-        dist=frame.get_buffer(ifm3dpy.buffer_id.RADIAL_DISTANCE_IMAGE)
-        refl=frame.get_buffer(ifm3dpy.buffer_id.REFLECTIVITY)
-        invIntrinsic = frame.get_buffer(ifm3dpy.buffer_id.INVERSE_INTRINSIC_CALIBRATION).tobytes()
-        invIntrinsicModelID, *invIntrinsicModelParams = struct.unpack("<I32f", invIntrinsic)
-        extrinsics = frame.get_buffer(ifm3dpy.buffer_id.EXTRINSIC_CALIB).flatten()
-        result = {
-            'A': ampl,
-            'C': conf,
-            'D': dist,
-            'X': xyz[:,:,0],
-            'Y': xyz[:,:,1],
-            'Z': xyz[:,:,2],
-            'R': refl,
-            'inverseIntrinsic': dict(modelID=invIntrinsicModelID,modelParameters=invIntrinsicModelParams),
-            'camRefToOpticalSystem': dict(trans=extrinsics[0:3], rot=extrinsics[3:6])
-        }
-        if mode == "extrinsic_calib":
-            # need to grab another frame with "normal" mode for validation purpose
-            frame_grabber.stop()
+    if ifm3dpy_version < (1,0,0):
+        logger.warning("Using ifm3dpy legacy version. Consider updating to a version >= 1.0.1")
+        # legacy API
+        o3r=ifm3dpy.O3RCamera(ip)
+        final_port=o3r.port("port%d" %port).pcic_port
+
+        oldCalib=o3r.get([f"/ports/port{port}/processing/extrinsicHeadToUser"])
+        try:  
+            o3r=set_extrinsic_zero(o3r,port)
+            frame_grabber=ifm3dpy.FrameGrabber(o3r,pcic_port=final_port)
+            im = ifm3dpy.ImageBuffer()
+            if frame_grabber.wait_for_frame(im, 10000)==False:
+                raise ValueError #Exception('fg-timeout on ' + port + ' reached')
+            xyz=im.xyz_image()
+            invIntrinsic=im.inverse_intrinsics()
+            invIntrinsic=np.array(invIntrinsic,dtype=float)
+            frame = {'A': im.amplitude_image(),'D': im.distance_image(),'X':xyz[:,:,0],'Y':xyz[:,:,1],'Z':xyz[:,:,2],'R': np.zeros((172, 224)),'inverseIntrinsic': dict(modelID=1,modelParameters=invIntrinsic),
+                    'camRefToOpticalSystem': dict(trans=np.array(im.extrinsics()[0:3]), rot=np.array(im.extrinsics()[3:6]) )}
+        finally:
+            o3r.set(oldCalib)
+    else:
+        if ifm3dpy_version == (1,0,0):
+            raise RuntimeError("Need a later version due to issues in ifm3dpy 1.0.0")
+        # updated API
+        o3r = ifm3dpy.O3R(ip=ip)
+        final_port = o3r.get([f"/ports/port{port}/data/pcicTCPPort"])["ports"][f"port{port}"]["data"]["pcicTCPPort"]
+        oldCalib=o3r.get([f"/ports/port{port}/processing/extrinsicHeadToUser"])
+        try:  
+            o3r=set_extrinsic_zero(o3r,port)
             frame_grabber=ifm3dpy.FrameGrabber(o3r,pcic_port=final_port)
-            o3r = set_extrinsic_zero(o3r, port, "standard_range4m")
             frame_grabber.start()
             ok, frame = frame_grabber.wait_for_frame().wait_for(timeout_ms=10000)
             if not ok:
                 raise ValueError #Exception('fg-timeout on ' + port + ' reached')
             xyz=frame.get_buffer(ifm3dpy.buffer_id.XYZ)
+            ampl=frame.get_buffer(ifm3dpy.buffer_id.NORM_AMPLITUDE_IMAGE)
             dist=frame.get_buffer(ifm3dpy.buffer_id.RADIAL_DISTANCE_IMAGE)
+            refl=frame.get_buffer(ifm3dpy.buffer_id.REFLECTIVITY)
             invIntrinsic = frame.get_buffer(ifm3dpy.buffer_id.INVERSE_INTRINSIC_CALIBRATION).tobytes()
             invIntrinsicModelID, *invIntrinsicModelParams = struct.unpack("<I32f", invIntrinsic)
             extrinsics = frame.get_buffer(ifm3dpy.buffer_id.EXTRINSIC_CALIB).flatten()
-            result.update({
+            frame = {
+                'A': ampl,
                 'D': dist,
                 'X': xyz[:,:,0],
                 'Y': xyz[:,:,1],
                 'Z': xyz[:,:,2],
+                'R': refl,
                 'inverseIntrinsic': dict(modelID=invIntrinsicModelID,modelParameters=invIntrinsicModelParams),
                 'camRefToOpticalSystem': dict(trans=extrinsics[0:3], rot=extrinsics[3:6])
-            })
-    finally:
-        o3r.set(oldConfig)
-    return result
+            }
+        finally:
+            o3r.set(oldCalib)
+    return frame
```

## Comparing `o3r_algo_utilities-1.0.11.dist-info/LICENSE` & `o3r_algo_utilities-1.0.8.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `o3r_algo_utilities-1.0.11.dist-info/METADATA` & `o3r_algo_utilities-1.0.8.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: o3r-algo-utilities
-Version: 1.0.11
+Version: 1.0.8
 Summary: Algorithm examples related to the ifm O3R product.
 Home-page: UNKNOWN
 License: Apache 2.0 License
 Keywords: ifm,o3r,point_cloud
 Platform: UNKNOWN
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Programming Language :: Python :: 3
```

## Comparing `o3r_algo_utilities-1.0.11.dist-info/RECORD` & `o3r_algo_utilities-1.0.8.dist-info/RECORD`

 * *Files 25% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 o3r_algo_utilities/__init__.py,sha256=2k4tkihqC0tf69Sn417v9_BlHLVnPgYMP_vpg0CIbLo,152
 o3r_algo_utilities/o3r_uncompress_di.py,sha256=RVdM-O-BMqmeK_RrfnaKOAouBFr90Yt8-ZeKGySgX9A,9623
 o3r_algo_utilities/calib/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-o3r_algo_utilities/calib/calibration.py,sha256=5E6I_R-yDJyDzZQC-G77Gujl6WUALarja5BNGU013tI,27657
+o3r_algo_utilities/calib/calibration.py,sha256=nvQ003YrKkU3V7qbas8FxwXpRCcWqNFqR72fJuBHXiY,26875
 o3r_algo_utilities/calib/point_correspondences.py,sha256=Nr203fpR6UgqCDA9XryG9YfJmDU8SmCHUMIyvDVrsPM,11458
-o3r_algo_utilities/calib/sources.py,sha256=LF3MSAloPDOUTJEDRcSsE8gvZ6AJ_rrVO8sXXja3u0c,11230
-o3r_algo_utilities/calib/vpu/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-o3r_algo_utilities/calib/vpu/vpu_extrinsic_calibration.py,sha256=6HDpwRBvnN_DMvEF1h81qlNMJTk32TtsqC7yV-wcFEw,16515
-o3r_algo_utilities/calib/vpu/vpu_misalignment_estimation.py,sha256=DBQ6sgjK5UHVfQErRrEBZJ2KwYVZ0YhSmQMexTFOl7I,40776
-o3r_algo_utilities-1.0.11.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-o3r_algo_utilities-1.0.11.dist-info/METADATA,sha256=ZqKKf60lIncby6BVfrkpm1nptlq4Q8vGokAM9f1wc04,779
-o3r_algo_utilities-1.0.11.dist-info/NOTICE,sha256=mdGXqTKd7o-xo6e52DIQacCMJL3FfuWNDyhzqJsYgc8,57
-o3r_algo_utilities-1.0.11.dist-info/WHEEL,sha256=YUYzQ6UQdoqxXjimOitTqynltBCkwY6qlTfTh2IzqQU,97
-o3r_algo_utilities-1.0.11.dist-info/entry_points.txt,sha256=ihB-3lBpYWnzuqFYltpJfq6q6i1UPg4JQsIQoJnC_k4,83
-o3r_algo_utilities-1.0.11.dist-info/top_level.txt,sha256=x4DaYgM4OdJWjjNY5EB3x9fEv7ZwPkNsRxeTMwCYYh0,19
-o3r_algo_utilities-1.0.11.dist-info/RECORD,,
+o3r_algo_utilities/calib/sources.py,sha256=UZg39VI5o_xFmLAyejvvNfGj7mBTrVDCNqJJ3LxCdQ8,8891
+o3r_algo_utilities-1.0.8.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+o3r_algo_utilities-1.0.8.dist-info/METADATA,sha256=t1uG1ba0d5LyYPB03VyR_JeonGvFaR75Rm2K-417QsI,778
+o3r_algo_utilities-1.0.8.dist-info/NOTICE,sha256=mdGXqTKd7o-xo6e52DIQacCMJL3FfuWNDyhzqJsYgc8,57
+o3r_algo_utilities-1.0.8.dist-info/WHEEL,sha256=YUYzQ6UQdoqxXjimOitTqynltBCkwY6qlTfTh2IzqQU,97
+o3r_algo_utilities-1.0.8.dist-info/entry_points.txt,sha256=ihB-3lBpYWnzuqFYltpJfq6q6i1UPg4JQsIQoJnC_k4,83
+o3r_algo_utilities-1.0.8.dist-info/top_level.txt,sha256=x4DaYgM4OdJWjjNY5EB3x9fEv7ZwPkNsRxeTMwCYYh0,19
+o3r_algo_utilities-1.0.8.dist-info/RECORD,,
```

