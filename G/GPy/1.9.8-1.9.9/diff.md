# Comparing `tmp/GPy-1.9.8.win-amd64-py3.7.exe` & `tmp/GPy-1.9.9.win-amd64-py3.7.exe`

## zipinfo {}

```diff
@@ -1,303 +1,306 @@
-Zip file size: 2047959 bytes, number of entries: 299
+Zip file size: 2055734 bytes, number of entries: 302
 warning: 588508 extra bytes at beginning or within zipfile
   (attempting to process anyway)
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy-1.9.8-py3.7.egg-info/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/core/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/examples/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/inference/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/kern/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/likelihoods/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/mappings/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/models/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/plotting/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/testing/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/util/
--rw-rw-rw-  2.0 fat     1053 b- defN 19-May-18 20:23 PLATLIB/GPy/defaults.cfg
--rw-rw-rw-  2.0 fat      509 b- defN 19-May-18 20:23 PLATLIB/GPy/installation.cfg
--rw-rw-rw-  2.0 fat     1934 b- defN 19-May-18 20:23 PLATLIB/GPy/__init__.py
--rw-rw-rw-  2.0 fat       22 b- defN 19-May-18 20:23 PLATLIB/GPy/__version__.py
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/core/parameterization/
--rw-rw-rw-  2.0 fat    32513 b- defN 19-May-18 20:23 PLATLIB/GPy/core/gp.py
--rw-rw-rw-  2.0 fat     4245 b- defN 19-May-18 20:23 PLATLIB/GPy/core/gp_grid.py
--rw-rw-rw-  2.0 fat     2510 b- defN 19-May-18 20:23 PLATLIB/GPy/core/mapping.py
--rw-rw-rw-  2.0 fat     5241 b- defN 19-May-18 20:23 PLATLIB/GPy/core/model.py
--rw-rw-rw-  2.0 fat     6354 b- defN 19-May-18 20:23 PLATLIB/GPy/core/sparse_gp.py
--rw-rw-rw-  2.0 fat     5192 b- defN 19-May-18 20:23 PLATLIB/GPy/core/sparse_gp_mpi.py
--rw-rw-rw-  2.0 fat     4622 b- defN 19-May-18 20:23 PLATLIB/GPy/core/svgp.py
--rw-rw-rw-  2.0 fat    20412 b- defN 19-May-18 20:23 PLATLIB/GPy/core/symbolic.py
--rw-rw-rw-  2.0 fat     1958 b- defN 19-May-18 20:23 PLATLIB/GPy/core/__init__.py
--rw-rw-rw-  2.0 fat      275 b- defN 19-May-18 20:23 PLATLIB/GPy/core/parameterization/param.py
--rw-rw-rw-  2.0 fat     1856 b- defN 19-May-18 20:23 PLATLIB/GPy/core/parameterization/parameterized.py
--rw-rw-rw-  2.0 fat     3668 b- defN 19-May-18 20:23 PLATLIB/GPy/core/parameterization/priorizable.py
--rw-rw-rw-  2.0 fat    47986 b- defN 19-May-18 20:23 PLATLIB/GPy/core/parameterization/priors.py
--rw-rw-rw-  2.0 fat      194 b- defN 19-May-18 20:23 PLATLIB/GPy/core/parameterization/transformations.py
--rw-rw-rw-  2.0 fat    10216 b- defN 19-May-18 20:23 PLATLIB/GPy/core/parameterization/variational.py
--rw-rw-rw-  2.0 fat      329 b- defN 19-May-18 20:23 PLATLIB/GPy/core/parameterization/__init__.py
--rw-rw-rw-  2.0 fat     7792 b- defN 19-May-18 20:23 PLATLIB/GPy/examples/classification.py
--rw-rw-rw-  2.0 fat    25399 b- defN 19-May-18 20:23 PLATLIB/GPy/examples/dimensionality_reduction.py
--rw-rw-rw-  2.0 fat    10700 b- defN 19-May-18 20:23 PLATLIB/GPy/examples/non_gaussian.py
--rw-rw-rw-  2.0 fat    19921 b- defN 19-May-18 20:23 PLATLIB/GPy/examples/regression.py
--rw-rw-rw-  2.0 fat      639 b- defN 19-May-18 20:23 PLATLIB/GPy/examples/state_space.py
--rw-rw-rw-  2.0 fat      413 b- defN 19-May-18 20:23 PLATLIB/GPy/examples/__init__.py
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/inference/latent_function_inference/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/inference/mcmc/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/inference/optimization/
--rw-rw-rw-  2.0 fat      225 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/__init__.py
--rw-rw-rw-  2.0 fat     5766 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/dtc.py
--rw-rw-rw-  2.0 fat     3232 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/exact_gaussian_inference.py
--rw-rw-rw-  2.0 fat     1787 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/exact_studentt_inference.py
--rw-rw-rw-  2.0 fat    28591 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/expectation_propagation.py
--rw-rw-rw-  2.0 fat     3137 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/fitc.py
--rw-rw-rw-  2.0 fat     4341 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/gaussian_grid_inference.py
--rw-rw-rw-  2.0 fat     1826 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/grid_posterior.py
--rw-rw-rw-  2.0 fat     7712 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/inferenceX.py
--rw-rw-rw-  2.0 fat    20817 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/laplace.py
--rw-rw-rw-  2.0 fat     3521 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/pep.py
--rw-rw-rw-  2.0 fat    13706 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/posterior.py
--rw-rw-rw-  2.0 fat     5144 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/svgp.py
--rw-rw-rw-  2.0 fat     6535 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/vardtc_md.py
--rw-rw-rw-  2.0 fat    12140 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/vardtc_svi_multiout.py
--rw-rw-rw-  2.0 fat    12771 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/vardtc_svi_multiout_miss.py
--rw-rw-rw-  2.0 fat    11145 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/var_dtc.py
--rw-rw-rw-  2.0 fat    18492 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/var_dtc_parallel.py
--rw-rw-rw-  2.0 fat     2641 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/var_gauss.py
--rw-rw-rw-  2.0 fat     4827 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/latent_function_inference/__init__.py
--rw-rw-rw-  2.0 fat     7252 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/mcmc/hmc.py
--rw-rw-rw-  2.0 fat     2932 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/mcmc/samplers.py
--rw-rw-rw-  2.0 fat       45 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/mcmc/__init__.py
--rw-rw-rw-  2.0 fat     4925 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/optimization/stochastics.py
--rw-rw-rw-  2.0 fat      247 b- defN 19-May-18 20:23 PLATLIB/GPy/inference/optimization/__init__.py
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/kern/src/
--rw-rw-rw-  2.0 fat     1913 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/__init__.py
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/kern/src/psi_comp/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/kern/src/todo/
--rw-rw-rw-  2.0 fat    17679 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/add.py
--rw-rw-rw-  2.0 fat    10243 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/basis_funcs.py
--rw-rw-rw-  2.0 fat     2161 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/brownian.py
--rw-rw-rw-  2.0 fat     5193 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/coregionalize.py
--rw-rw-rw-  2.0 fat   364545 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/coregionalize_cython.c
--rw-rw-rw-  2.0 fat    55296 b- defN 19-May-18 20:28 PLATLIB/GPy/kern/src/coregionalize_cython.cp37-win_amd64.pyd
--rw-rw-rw-  2.0 fat     1277 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/coregionalize_cython.pyx
--rw-rw-rw-  2.0 fat    22937 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/eq_ode1.py
--rw-rw-rw-  2.0 fat    51967 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/eq_ode2.py
--rw-rw-rw-  2.0 fat     2735 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/grid_kerns.py
--rw-rw-rw-  2.0 fat    10422 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/independent_outputs.py
--rw-rw-rw-  2.0 fat     3838 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/integral.py
--rw-rw-rw-  2.0 fat     6127 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/integral_limits.py
--rw-rw-rw-  2.0 fat    18275 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/kern.py
--rw-rw-rw-  2.0 fat     7024 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/kernel_slice_operations.py
--rw-rw-rw-  2.0 fat     9242 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/linear.py
--rw-rw-rw-  2.0 fat     6604 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/mlp.py
--rw-rw-rw-  2.0 fat     6207 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/multidimensional_integral_limits.py
--rw-rw-rw-  2.0 fat     7150 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/multioutput_kern.py
--rw-rw-rw-  2.0 fat    12840 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/ODE_st.py
--rw-rw-rw-  2.0 fat     7626 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/ODE_t.py
--rw-rw-rw-  2.0 fat    15111 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/ODE_UY.py
--rw-rw-rw-  2.0 fat    15545 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/ODE_UYC.py
--rw-rw-rw-  2.0 fat    26459 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/periodic.py
--rw-rw-rw-  2.0 fat     1948 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/poly.py
--rw-rw-rw-  2.0 fat     8449 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/prod.py
--rw-rw-rw-  2.0 fat     5013 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/rbf.py
--rw-rw-rw-  2.0 fat     1675 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/sde_brownian.py
--rw-rw-rw-  2.0 fat     1918 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/sde_linear.py
--rw-rw-rw-  2.0 fat     5159 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/sde_matern.py
--rw-rw-rw-  2.0 fat     8316 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/sde_standard_periodic.py
--rw-rw-rw-  2.0 fat     2578 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/sde_static.py
--rw-rw-rw-  2.0 fat     7861 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/sde_stationary.py
--rw-rw-rw-  2.0 fat     2089 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/spline.py
--rw-rw-rw-  2.0 fat     9035 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/splitKern.py
--rw-rw-rw-  2.0 fat     7511 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/standard_periodic.py
--rw-rw-rw-  2.0 fat    10668 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/static.py
--rw-rw-rw-  2.0 fat    26688 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/stationary.py
--rw-rw-rw-  2.0 fat   960530 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/stationary_cython.c
--rw-rw-rw-  2.0 fat   156160 b- defN 19-May-18 20:28 PLATLIB/GPy/kern/src/stationary_cython.cp37-win_amd64.pyd
--rw-rw-rw-  2.0 fat     2211 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/stationary_cython.pyx
--rw-rw-rw-  2.0 fat     1101 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/stationary_utils.c
--rw-rw-rw-  2.0 fat      222 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/stationary_utils.h
--rw-rw-rw-  2.0 fat     2875 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/symbolic.py
--rw-rw-rw-  2.0 fat     5515 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/symmetric.py
--rw-rw-rw-  2.0 fat      204 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/sympy_helpers.h
--rw-rw-rw-  2.0 fat     7906 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/trunclinear.py
--rw-rw-rw-  2.0 fat       23 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/__init__.py
--rw-rw-rw-  2.0 fat     3582 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/psi_comp/gaussherm.py
--rw-rw-rw-  2.0 fat     3548 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/psi_comp/linear_psi_comp.py
--rw-rw-rw-  2.0 fat     5980 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/psi_comp/rbf_psi_comp.py
--rw-rw-rw-  2.0 fat    21150 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/psi_comp/rbf_psi_gpucomp.py
--rw-rw-rw-  2.0 fat     2983 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/psi_comp/sslinear_psi_comp.py
--rw-rw-rw-  2.0 fat    18839 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/psi_comp/ssrbf_psi_comp.py
--rw-rw-rw-  2.0 fat    24369 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/psi_comp/ssrbf_psi_gpucomp.py
--rw-rw-rw-  2.0 fat     3618 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/psi_comp/__init__.py
--rw-rw-rw-  2.0 fat      503 b- defN 19-May-18 20:23 PLATLIB/GPy/kern/src/todo/odekern1.c
--rw-rw-rw-  2.0 fat    10804 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/bernoulli.py
--rw-rw-rw-  2.0 fat     7803 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/binomial.py
--rw-rw-rw-  2.0 fat     4727 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/exponential.py
--rw-rw-rw-  2.0 fat     5833 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/gamma.py
--rw-rw-rw-  2.0 fat    14689 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/gaussian.py
--rw-rw-rw-  2.0 fat    36586 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/likelihood.py
--rw-rw-rw-  2.0 fat     6046 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/link_functions.py
--rw-rw-rw-  2.0 fat    12932 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/loggaussian.py
--rw-rw-rw-  2.0 fat    13079 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/loglogistic.py
--rw-rw-rw-  2.0 fat     3266 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/mixed_noise.py
--rw-rw-rw-  2.0 fat    10622 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/multioutput_likelihood.py
--rw-rw-rw-  2.0 fat     5295 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/poisson.py
--rw-rw-rw-  2.0 fat    13084 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/student_t.py
--rw-rw-rw-  2.0 fat    12109 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/weibull.py
--rw-rw-rw-  2.0 fat      437 b- defN 19-May-18 20:23 PLATLIB/GPy/likelihoods/__init__.py
--rw-rw-rw-  2.0 fat     1308 b- defN 19-May-18 20:23 PLATLIB/GPy/mappings/additive.py
--rw-rw-rw-  2.0 fat     1274 b- defN 19-May-18 20:23 PLATLIB/GPy/mappings/compound.py
--rw-rw-rw-  2.0 fat     1637 b- defN 19-May-18 20:23 PLATLIB/GPy/mappings/constant.py
--rw-rw-rw-  2.0 fat      895 b- defN 19-May-18 20:23 PLATLIB/GPy/mappings/identity.py
--rw-rw-rw-  2.0 fat     1602 b- defN 19-May-18 20:23 PLATLIB/GPy/mappings/kernel.py
--rw-rw-rw-  2.0 fat     1942 b- defN 19-May-18 20:23 PLATLIB/GPy/mappings/linear.py
--rw-rw-rw-  2.0 fat     1935 b- defN 19-May-18 20:23 PLATLIB/GPy/mappings/mlp.py
--rw-rw-rw-  2.0 fat     5430 b- defN 19-May-18 20:23 PLATLIB/GPy/mappings/mlpext.py
--rw-rw-rw-  2.0 fat     3707 b- defN 19-May-18 20:23 PLATLIB/GPy/mappings/piecewise_linear.py
--rw-rw-rw-  2.0 fat      392 b- defN 19-May-18 20:23 PLATLIB/GPy/mappings/__init__.py
--rw-rw-rw-  2.0 fat     4457 b- defN 19-May-18 20:23 PLATLIB/GPy/models/bayesian_gplvm.py
--rw-rw-rw-  2.0 fat     5947 b- defN 19-May-18 20:23 PLATLIB/GPy/models/bayesian_gplvm_minibatch.py
--rw-rw-rw-  2.0 fat     1466 b- defN 19-May-18 20:23 PLATLIB/GPy/models/bcgplvm.py
--rw-rw-rw-  2.0 fat     1046 b- defN 19-May-18 20:23 PLATLIB/GPy/models/dpgplvm.py
--rw-rw-rw-  2.0 fat     1357 b- defN 19-May-18 20:23 PLATLIB/GPy/models/gplvm.py
--rw-rw-rw-  2.0 fat     2545 b- defN 19-May-18 20:23 PLATLIB/GPy/models/gp_classification.py
--rw-rw-rw-  2.0 fat     1935 b- defN 19-May-18 20:23 PLATLIB/GPy/models/gp_coregionalized_regression.py
--rw-rw-rw-  2.0 fat     1195 b- defN 19-May-18 20:23 PLATLIB/GPy/models/gp_grid_regression.py
--rw-rw-rw-  2.0 fat     1151 b- defN 19-May-18 20:23 PLATLIB/GPy/models/gp_heteroscedastic_regression.py
--rw-rw-rw-  2.0 fat     4361 b- defN 19-May-18 20:23 PLATLIB/GPy/models/gp_kronecker_gaussian_regression.py
--rw-rw-rw-  2.0 fat    10598 b- defN 19-May-18 20:23 PLATLIB/GPy/models/gp_multiout_regression.py
--rw-rw-rw-  2.0 fat    11908 b- defN 19-May-18 20:23 PLATLIB/GPy/models/gp_multiout_regression_md.py
--rw-rw-rw-  2.0 fat     4059 b- defN 19-May-18 20:23 PLATLIB/GPy/models/gp_offset_regression.py
--rw-rw-rw-  2.0 fat     2037 b- defN 19-May-18 20:23 PLATLIB/GPy/models/gp_regression.py
--rw-rw-rw-  2.0 fat     1168 b- defN 19-May-18 20:23 PLATLIB/GPy/models/gp_var_gauss.py
--rw-rw-rw-  2.0 fat    17219 b- defN 19-May-18 20:23 PLATLIB/GPy/models/gradient_checker.py
--rw-rw-rw-  2.0 fat    21083 b- defN 19-May-18 20:23 PLATLIB/GPy/models/ibp_lfm.py
--rw-rw-rw-  2.0 fat     5297 b- defN 19-May-18 20:23 PLATLIB/GPy/models/input_warped_gp.py
--rw-rw-rw-  2.0 fat    15289 b- defN 19-May-18 20:23 PLATLIB/GPy/models/mrd.py
--rw-rw-rw-  2.0 fat     1352 b- defN 19-May-18 20:23 PLATLIB/GPy/models/one_vs_all_classification.py
--rw-rw-rw-  2.0 fat     1399 b- defN 19-May-18 20:23 PLATLIB/GPy/models/one_vs_all_sparse_classification.py
--rw-rw-rw-  2.0 fat     1890 b- defN 19-May-18 20:23 PLATLIB/GPy/models/sparse_gplvm.py
--rw-rw-rw-  2.0 fat     6586 b- defN 19-May-18 20:23 PLATLIB/GPy/models/sparse_gp_classification.py
--rw-rw-rw-  2.0 fat     3024 b- defN 19-May-18 20:23 PLATLIB/GPy/models/sparse_gp_coregionalized_regression.py
--rw-rw-rw-  2.0 fat    15415 b- defN 19-May-18 20:23 PLATLIB/GPy/models/sparse_gp_minibatch.py
--rw-rw-rw-  2.0 fat     2664 b- defN 19-May-18 20:23 PLATLIB/GPy/models/sparse_gp_regression.py
--rw-rw-rw-  2.0 fat     4089 b- defN 19-May-18 20:23 PLATLIB/GPy/models/sparse_gp_regression_md.py
--rw-rw-rw-  2.0 fat    15198 b- defN 19-May-18 20:23 PLATLIB/GPy/models/ss_gplvm.py
--rw-rw-rw-  2.0 fat    12940 b- defN 19-May-18 20:23 PLATLIB/GPy/models/ss_mrd.py
--rw-rw-rw-  2.0 fat    24813 b- defN 19-May-18 20:23 PLATLIB/GPy/models/state_space.py
--rw-rw-rw-  2.0 fat  1923801 b- defN 19-May-18 20:23 PLATLIB/GPy/models/state_space_cython.c
--rw-rw-rw-  2.0 fat   414720 b- defN 19-May-18 20:28 PLATLIB/GPy/models/state_space_cython.cp37-win_amd64.pyd
--rw-rw-rw-  2.0 fat    41650 b- defN 19-May-18 20:23 PLATLIB/GPy/models/state_space_cython.pyx
--rw-rw-rw-  2.0 fat   143832 b- defN 19-May-18 20:23 PLATLIB/GPy/models/state_space_main.py
--rw-rw-rw-  2.0 fat    16885 b- defN 19-May-18 20:23 PLATLIB/GPy/models/state_space_model.py
--rw-rw-rw-  2.0 fat      321 b- defN 19-May-18 20:23 PLATLIB/GPy/models/state_space_setup.py
--rw-rw-rw-  2.0 fat    12410 b- defN 19-May-18 20:23 PLATLIB/GPy/models/tp_regression.py
--rw-rw-rw-  2.0 fat     7238 b- defN 19-May-18 20:23 PLATLIB/GPy/models/warped_gp.py
--rw-rw-rw-  2.0 fat     1579 b- defN 19-May-18 20:23 PLATLIB/GPy/models/__init__.py
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/plotting/gpy_plot/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/plotting/matplot_dep/
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/plotting/plotly_dep/
--rw-rw-rw-  2.0 fat    13998 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/abstract_plotting_library.py
--rw-rw-rw-  2.0 fat     5686 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/Tango.py
--rw-rw-rw-  2.0 fat     7486 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/__init__.py
--rw-rw-rw-  2.0 fat    13885 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/gpy_plot/data_plots.py
--rw-rw-rw-  2.0 fat    23732 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/gpy_plot/gp_plots.py
--rw-rw-rw-  2.0 fat     1233 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/gpy_plot/inference_plots.py
--rw-rw-rw-  2.0 fat     6826 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/gpy_plot/kernel_plots.py
--rw-rw-rw-  2.0 fat    18468 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/gpy_plot/latent_plots.py
--rw-rw-rw-  2.0 fat    15084 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/gpy_plot/plot_util.py
--rw-rw-rw-  2.0 fat      123 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/gpy_plot/__init__.py
-drwxrwxrwx  2.0 fat        0 b- stor 19-May-18 20:32 PLATLIB/GPy/plotting/matplot_dep/controllers/
--rw-rw-rw-  2.0 fat     8394 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/base_plots.py
--rw-rw-rw-  2.0 fat     3838 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/defaults.py
--rw-rw-rw-  2.0 fat     2159 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/img_plots.py
--rw-rw-rw-  2.0 fat     3517 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/mapping_plots.py
--rw-rw-rw-  2.0 fat     5721 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/maps.py
--rw-rw-rw-  2.0 fat    13963 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/plot_definitions.py
--rw-rw-rw-  2.0 fat      909 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/priors_plots.py
--rw-rw-rw-  2.0 fat      806 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/ssgplvm.py
--rw-rw-rw-  2.0 fat     1323 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/svig_plots.py
--rw-rw-rw-  2.0 fat     6172 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/util.py
--rw-rw-rw-  2.0 fat     4094 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/variational_plots.py
--rw-rw-rw-  2.0 fat    23220 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/visualize.py
--rw-rw-rw-  2.0 fat      698 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/__init__.py
--rw-rw-rw-  2.0 fat     5386 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/controllers/axis_event_controller.py
--rw-rw-rw-  2.0 fat     3647 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/controllers/imshow_controller.py
--rw-rw-rw-  2.0 fat       70 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/matplot_dep/controllers/__init__.py
--rw-rw-rw-  2.0 fat     3977 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/plotly_dep/defaults.py
--rw-rw-rw-  2.0 fat    16743 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/plotly_dep/plot_definitions.py
--rw-rw-rw-  2.0 fat        0 b- defN 19-May-18 20:23 PLATLIB/GPy/plotting/plotly_dep/__init__.py
--rw-rw-rw-  2.0 fat     3148 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/cython_tests.py
--rw-rw-rw-  2.0 fat     6431 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/ep_likelihood_tests.py
--rw-rw-rw-  2.0 fat     3721 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/examples_tests.py
--rw-rw-rw-  2.0 fat     1138 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/fitc.py
--rw-rw-rw-  2.0 fat    21124 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/gpy_kernels_state_space_tests.py
--rw-rw-rw-  2.0 fat     3398 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/gp_tests.py
--rw-rw-rw-  2.0 fat     1964 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/grid_tests.py
--rw-rw-rw-  2.0 fat     8585 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/inference_tests.py
--rw-rw-rw-  2.0 fat    34625 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/kernel_tests.py
--rw-rw-rw-  2.0 fat    37268 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/likelihood_tests.py
--rw-rw-rw-  2.0 fat     2166 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/linalg_test.py
--rw-rw-rw-  2.0 fat     6783 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/link_function_tests.py
--rw-rw-rw-  2.0 fat     2853 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/mapping_tests.py
--rw-rw-rw-  2.0 fat     3340 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/meanfunc_tests.py
--rw-rw-rw-  2.0 fat    13260 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/minibatch_tests.py
--rw-rw-rw-  2.0 fat      862 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/misc_tests.py
--rw-rw-rw-  2.0 fat    49879 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/model_tests.py
--rw-rw-rw-  2.0 fat     2682 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/mpi_tests.py
--rw-rw-rw-  2.0 fat     3437 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/pep_tests.py
--rw-rw-rw-  2.0 fat     5315 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/pickle_tests.py
--rw-rw-rw-  2.0 fat    21775 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/plotting_tests.py
--rw-rw-rw-  2.0 fat     5630 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/prior_tests.py
--rw-rw-rw-  2.0 fat     1316 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/quadrature_tests.py
--rw-rw-rw-  2.0 fat     4069 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/rv_transformation_tests.py
--rw-rw-rw-  2.0 fat    15358 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/serialization_tests.py
--rw-rw-rw-  2.0 fat    44812 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/state_space_main_tests.py
--rw-rw-rw-  2.0 fat     1851 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/svgp_tests.py
--rw-rw-rw-  2.0 fat     5466 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/tp_tests.py
--rw-rw-rw-  2.0 fat    10489 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/util_tests.py
--rw-rw-rw-  2.0 fat     2610 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/variational_tests.py
--rw-rw-rw-  2.0 fat      306 b- defN 19-May-18 20:23 PLATLIB/GPy/testing/__init__.py
--rw-rw-rw-  2.0 fat     4522 b- defN 19-May-18 20:23 PLATLIB/GPy/util/block_matrices.py
--rw-rw-rw-  2.0 fat     3367 b- defN 19-May-18 20:23 PLATLIB/GPy/util/choleskies.py
--rw-rw-rw-  2.0 fat   996162 b- defN 19-May-18 20:23 PLATLIB/GPy/util/choleskies_cython.c
--rw-rw-rw-  2.0 fat   165888 b- defN 19-May-18 20:28 PLATLIB/GPy/util/choleskies_cython.cp37-win_amd64.pyd
--rw-rw-rw-  2.0 fat     3727 b- defN 19-May-18 20:23 PLATLIB/GPy/util/choleskies_cython.pyx
--rw-rw-rw-  2.0 fat     1489 b- defN 19-May-18 20:23 PLATLIB/GPy/util/classification.py
--rw-rw-rw-  2.0 fat     6520 b- defN 19-May-18 20:23 PLATLIB/GPy/util/cluster_with_offset.py
--rw-rw-rw-  2.0 fat     1241 b- defN 19-May-18 20:23 PLATLIB/GPy/util/config.py
--rw-rw-rw-  2.0 fat    65186 b- defN 19-May-18 20:23 PLATLIB/GPy/util/datasets.py
--rw-rw-rw-  2.0 fat    34017 b- defN 19-May-18 20:23 PLATLIB/GPy/util/data_resources.json
--rw-rw-rw-  2.0 fat     1127 b- defN 19-May-18 20:23 PLATLIB/GPy/util/debug.py
--rw-rw-rw-  2.0 fat      566 b- defN 19-May-18 20:23 PLATLIB/GPy/util/decorators.py
--rw-rw-rw-  2.0 fat     3853 b- defN 19-May-18 20:23 PLATLIB/GPy/util/diag.py
--rw-rw-rw-  2.0 fat     2429 b- defN 19-May-18 20:23 PLATLIB/GPy/util/football_teams.json
--rw-rw-rw-  2.0 fat     1329 b- defN 19-May-18 20:23 PLATLIB/GPy/util/functions.py
--rw-rw-rw-  2.0 fat     1152 b- defN 19-May-18 20:23 PLATLIB/GPy/util/gpu_init.py
--rw-rw-rw-  2.0 fat      874 b- defN 19-May-18 20:23 PLATLIB/GPy/util/initialization.py
--rw-rw-rw-  2.0 fat     8588 b- defN 19-May-18 20:23 PLATLIB/GPy/util/input_warping_functions.py
--rw-rw-rw-  2.0 fat    11712 b- defN 19-May-18 20:23 PLATLIB/GPy/util/linalg.py
--rw-rw-rw-  2.0 fat   331809 b- defN 19-May-18 20:23 PLATLIB/GPy/util/linalg_cython.c
--rw-rw-rw-  2.0 fat    44032 b- defN 19-May-18 20:28 PLATLIB/GPy/util/linalg_cython.cp37-win_amd64.pyd
--rw-rw-rw-  2.0 fat     1038 b- defN 19-May-18 20:23 PLATLIB/GPy/util/linalg_cython.pyx
--rw-rw-rw-  2.0 fat     3038 b- defN 19-May-18 20:23 PLATLIB/GPy/util/linalg_gpu.py
--rw-rw-rw-  2.0 fat     3554 b- defN 19-May-18 20:23 PLATLIB/GPy/util/ln_diff_erfs.py
--rw-rw-rw-  2.0 fat     5919 b- defN 19-May-18 20:23 PLATLIB/GPy/util/misc.py
--rw-rw-rw-  2.0 fat    27949 b- defN 19-May-18 20:23 PLATLIB/GPy/util/mocap.py
--rw-rw-rw-  2.0 fat     3588 b- defN 19-May-18 20:23 PLATLIB/GPy/util/multioutput.py
--rw-rw-rw-  2.0 fat    12223 b- defN 19-May-18 20:23 PLATLIB/GPy/util/netpbmfile.py
--rw-rw-rw-  2.0 fat     3915 b- defN 19-May-18 20:23 PLATLIB/GPy/util/normalizer.py
--rw-rw-rw-  2.0 fat     1752 b- defN 19-May-18 20:23 PLATLIB/GPy/util/parallel.py
--rw-rw-rw-  2.0 fat     4747 b- defN 19-May-18 20:23 PLATLIB/GPy/util/pca.py
--rw-rw-rw-  2.0 fat     4545 b- defN 19-May-18 20:23 PLATLIB/GPy/util/quad_integrate.py
--rw-rw-rw-  2.0 fat      340 b- defN 19-May-18 20:23 PLATLIB/GPy/util/squashers.py
--rw-rw-rw-  2.0 fat     1960 b- defN 19-May-18 20:23 PLATLIB/GPy/util/subarray_and_sorting.py
--rw-rw-rw-  2.0 fat     5982 b- defN 19-May-18 20:23 PLATLIB/GPy/util/univariate_Gaussian.py
--rw-rw-rw-  2.0 fat     7143 b- defN 19-May-18 20:23 PLATLIB/GPy/util/warping_functions.py
--rw-rw-rw-  2.0 fat      513 b- defN 19-May-18 20:23 PLATLIB/GPy/util/__init__.py
--rw-rw-rw-  2.0 fat        1 b- defN 19-May-18 20:32 PLATLIB/GPy-1.9.8-py3.7.egg-info/dependency_links.txt
--rw-rw-rw-  2.0 fat     1286 b- defN 19-May-18 20:32 PLATLIB/GPy-1.9.8-py3.7.egg-info/PKG-INFO
--rw-rw-rw-  2.0 fat      217 b- defN 19-May-18 20:32 PLATLIB/GPy-1.9.8-py3.7.egg-info/requires.txt
--rw-rw-rw-  2.0 fat     9035 b- defN 19-May-18 20:32 PLATLIB/GPy-1.9.8-py3.7.egg-info/SOURCES.txt
--rw-rw-rw-  2.0 fat        4 b- defN 19-May-18 20:32 PLATLIB/GPy-1.9.8-py3.7.egg-info/top_level.txt
-299 files, 7676869 bytes uncompressed, 1413849 bytes compressed:  81.6%
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy-1.9.9-py3.7.egg-info/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/core/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/examples/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/inference/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/kern/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/likelihoods/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/mappings/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/models/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/plotting/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/testing/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/util/
+-rw-rw-rw-  2.0 fat     1053 b- defN 19-Oct-17 08:29 PLATLIB/GPy/defaults.cfg
+-rw-rw-rw-  2.0 fat      509 b- defN 19-Oct-17 08:29 PLATLIB/GPy/installation.cfg
+-rw-rw-rw-  2.0 fat     1934 b- defN 19-Oct-17 08:29 PLATLIB/GPy/__init__.py
+-rw-rw-rw-  2.0 fat       22 b- defN 19-Oct-17 08:29 PLATLIB/GPy/__version__.py
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/core/parameterization/
+-rw-rw-rw-  2.0 fat    32513 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/gp.py
+-rw-rw-rw-  2.0 fat     4245 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/gp_grid.py
+-rw-rw-rw-  2.0 fat     2510 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/mapping.py
+-rw-rw-rw-  2.0 fat     5241 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/model.py
+-rw-rw-rw-  2.0 fat     6354 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/sparse_gp.py
+-rw-rw-rw-  2.0 fat     5192 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/sparse_gp_mpi.py
+-rw-rw-rw-  2.0 fat     4622 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/svgp.py
+-rw-rw-rw-  2.0 fat    20412 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/symbolic.py
+-rw-rw-rw-  2.0 fat     1958 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/__init__.py
+-rw-rw-rw-  2.0 fat      275 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/parameterization/param.py
+-rw-rw-rw-  2.0 fat     1856 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/parameterization/parameterized.py
+-rw-rw-rw-  2.0 fat     3668 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/parameterization/priorizable.py
+-rw-rw-rw-  2.0 fat    47986 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/parameterization/priors.py
+-rw-rw-rw-  2.0 fat      194 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/parameterization/transformations.py
+-rw-rw-rw-  2.0 fat    10216 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/parameterization/variational.py
+-rw-rw-rw-  2.0 fat      329 b- defN 19-Oct-17 08:29 PLATLIB/GPy/core/parameterization/__init__.py
+-rw-rw-rw-  2.0 fat     7792 b- defN 19-Oct-17 08:29 PLATLIB/GPy/examples/classification.py
+-rw-rw-rw-  2.0 fat    25399 b- defN 19-Oct-17 08:29 PLATLIB/GPy/examples/dimensionality_reduction.py
+-rw-rw-rw-  2.0 fat    10700 b- defN 19-Oct-17 08:29 PLATLIB/GPy/examples/non_gaussian.py
+-rw-rw-rw-  2.0 fat    22458 b- defN 19-Oct-17 08:29 PLATLIB/GPy/examples/regression.py
+-rw-rw-rw-  2.0 fat      639 b- defN 19-Oct-17 08:29 PLATLIB/GPy/examples/state_space.py
+-rw-rw-rw-  2.0 fat      413 b- defN 19-Oct-17 08:29 PLATLIB/GPy/examples/__init__.py
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/inference/latent_function_inference/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/inference/mcmc/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/inference/optimization/
+-rw-rw-rw-  2.0 fat      225 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/__init__.py
+-rw-rw-rw-  2.0 fat     5766 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/dtc.py
+-rw-rw-rw-  2.0 fat     3232 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/exact_gaussian_inference.py
+-rw-rw-rw-  2.0 fat     1787 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/exact_studentt_inference.py
+-rw-rw-rw-  2.0 fat    28591 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/expectation_propagation.py
+-rw-rw-rw-  2.0 fat     3137 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/fitc.py
+-rw-rw-rw-  2.0 fat     4341 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/gaussian_grid_inference.py
+-rw-rw-rw-  2.0 fat     1826 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/grid_posterior.py
+-rw-rw-rw-  2.0 fat     7712 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/inferenceX.py
+-rw-rw-rw-  2.0 fat    20817 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/laplace.py
+-rw-rw-rw-  2.0 fat     3521 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/pep.py
+-rw-rw-rw-  2.0 fat    13706 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/posterior.py
+-rw-rw-rw-  2.0 fat     5144 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/svgp.py
+-rw-rw-rw-  2.0 fat     6535 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/vardtc_md.py
+-rw-rw-rw-  2.0 fat    12140 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/vardtc_svi_multiout.py
+-rw-rw-rw-  2.0 fat    12771 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/vardtc_svi_multiout_miss.py
+-rw-rw-rw-  2.0 fat    11145 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/var_dtc.py
+-rw-rw-rw-  2.0 fat    18492 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/var_dtc_parallel.py
+-rw-rw-rw-  2.0 fat     2641 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/var_gauss.py
+-rw-rw-rw-  2.0 fat     4827 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/latent_function_inference/__init__.py
+-rw-rw-rw-  2.0 fat     7252 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/mcmc/hmc.py
+-rw-rw-rw-  2.0 fat     2932 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/mcmc/samplers.py
+-rw-rw-rw-  2.0 fat       45 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/mcmc/__init__.py
+-rw-rw-rw-  2.0 fat     4925 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/optimization/stochastics.py
+-rw-rw-rw-  2.0 fat      247 b- defN 19-Oct-17 08:29 PLATLIB/GPy/inference/optimization/__init__.py
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/kern/src/
+-rw-rw-rw-  2.0 fat     2020 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/__init__.py
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/kern/src/psi_comp/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/kern/src/todo/
+-rw-rw-rw-  2.0 fat    17679 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/add.py
+-rw-rw-rw-  2.0 fat    10243 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/basis_funcs.py
+-rw-rw-rw-  2.0 fat     2161 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/brownian.py
+-rw-rw-rw-  2.0 fat     5193 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/coregionalize.py
+-rw-rw-rw-  2.0 fat   364545 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/coregionalize_cython.c
+-rw-rw-rw-  2.0 fat    55296 b- defN 19-Oct-17 08:32 PLATLIB/GPy/kern/src/coregionalize_cython.cp37-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     1277 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/coregionalize_cython.pyx
+-rw-rw-rw-  2.0 fat     3782 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/diff_kern.py
+-rw-rw-rw-  2.0 fat    22937 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/eq_ode1.py
+-rw-rw-rw-  2.0 fat    51967 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/eq_ode2.py
+-rw-rw-rw-  2.0 fat     2735 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/grid_kerns.py
+-rw-rw-rw-  2.0 fat     9499 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/independent_outputs.py
+-rw-rw-rw-  2.0 fat     3838 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/integral.py
+-rw-rw-rw-  2.0 fat     6127 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/integral_limits.py
+-rw-rw-rw-  2.0 fat    18426 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/kern.py
+-rw-rw-rw-  2.0 fat    11423 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/kernel_slice_operations.py
+-rw-rw-rw-  2.0 fat     9242 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/linear.py
+-rw-rw-rw-  2.0 fat     6604 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/mlp.py
+-rw-rw-rw-  2.0 fat     6207 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/multidimensional_integral_limits.py
+-rw-rw-rw-  2.0 fat     3814 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/multioutput_derivative_kern.py
+-rw-rw-rw-  2.0 fat     7066 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/multioutput_kern.py
+-rw-rw-rw-  2.0 fat    12839 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/ODE_st.py
+-rw-rw-rw-  2.0 fat     7625 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/ODE_t.py
+-rw-rw-rw-  2.0 fat    15110 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/ODE_UY.py
+-rw-rw-rw-  2.0 fat    15544 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/ODE_UYC.py
+-rw-rw-rw-  2.0 fat    26459 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/periodic.py
+-rw-rw-rw-  2.0 fat     1948 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/poly.py
+-rw-rw-rw-  2.0 fat     8449 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/prod.py
+-rw-rw-rw-  2.0 fat     8929 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/rbf.py
+-rw-rw-rw-  2.0 fat     1675 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/sde_brownian.py
+-rw-rw-rw-  2.0 fat     1918 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/sde_linear.py
+-rw-rw-rw-  2.0 fat     5159 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/sde_matern.py
+-rw-rw-rw-  2.0 fat     8316 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/sde_standard_periodic.py
+-rw-rw-rw-  2.0 fat     2578 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/sde_static.py
+-rw-rw-rw-  2.0 fat     7861 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/sde_stationary.py
+-rw-rw-rw-  2.0 fat     2089 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/spline.py
+-rw-rw-rw-  2.0 fat     9034 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/splitKern.py
+-rw-rw-rw-  2.0 fat     7511 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/standard_periodic.py
+-rw-rw-rw-  2.0 fat    10668 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/static.py
+-rw-rw-rw-  2.0 fat    27220 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/stationary.py
+-rw-rw-rw-  2.0 fat   960530 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/stationary_cython.c
+-rw-rw-rw-  2.0 fat   156160 b- defN 19-Oct-17 08:32 PLATLIB/GPy/kern/src/stationary_cython.cp37-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     2211 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/stationary_cython.pyx
+-rw-rw-rw-  2.0 fat     1101 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/stationary_utils.c
+-rw-rw-rw-  2.0 fat      222 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/stationary_utils.h
+-rw-rw-rw-  2.0 fat     2875 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/symbolic.py
+-rw-rw-rw-  2.0 fat     5515 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/symmetric.py
+-rw-rw-rw-  2.0 fat      204 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/sympy_helpers.h
+-rw-rw-rw-  2.0 fat     7906 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/trunclinear.py
+-rw-rw-rw-  2.0 fat       23 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/__init__.py
+-rw-rw-rw-  2.0 fat     3582 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/psi_comp/gaussherm.py
+-rw-rw-rw-  2.0 fat     3548 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/psi_comp/linear_psi_comp.py
+-rw-rw-rw-  2.0 fat     5980 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/psi_comp/rbf_psi_comp.py
+-rw-rw-rw-  2.0 fat    21150 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/psi_comp/rbf_psi_gpucomp.py
+-rw-rw-rw-  2.0 fat     2983 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/psi_comp/sslinear_psi_comp.py
+-rw-rw-rw-  2.0 fat    18839 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/psi_comp/ssrbf_psi_comp.py
+-rw-rw-rw-  2.0 fat    24369 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/psi_comp/ssrbf_psi_gpucomp.py
+-rw-rw-rw-  2.0 fat     3618 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/psi_comp/__init__.py
+-rw-rw-rw-  2.0 fat      503 b- defN 19-Oct-17 08:29 PLATLIB/GPy/kern/src/todo/odekern1.c
+-rw-rw-rw-  2.0 fat    10804 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/bernoulli.py
+-rw-rw-rw-  2.0 fat     9654 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/binomial.py
+-rw-rw-rw-  2.0 fat     4727 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/exponential.py
+-rw-rw-rw-  2.0 fat     5833 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/gamma.py
+-rw-rw-rw-  2.0 fat    14689 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/gaussian.py
+-rw-rw-rw-  2.0 fat    36592 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/likelihood.py
+-rw-rw-rw-  2.0 fat     7031 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/link_functions.py
+-rw-rw-rw-  2.0 fat    12932 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/loggaussian.py
+-rw-rw-rw-  2.0 fat    13079 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/loglogistic.py
+-rw-rw-rw-  2.0 fat     3266 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/mixed_noise.py
+-rw-rw-rw-  2.0 fat    10610 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/multioutput_likelihood.py
+-rw-rw-rw-  2.0 fat     5295 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/poisson.py
+-rw-rw-rw-  2.0 fat    13084 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/student_t.py
+-rw-rw-rw-  2.0 fat    12109 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/weibull.py
+-rw-rw-rw-  2.0 fat      437 b- defN 19-Oct-17 08:29 PLATLIB/GPy/likelihoods/__init__.py
+-rw-rw-rw-  2.0 fat     1308 b- defN 19-Oct-17 08:29 PLATLIB/GPy/mappings/additive.py
+-rw-rw-rw-  2.0 fat     1274 b- defN 19-Oct-17 08:29 PLATLIB/GPy/mappings/compound.py
+-rw-rw-rw-  2.0 fat     1637 b- defN 19-Oct-17 08:29 PLATLIB/GPy/mappings/constant.py
+-rw-rw-rw-  2.0 fat      895 b- defN 19-Oct-17 08:29 PLATLIB/GPy/mappings/identity.py
+-rw-rw-rw-  2.0 fat     1602 b- defN 19-Oct-17 08:29 PLATLIB/GPy/mappings/kernel.py
+-rw-rw-rw-  2.0 fat     1942 b- defN 19-Oct-17 08:29 PLATLIB/GPy/mappings/linear.py
+-rw-rw-rw-  2.0 fat     1935 b- defN 19-Oct-17 08:29 PLATLIB/GPy/mappings/mlp.py
+-rw-rw-rw-  2.0 fat     5430 b- defN 19-Oct-17 08:29 PLATLIB/GPy/mappings/mlpext.py
+-rw-rw-rw-  2.0 fat     3707 b- defN 19-Oct-17 08:29 PLATLIB/GPy/mappings/piecewise_linear.py
+-rw-rw-rw-  2.0 fat      392 b- defN 19-Oct-17 08:29 PLATLIB/GPy/mappings/__init__.py
+-rw-rw-rw-  2.0 fat     4457 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/bayesian_gplvm.py
+-rw-rw-rw-  2.0 fat     5947 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/bayesian_gplvm_minibatch.py
+-rw-rw-rw-  2.0 fat     1466 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/bcgplvm.py
+-rw-rw-rw-  2.0 fat     1046 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/dpgplvm.py
+-rw-rw-rw-  2.0 fat     1357 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/gplvm.py
+-rw-rw-rw-  2.0 fat     2545 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/gp_classification.py
+-rw-rw-rw-  2.0 fat     1935 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/gp_coregionalized_regression.py
+-rw-rw-rw-  2.0 fat     1195 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/gp_grid_regression.py
+-rw-rw-rw-  2.0 fat     1151 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/gp_heteroscedastic_regression.py
+-rw-rw-rw-  2.0 fat     4361 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/gp_kronecker_gaussian_regression.py
+-rw-rw-rw-  2.0 fat    10598 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/gp_multiout_regression.py
+-rw-rw-rw-  2.0 fat    11908 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/gp_multiout_regression_md.py
+-rw-rw-rw-  2.0 fat     4059 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/gp_offset_regression.py
+-rw-rw-rw-  2.0 fat     2037 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/gp_regression.py
+-rw-rw-rw-  2.0 fat     1168 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/gp_var_gauss.py
+-rw-rw-rw-  2.0 fat    17219 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/gradient_checker.py
+-rw-rw-rw-  2.0 fat    21083 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/ibp_lfm.py
+-rw-rw-rw-  2.0 fat     5297 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/input_warped_gp.py
+-rw-rw-rw-  2.0 fat    15289 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/mrd.py
+-rw-rw-rw-  2.0 fat     7500 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/multioutput_gp.py
+-rw-rw-rw-  2.0 fat     1352 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/one_vs_all_classification.py
+-rw-rw-rw-  2.0 fat     1399 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/one_vs_all_sparse_classification.py
+-rw-rw-rw-  2.0 fat     1890 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/sparse_gplvm.py
+-rw-rw-rw-  2.0 fat     6586 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/sparse_gp_classification.py
+-rw-rw-rw-  2.0 fat     3024 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/sparse_gp_coregionalized_regression.py
+-rw-rw-rw-  2.0 fat    15415 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/sparse_gp_minibatch.py
+-rw-rw-rw-  2.0 fat     2664 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/sparse_gp_regression.py
+-rw-rw-rw-  2.0 fat     4089 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/sparse_gp_regression_md.py
+-rw-rw-rw-  2.0 fat    15198 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/ss_gplvm.py
+-rw-rw-rw-  2.0 fat    12940 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/ss_mrd.py
+-rw-rw-rw-  2.0 fat    24813 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/state_space.py
+-rw-rw-rw-  2.0 fat  1923801 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/state_space_cython.c
+-rw-rw-rw-  2.0 fat   414720 b- defN 19-Oct-17 08:32 PLATLIB/GPy/models/state_space_cython.cp37-win_amd64.pyd
+-rw-rw-rw-  2.0 fat    41650 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/state_space_cython.pyx
+-rw-rw-rw-  2.0 fat   143832 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/state_space_main.py
+-rw-rw-rw-  2.0 fat    16885 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/state_space_model.py
+-rw-rw-rw-  2.0 fat      321 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/state_space_setup.py
+-rw-rw-rw-  2.0 fat    12410 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/tp_regression.py
+-rw-rw-rw-  2.0 fat     7238 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/warped_gp.py
+-rw-rw-rw-  2.0 fat     1621 b- defN 19-Oct-17 08:29 PLATLIB/GPy/models/__init__.py
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/plotting/gpy_plot/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/plotting/matplot_dep/
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/plotting/plotly_dep/
+-rw-rw-rw-  2.0 fat    13998 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/abstract_plotting_library.py
+-rw-rw-rw-  2.0 fat     5686 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/Tango.py
+-rw-rw-rw-  2.0 fat     7486 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/__init__.py
+-rw-rw-rw-  2.0 fat    13885 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/gpy_plot/data_plots.py
+-rw-rw-rw-  2.0 fat    23732 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/gpy_plot/gp_plots.py
+-rw-rw-rw-  2.0 fat     1233 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/gpy_plot/inference_plots.py
+-rw-rw-rw-  2.0 fat     6826 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/gpy_plot/kernel_plots.py
+-rw-rw-rw-  2.0 fat    18468 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/gpy_plot/latent_plots.py
+-rw-rw-rw-  2.0 fat    15084 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/gpy_plot/plot_util.py
+-rw-rw-rw-  2.0 fat      123 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/gpy_plot/__init__.py
+drwxrwxrwx  2.0 fat        0 b- stor 19-Oct-17 08:36 PLATLIB/GPy/plotting/matplot_dep/controllers/
+-rw-rw-rw-  2.0 fat     6586 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/base_plots.py
+-rw-rw-rw-  2.0 fat     3838 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/defaults.py
+-rw-rw-rw-  2.0 fat     2159 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/img_plots.py
+-rw-rw-rw-  2.0 fat     3517 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/mapping_plots.py
+-rw-rw-rw-  2.0 fat     5721 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/maps.py
+-rw-rw-rw-  2.0 fat    13963 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/plot_definitions.py
+-rw-rw-rw-  2.0 fat      909 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/priors_plots.py
+-rw-rw-rw-  2.0 fat      806 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/ssgplvm.py
+-rw-rw-rw-  2.0 fat     1323 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/svig_plots.py
+-rw-rw-rw-  2.0 fat     6172 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/util.py
+-rw-rw-rw-  2.0 fat     4094 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/variational_plots.py
+-rw-rw-rw-  2.0 fat    23220 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/visualize.py
+-rw-rw-rw-  2.0 fat      698 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/__init__.py
+-rw-rw-rw-  2.0 fat     5386 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/controllers/axis_event_controller.py
+-rw-rw-rw-  2.0 fat     3647 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/controllers/imshow_controller.py
+-rw-rw-rw-  2.0 fat       70 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/matplot_dep/controllers/__init__.py
+-rw-rw-rw-  2.0 fat     3975 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/plotly_dep/defaults.py
+-rw-rw-rw-  2.0 fat    16726 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/plotly_dep/plot_definitions.py
+-rw-rw-rw-  2.0 fat        0 b- defN 19-Oct-17 08:29 PLATLIB/GPy/plotting/plotly_dep/__init__.py
+-rw-rw-rw-  2.0 fat     3148 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/cython_tests.py
+-rw-rw-rw-  2.0 fat     6431 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/ep_likelihood_tests.py
+-rw-rw-rw-  2.0 fat     3721 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/examples_tests.py
+-rw-rw-rw-  2.0 fat     1138 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/fitc.py
+-rw-rw-rw-  2.0 fat    21124 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/gpy_kernels_state_space_tests.py
+-rw-rw-rw-  2.0 fat     3398 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/gp_tests.py
+-rw-rw-rw-  2.0 fat     1964 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/grid_tests.py
+-rw-rw-rw-  2.0 fat     8585 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/inference_tests.py
+-rw-rw-rw-  2.0 fat    34638 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/kernel_tests.py
+-rw-rw-rw-  2.0 fat    37268 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/likelihood_tests.py
+-rw-rw-rw-  2.0 fat     2166 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/linalg_test.py
+-rw-rw-rw-  2.0 fat     7002 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/link_function_tests.py
+-rw-rw-rw-  2.0 fat     2853 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/mapping_tests.py
+-rw-rw-rw-  2.0 fat     3340 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/meanfunc_tests.py
+-rw-rw-rw-  2.0 fat    13260 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/minibatch_tests.py
+-rw-rw-rw-  2.0 fat      862 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/misc_tests.py
+-rw-rw-rw-  2.0 fat    52590 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/model_tests.py
+-rw-rw-rw-  2.0 fat     2682 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/mpi_tests.py
+-rw-rw-rw-  2.0 fat     3437 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/pep_tests.py
+-rw-rw-rw-  2.0 fat     5315 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/pickle_tests.py
+-rw-rw-rw-  2.0 fat    21772 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/plotting_tests.py
+-rw-rw-rw-  2.0 fat     5630 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/prior_tests.py
+-rw-rw-rw-  2.0 fat     1316 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/quadrature_tests.py
+-rw-rw-rw-  2.0 fat     4069 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/rv_transformation_tests.py
+-rw-rw-rw-  2.0 fat    15358 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/serialization_tests.py
+-rw-rw-rw-  2.0 fat    44812 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/state_space_main_tests.py
+-rw-rw-rw-  2.0 fat     1851 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/svgp_tests.py
+-rw-rw-rw-  2.0 fat     5466 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/tp_tests.py
+-rw-rw-rw-  2.0 fat    10489 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/util_tests.py
+-rw-rw-rw-  2.0 fat     2610 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/variational_tests.py
+-rw-rw-rw-  2.0 fat      306 b- defN 19-Oct-17 08:29 PLATLIB/GPy/testing/__init__.py
+-rw-rw-rw-  2.0 fat     4522 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/block_matrices.py
+-rw-rw-rw-  2.0 fat     3367 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/choleskies.py
+-rw-rw-rw-  2.0 fat   996162 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/choleskies_cython.c
+-rw-rw-rw-  2.0 fat   165888 b- defN 19-Oct-17 08:32 PLATLIB/GPy/util/choleskies_cython.cp37-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     3727 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/choleskies_cython.pyx
+-rw-rw-rw-  2.0 fat     1489 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/classification.py
+-rw-rw-rw-  2.0 fat     6520 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/cluster_with_offset.py
+-rw-rw-rw-  2.0 fat     1241 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/config.py
+-rw-rw-rw-  2.0 fat    65186 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/datasets.py
+-rw-rw-rw-  2.0 fat    34017 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/data_resources.json
+-rw-rw-rw-  2.0 fat     1127 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/debug.py
+-rw-rw-rw-  2.0 fat      566 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/decorators.py
+-rw-rw-rw-  2.0 fat     3853 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/diag.py
+-rw-rw-rw-  2.0 fat     2429 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/football_teams.json
+-rw-rw-rw-  2.0 fat     1329 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/functions.py
+-rw-rw-rw-  2.0 fat     1152 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/gpu_init.py
+-rw-rw-rw-  2.0 fat      874 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/initialization.py
+-rw-rw-rw-  2.0 fat     8588 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/input_warping_functions.py
+-rw-rw-rw-  2.0 fat    11712 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/linalg.py
+-rw-rw-rw-  2.0 fat   331809 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/linalg_cython.c
+-rw-rw-rw-  2.0 fat    44032 b- defN 19-Oct-17 08:32 PLATLIB/GPy/util/linalg_cython.cp37-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     1038 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/linalg_cython.pyx
+-rw-rw-rw-  2.0 fat     3038 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/linalg_gpu.py
+-rw-rw-rw-  2.0 fat     3554 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/ln_diff_erfs.py
+-rw-rw-rw-  2.0 fat     5919 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/misc.py
+-rw-rw-rw-  2.0 fat    27949 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/mocap.py
+-rw-rw-rw-  2.0 fat     4559 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/multioutput.py
+-rw-rw-rw-  2.0 fat    12223 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/netpbmfile.py
+-rw-rw-rw-  2.0 fat     3915 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/normalizer.py
+-rw-rw-rw-  2.0 fat     1752 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/parallel.py
+-rw-rw-rw-  2.0 fat     4747 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/pca.py
+-rw-rw-rw-  2.0 fat     4545 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/quad_integrate.py
+-rw-rw-rw-  2.0 fat      340 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/squashers.py
+-rw-rw-rw-  2.0 fat     1960 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/subarray_and_sorting.py
+-rw-rw-rw-  2.0 fat     5982 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/univariate_Gaussian.py
+-rw-rw-rw-  2.0 fat     7143 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/warping_functions.py
+-rw-rw-rw-  2.0 fat      513 b- defN 19-Oct-17 08:29 PLATLIB/GPy/util/__init__.py
+-rw-rw-rw-  2.0 fat        1 b- defN 19-Oct-17 08:36 PLATLIB/GPy-1.9.9-py3.7.egg-info/dependency_links.txt
+-rw-rw-rw-  2.0 fat     1286 b- defN 19-Oct-17 08:36 PLATLIB/GPy-1.9.9-py3.7.egg-info/PKG-INFO
+-rw-rw-rw-  2.0 fat      217 b- defN 19-Oct-17 08:36 PLATLIB/GPy-1.9.9-py3.7.egg-info/requires.txt
+-rw-rw-rw-  2.0 fat     9134 b- defN 19-Oct-17 08:36 PLATLIB/GPy-1.9.9-py3.7.egg-info/SOURCES.txt
+-rw-rw-rw-  2.0 fat        4 b- defN 19-Oct-17 08:36 PLATLIB/GPy-1.9.9-py3.7.egg-info/top_level.txt
+302 files, 7707650 bytes uncompressed, 1421156 bytes compressed:  81.6%
```

## PLATLIB/GPy/__version__.py

```diff
@@ -1 +1 @@
-__version__ = "1.9.8"
+__version__ = "1.9.9"
```

## PLATLIB/GPy/examples/regression.py

```diff
@@ -577,7 +577,60 @@
     warp_m.predict_in_warped_space = False
     warp_m.plot(title="Warped GP - Latent space")
     warp_m.predict_in_warped_space = True
     warp_m.plot(title="Warped GP - Warped space")
     m.plot(title="Standard GP")
     warp_m.plot_warping()
     pb.show()
+    return warp_m
+
+
+
+def multioutput_gp_with_derivative_observations():
+    def plot_gp_vs_real(m, x, yreal, size_inputs, title, fixed_input=1, xlim=[0,11], ylim=[-1.5,3]):
+        fig, ax = pb.subplots()
+        ax.set_title(title)
+        pb.plot(x, yreal, "r", label='Real function')
+        rows = slice(0, size_inputs[0]) if fixed_input == 0 else slice(size_inputs[0], size_inputs[0]+size_inputs[1])
+        m.plot(fixed_inputs=[(1, fixed_input)], which_data_rows=rows, xlim=xlim, ylim=ylim, ax=ax)
+    f = lambda x: np.sin(x)+0.1*(x-2.)**2-0.005*x**3
+    fd = lambda x: np.cos(x)+0.2*(x-2.)-0.015*x**2
+    N=10 # Number of observations
+    M=10 # Number of derivative observations
+    Npred=100 # Number of prediction points
+    sigma = 0.05 # Noise of observations
+    sigma_der = 0.05 # Noise of derivative observations
+    x = np.array([np.linspace(1,10,N)]).T
+    y = f(x) + np.array(sigma*np.random.normal(0,1,(N,1)))
+
+    xd = np.array([np.linspace(2,8,M)]).T
+    yd = fd(xd) + np.array(sigma_der*np.random.normal(0,1,(M,1)))
+
+    xpred = np.array([np.linspace(0,11,Npred)]).T
+    ypred_true = f(xpred)
+    ydpred_true = fd(xpred)
+
+    # squared exponential kernel:
+    se = GPy.kern.RBF(input_dim = 1, lengthscale=1.5, variance=0.2)
+    # We need to generate separate kernel for the derivative observations and give the created kernel as an input:
+    se_der = GPy.kern.DiffKern(se, 0)
+
+    #Then
+    gauss = GPy.likelihoods.Gaussian(variance=sigma**2)
+    gauss_der = GPy.likelihoods.Gaussian(variance=sigma_der**2)
+
+    # Then create the model, we give everything in lists, the order of the inputs indicates the order of the outputs
+    # Now we have the regular observations first and derivative observations second, meaning that the kernels and
+    # the likelihoods must follow the same order. Crosscovariances are automatically taken car of
+    m = GPy.models.MultioutputGP(X_list=[x, xd], Y_list=[y, yd], kernel_list=[se, se_der], likelihood_list = [gauss, gauss])
+
+    # Optimize the model
+    m.optimize(messages=0, ipython_notebook=False)
+
+    #Plot the model, the syntax is same as for multioutput models:
+    plot_gp_vs_real(m, xpred, ydpred_true, [x.shape[0], xd.shape[0]], title='Latent function derivatives', fixed_input=1, xlim=[0,11], ylim=[-1.5,3])
+    plot_gp_vs_real(m, xpred, ypred_true, [x.shape[0], xd.shape[0]], title='Latent function', fixed_input=0, xlim=[0,11], ylim=[-1.5,3])
+
+    #making predictions for the values:
+    mu, var = m.predict_noiseless(Xnew=[xpred, np.empty((0,1))])
+
+    return m
```

## PLATLIB/GPy/kern/__init__.py

```diff
@@ -39,8 +39,10 @@
 from .src.sde_matern import sde_Matern32
 from .src.sde_matern import sde_Matern52
 from .src.sde_linear import sde_Linear
 from .src.sde_standard_periodic import sde_StdPeriodic
 from .src.sde_static import sde_White, sde_Bias
 from .src.sde_stationary import sde_RBF,sde_Exponential,sde_RatQuad
 from .src.sde_brownian import sde_Brownian
-from .src.multioutput_kern import MultioutputKern
+from .src.multioutput_kern import MultioutputKern
+from .src.multioutput_derivative_kern import MultioutputDerivativeKern
+from .src.diff_kern import DiffKern
```

## PLATLIB/GPy/kern/src/independent_outputs.py

```diff
@@ -1,42 +1,16 @@
 # Copyright (c) 2012, James Hesnsman
 # Licensed under the BSD 3-clause license (see LICENSE.txt)
 
 
 from .kern import CombinationKernel
 import numpy as np
 import itertools
+from ...util.multioutput import index_to_slices
 
-def index_to_slices(index):
-    """
-    take a numpy array of integers (index) and return a  nested list of slices such that the slices describe the start, stop points for each integer in the index.
-
-    e.g.
-    >>> index = np.asarray([0,0,0,1,1,1,2,2,2])
-    returns
-    >>> [[slice(0,3,None)],[slice(3,6,None)],[slice(6,9,None)]]
-
-    or, a more complicated example
-    >>> index = np.asarray([0,0,1,1,0,2,2,2,1,1])
-    returns
-    >>> [[slice(0,2,None),slice(4,5,None)],[slice(2,4,None),slice(8,10,None)],[slice(5,8,None)]]
-    """
-    if len(index)==0:
-        return[]
-
-    #contruct the return structure
-    ind = np.asarray(index,dtype=np.int)
-    ret = [[] for i in range(ind.max()+1)]
-
-    #find the switchpoints
-    ind_ = np.hstack((ind,ind[0]+ind[-1]+1))
-    switchpoints = np.nonzero(ind_ - np.roll(ind_,+1))[0]
-
-    [ret[ind_i].append(slice(*indexes_i)) for ind_i,indexes_i in zip(ind[switchpoints[:-1]],zip(switchpoints,switchpoints[1:]))]
-    return ret
 
 class IndependentOutputs(CombinationKernel):
     """
     A kernel which can represent several independent functions.  this kernel
     'switches off' parts of the matrix where the output indexes are different.
 
     The index of the functions is given by the last column in the input X the
```

## PLATLIB/GPy/kern/src/kern.py

```diff
@@ -112,14 +112,20 @@
     @Cache_this(limit=3)
     def _slice_X(self, X):
         try:
             return X[:, self._all_dims_active].astype('float')
         except:
             return X[:, self._all_dims_active]
 
+    def _project_dim(self, dim):
+        try:
+            return np.where(self._all_dims_active == dim)[0][0]
+        except:
+            return None
+
     def K(self, X, X2):
         """
         Compute the kernel function.
 
         .. math::
             K_{ij} = k(X_i, X_j)
```

## PLATLIB/GPy/kern/src/kernel_slice_operations.py

```diff
@@ -15,24 +15,34 @@
     if name in dct:
         dct['_clean_{}'.format(name)] = dct[name]
         dct[name] = func(dct[name])
 
 class KernCallsViaSlicerMeta(ParametersChangedMeta):
     def __new__(cls, name, bases, dct):
         put_clean(dct, 'K', _slice_K)
+        put_clean(dct, 'dK_dX', _slice_dK_dX)
+        put_clean(dct, 'dK_dX2', _slice_dK_dX)
+        put_clean(dct, 'dK2_dXdX2', _slice_dK2_dXdX2)
         put_clean(dct, 'Kdiag', _slice_Kdiag)
         put_clean(dct, 'phi', _slice_Kdiag)
         put_clean(dct, 'update_gradients_full', _slice_update_gradients_full)
         put_clean(dct, 'update_gradients_diag', _slice_update_gradients_diag)
+        put_clean(dct, 'update_gradients_dK_dX', _slice_update_gradients_full)
+        put_clean(dct, 'update_gradients_dK_dX2', _slice_update_gradients_full)
         put_clean(dct, 'gradients_X', _slice_gradients_X)
+        put_clean(dct, 'gradients_X2', _slice_gradients_X)
         put_clean(dct, 'gradients_X_X2', _slice_gradients_X)
         put_clean(dct, 'gradients_XX', _slice_gradients_XX)
         put_clean(dct, 'gradients_XX_diag', _slice_gradients_XX_diag)
         put_clean(dct, 'gradients_X_diag', _slice_gradients_X_diag)
 
+        put_clean(dct, 'dgradients_dX',_slice_partial_gradients_list_X)
+        put_clean(dct, 'dgradients_dX2',_slice_partial_gradients_list_X)
+        put_clean(dct, 'dgradients2_dXdX2',_slice_partial_gradients_list_XX)
+
         put_clean(dct, 'psi0', _slice_psi)
         put_clean(dct, 'psi1', _slice_psi)
         put_clean(dct, 'psi2', _slice_psi)
         put_clean(dct, 'psi2n', _slice_psi)
         put_clean(dct, 'update_gradients_expectations', _slice_update_gradients_expectations)
         put_clean(dct, 'gradients_Z_expectations', _slice_gradients_Z_expectations)
         put_clean(dct, 'gradients_qX_expectations', _slice_gradients_qX_expectations)
@@ -75,14 +85,28 @@
                 else:
                     ret[:, :, self.k._all_dims_active] = return_val
             elif len(self.shape) == 4: # second order derivative
                 ret.T[np.ix_(self.k._all_dims_active, self.k._all_dims_active)] = return_val.T
             return ret
         return return_val
 
+    def handle_return_list(self, return_val):
+        if self.ret:
+            ret = [np.zeros(self.shape) for _ in range(len(return_val))]
+            if len(self.shape) == 3:
+                for i in range(len(return_val)):
+                    ret[i][self.k._all_dims_active, :, :] = return_val[i]
+                #[ret[i].__setitem__((:, :, self.k._all_dims_active), return_val[i])  for i in range(len(return_val))]             
+            elif len(self.shape) == 4:
+                for i in range(len(return_val)):
+                    ret[i][np.ix_(self.k._all_dims_active, self.k._all_dims_active)] = return_val[i]
+                #[ret[i].__setitem__((:, :, self.k._all_dims_active, self.k._all_dims_active), return_val[i])  for i in range(len(return_val))]             
+            return ret
+        return return_val
+
 def _slice_K(f):
     @wraps(f)
     def wrap(self, X, X2 = None, *a, **kw):
         with _Slice_wrap(self, X, X2) as s:
             ret = f(self, s.X, s.X2, *a, **kw)
         return ret
     return wrap
@@ -93,36 +117,129 @@
         with _Slice_wrap(self, X, None) as s:
             ret = f(self, s.X, *a, **kw)
         return ret
     return wrap
 
 def _slice_update_gradients_full(f):
     @wraps(f)
-    def wrap(self, dL_dK, X, X2=None):
+    def wrap(self, dL_dK, X, X2=None, *a, **kw):
         with _Slice_wrap(self, X, X2) as s:
-            ret = f(self, dL_dK, s.X, s.X2)
+            ret = f(self, dL_dK, s.X, s.X2, *a, **kw)
         return ret
     return wrap
 
 def _slice_update_gradients_diag(f):
     @wraps(f)
-    def wrap(self, dL_dKdiag, X):
+    def wrap(self, dL_dKdiag, X, *a, **kw):
         with _Slice_wrap(self, X, None) as s:
             ret = f(self, dL_dKdiag, s.X)
         return ret
     return wrap
 
 def _slice_gradients_X(f):
     @wraps(f)
     def wrap(self, dL_dK, X, X2=None):
         with _Slice_wrap(self, X, X2) as s:
             ret = s.handle_return_array(f(self, dL_dK, s.X, s.X2))
         return ret
     return wrap
 
+def _slice_dK_dX(f):
+    @wraps(f)
+    def wrap(self, X, X2, dim, *a, **kw):
+        with _Slice_wrap(self, X, X2) as s:
+            d = s.k._project_dim(dim)
+            if d is None:
+                ret = np.zeros((X.shape[0], X2.shape[0]))
+            else:
+                ret = f(self, s.X, s.X2, d, *a, **kw)
+        return ret
+    return wrap
+
+def _slice_dK2_dXdX2(f):
+    @wraps(f)
+    def wrap(self, X, X2, dimX, dimX2, *a, **kw):
+        with _Slice_wrap(self, X, X2) as s:
+            d = s.k._project_dim(dimX)
+            d2 = s.k._project_dim(dimX2)
+            if (d is None) or (d2 is None):
+                ret = np.zeros((X.shape[0], X2.shape[0]))
+            else:
+                ret = f(self, s.X, s.X2, d, d2, *a, **kw)
+        return ret
+    return wrap
+
+def _slice_partial_gradients_X(f):
+    @wraps(f)
+    def wrap(self, X, X2, dim):
+        if X2 is None:
+            N, M = X.shape[0], X.shape[0]
+        else:
+            N, M = X.shape[0], X2.shape[0]
+        Q1 = X.shape[1]
+        with _Slice_wrap(self, X, X2, ret_shape=(N, M, Q1)) as s:
+            ret = s.handle_return_array(f(self, s.X, s.X2, dim))
+        return ret
+    return wrap
+
+def _slice_partial_gradients_list_X(f):
+    @wraps(f)
+    def wrap(self, X, X2, dim):
+        if X2 is None:
+            N, M = X.shape[0], X.shape[0]
+        else:
+            N, M = X.shape[0], X2.shape[0]
+        with _Slice_wrap(self, X, X2, ret_shape=(N, M)) as s:
+            d = s.k._project_dim(dim)
+            if d is None:
+                ret = [np.zeros((N, M)) for i in range(s.k.size)]
+            else:            
+                ret = f(self, s.X, s.X2, d)
+        return ret
+    return wrap
+
+def _slice_partial_gradients_XX(f):
+    @wraps(f)
+    def wrap(self, X, X2, dim, dimX2):
+        if X2 is None:
+            N, M = X.shape[0], X.shape[0]
+            Q1 = X.shape[1]
+        else:
+            N, M = X.shape[0], X2.shape[0]
+            Q1, Q2 = X.shape[1], X2.shape[1]
+        with _Slice_wrap(self, X, X2, ret_shape=(N, M, Q1, Q2)) as s:
+            ret = s.handle_return_array(f(self, s.X, s.X2, dim, dimX2))
+        return ret
+    return wrap
+
+def _slice_partial_gradients_list_XX(f):
+    @wraps(f)
+    def wrap(self, X, X2, dimX, dimX2):
+        if X2 is None:
+            N, M = X.shape[0], X.shape[0]
+        else:
+            N, M = X.shape[0], X2.shape[0]
+        with _Slice_wrap(self, X, X2, ret_shape=(N, M)) as s:
+            d = s.k._project_dim(dimX)
+            d2 = s.k._project_dim(dimX2)
+            if (d is None) or (d2 is None):
+                ret = [np.zeros((N, M)) for i in range(s.k.size)]
+            else:
+                ret = f(self, s.X, s.X2, d, d2)
+        return ret
+    return wrap
+
+def _slice_gradient_derivatives_X(f):
+    @wraps(f)
+    def wrap(self, dL_dK, X, X2=None):
+        with _Slice_wrap(self, X, X2) as s:
+            ret = s.handle_return_array(f(self, dL_dK, s.X, s.X2))
+        return ret
+    return wrap
+
 def _slice_gradients_X_diag(f):
     @wraps(f)
     def wrap(self, dL_dKdiag, X):
         with _Slice_wrap(self, X, None) as s:
             ret = s.handle_return_array(f(self, dL_dKdiag, s.X))
         return ret
     return wrap
```

## PLATLIB/GPy/kern/src/multioutput_kern.py

```diff
@@ -1,11 +1,14 @@
+# Copyright (c) 2018, GPy authors (see AUTHORS.txt).
+# Licensed under the BSD 3-clause license (see LICENSE.txt)
+
 from .kern import Kern, CombinationKernel
 import numpy as np
 from functools import reduce, partial
-from .independent_outputs import index_to_slices
+from ...util.multioutput import index_to_slices
 from paramz.caching import Cache_this
 
 class ZeroKern(Kern):
     def __init__(self):
         super(ZeroKern, self).__init__(1, None, name='ZeroKern',useGPU=False)
 
     def K(self, X ,X2=None):
@@ -14,14 +17,21 @@
         return np.zeros((X.shape[0],X2.shape[0]))
     
     def update_gradients_full(self,dL_dK, X, X2=None):
         return np.zeros(dL_dK.shape)
     
     def gradients_X(self,dL_dK, X, X2=None):
         return np.zeros((X.shape[0],X.shape[1]))
+    @property
+    def gradient(self):
+        return np.empty((1,0))
+
+    @gradient.setter
+    def gradient(self, gradient):
+        pass
         
 class MultioutputKern(CombinationKernel):
     """
     Multioutput kernel is a meta class for combining different kernels for multioutput GPs. 
 
     As an example let us have inputs x1 for output 1 with covariance k1 and x2 for output 2 with covariance k2.
     In addition, we need to define the cross covariances k12(x1,x2) and k21(x2,x1). Then the kernel becomes:
@@ -58,49 +68,48 @@
         #build covariance structure
         covariance = [[None for i in range(nl)] for j in range(nl)]
         linked = []
         for i in range(0,nl):
             unique=True
             for j in range(0,nl):
                 if i==j or (kernels[i] is kernels[j]):
-                    covariance[i][j] = {'kern': kernels[i], 'K': kernels[i].K, 'update_gradients_full': kernels[i].update_gradients_full, 'gradients_X': kernels[i].gradients_X}
+                    covariance[i][j] = kernels[i]
                     if i>j:
                         unique=False
                 elif cross_covariances.get((i,j)) is not None: #cross covariance is given
                     covariance[i][j] = cross_covariances.get((i,j))
                 else: # zero covariance structure
-                    kern = ZeroKern()
-                    covariance[i][j] = {'kern': kern, 'K': kern.K, 'update_gradients_full': kern.update_gradients_full, 'gradients_X': kern.gradients_X}       
+                    covariance[i][j] = ZeroKern()
             if unique is True:
                 linked.append(i)
         self.covariance = covariance
         self.link_parameters(*[kernels[i] for i in linked])
         
     @Cache_this(limit=3, ignore_args=())
     def K(self, X ,X2=None):
         if X2 is None:
             X2 = X
         slices = index_to_slices(X[:,self.index_dim])
         slices2 = index_to_slices(X2[:,self.index_dim])
         target =  np.zeros((X.shape[0], X2.shape[0]))
-        [[[[ target.__setitem__((slices[i][k],slices2[j][l]), self.covariance[i][j]['K'](X[slices[i][k],:],X2[slices2[j][l],:])) for k in range( len(slices[i]))] for l in range(len(slices2[j])) ] for i in range(len(slices))] for j in range(len(slices2))]  
+        [[[[ target.__setitem__((slices[i][k],slices2[j][l]), self.covariance[i][j].K(X[slices[i][k],:],X2[slices2[j][l],:])) for k in range( len(slices[i]))] for l in range(len(slices2[j])) ] for i in range(len(slices))] for j in range(len(slices2))]  
         return target
 
     @Cache_this(limit=3, ignore_args=())
     def Kdiag(self,X):
         slices = index_to_slices(X[:,self.index_dim])
         kerns = itertools.repeat(self.kern) if self.single_kern else self.kern
         target = np.zeros(X.shape[0])
         [[np.copyto(target[s], kern.Kdiag(X[s])) for s in slices_i] for kern, slices_i in zip(kerns, slices)]
         return target
     
-    def _update_gradients_full_wrapper(self, cov_struct, dL_dK, X, X2):
-        gradient = cov_struct['kern'].gradient.copy()
-        cov_struct['update_gradients_full'](dL_dK, X, X2)
-        cov_struct['kern'].gradient += gradient
+    def _update_gradients_full_wrapper(self, kern, dL_dK, X, X2):
+        gradient = kern.gradient.copy()
+        kern.update_gradients_full(dL_dK, X, X2)
+        kern.gradient += gradient
     
     def _update_gradients_diag_wrapper(self, kern, dL_dKdiag, X):
         gradient = kern.gradient.copy()
         kern.update_gradients_diag(dL_dKdiag, X)
         kern.gradient += gradient
         
     def reset_gradients(self):
@@ -114,18 +123,18 @@
             [[[[ self._update_gradients_full_wrapper(self.covariance[i][j], dL_dK[slices[i][k],slices2[j][l]], X[slices[i][k],:], X2[slices2[j][l],:]) for k in range(len(slices[i]))] for l in range(len(slices2[j]))] for i in range(len(slices))] for j in range(len(slices2))]
         else:
             [[[[ self._update_gradients_full_wrapper(self.covariance[i][j], dL_dK[slices[i][k],slices[j][l]], X[slices[i][k],:], X[slices[j][l],:]) for k in range(len(slices[i]))] for l in range(len(slices[j]))] for i in range(len(slices))] for j in range(len(slices))]
             
     def update_gradients_diag(self, dL_dKdiag, X):
         self.reset_gradients()
         slices = index_to_slices(X[:,self.index_dim])
-        [[ self._update_gradients_diag_wrapper(self.covariance[i][i]['kern'], dL_dKdiag[slices[i][k]], X[slices[i][k],:]) for k in range(len(slices[i]))] for i in range(len(slices))]
+        [[ self._update_gradients_diag_wrapper(self.covariance[i][i], dL_dKdiag[slices[i][k]], X[slices[i][k],:]) for k in range(len(slices[i]))] for i in range(len(slices))]
     
     def gradients_X(self,dL_dK, X, X2=None):
         slices = index_to_slices(X[:,self.index_dim])
         target = np.zeros((X.shape[0], X.shape[1]) )
         if X2 is not None:
             slices2 = index_to_slices(X2[:,self.index_dim])
-            [[[[ target.__setitem__((slices[i][k]), target[slices[i][k],:] + self.covariance[i][j]['gradients_X'](dL_dK[slices[i][k],slices2[j][l]], X[slices[i][k],:], X2[slices2[j][l],:]) ) for k in range(len(slices[i]))] for l in range(len(slices2[j]))] for i in range(len(slices))] for j in range(len(slices2))]
+            [[[[ target.__setitem__((slices[i][k]), target[slices[i][k],:] + self.covariance[i][j].gradients_X(dL_dK[slices[i][k],slices2[j][l]], X[slices[i][k],:], X2[slices2[j][l],:]) ) for k in range(len(slices[i]))] for l in range(len(slices2[j]))] for i in range(len(slices))] for j in range(len(slices2))]
         else:
-            [[[[ target.__setitem__((slices[i][k]), target[slices[i][k],:] + self.covariance[i][j]['gradients_X'](dL_dK[slices[i][k],slices[j][l]], X[slices[i][k],:], (None if (i==j and k==l) else X[slices[j][l],:] )) ) for k in range(len(slices[i]))] for l in range(len(slices[j]))] for i in range(len(slices))] for j in range(len(slices))]
+            [[[[ target.__setitem__((slices[i][k]), target[slices[i][k],:] + self.covariance[i][j].gradients_X(dL_dK[slices[i][k],slices[j][l]], X[slices[i][k],:], (None if (i==j and k==l) else X[slices[j][l],:] )) ) for k in range(len(slices[i]))] for l in range(len(slices[j]))] for i in range(len(slices))] for j in range(len(slices))]
         return target
```

## PLATLIB/GPy/kern/src/ODE_st.py

```diff
@@ -1,14 +1,14 @@
 # Copyright (c) 2012, GPy authors (see AUTHORS.txt).
 # Licensed under the BSD 3-clause license (see LICENSE.txt)
 from .kern import Kern
 from ...core.parameterization import Param
 from paramz.transformations import Logexp
 import numpy as np
-from .independent_outputs import index_to_slices
+from ...util.multioutput import index_to_slices
 
 
 class ODE_st(Kern):
     """
     kernel resultiong from a first order ODE with OU driving GP
 
     :param input_dim: the number of input dimension, has to be equal to one
```

## PLATLIB/GPy/kern/src/ODE_t.py

```diff
@@ -1,12 +1,12 @@
 from .kern import Kern
 from ...core.parameterization import Param
 from paramz.transformations import Logexp
 import numpy as np
-from .independent_outputs import index_to_slices
+from ...util.multioutput import index_to_slices
 
 
 class ODE_t(Kern):
 
         def __init__(self, input_dim, a=1., c=1.,variance_Yt=3., lengthscale_Yt=1.5,ubias =1., active_dims=None, name='ode_st'):
                 assert input_dim ==2, "only defined for 2 input dims"
                 super(ODE_t, self).__init__(input_dim, active_dims, name)
```

## PLATLIB/GPy/kern/src/ODE_UY.py

```diff
@@ -1,12 +1,12 @@
 # Copyright (c) 2013, GPy authors (see AUTHORS.txt).
 # Licensed under the BSD 3-clause license (see LICENSE.txt)
 
 from .kern import Kern
-from .independent_outputs import index_to_slices
+from ...util.multioutput import index_to_slices
 from ...core.parameterization import Param
 from paramz.transformations import Logexp
 import numpy as np
 
 class ODE_UY(Kern):
     def __init__(self, input_dim, variance_U=3., variance_Y=1., lengthscale_U=1., lengthscale_Y=1., active_dims=None, name='ode_uy'):
         assert input_dim ==2, "only defined for 2 input dims"
```

## PLATLIB/GPy/kern/src/ODE_UYC.py

```diff
@@ -1,15 +1,15 @@
 # Copyright (c) 2013, GPy authors (see AUTHORS.txt).
 # Licensed under the BSD 3-clause license (see LICENSE.txt)
 
 from .kern import Kern
 from ...core.parameterization import Param
 from paramz.transformations import Logexp
 import numpy as np
-from .independent_outputs import index_to_slices
+from ...util.multioutput import index_to_slices
 
 class ODE_UYC(Kern):
     def __init__(self, input_dim, variance_U=3., variance_Y=1., lengthscale_U=1., lengthscale_Y=1., ubias =1. ,active_dims=None, name='ode_uyc'):
         assert input_dim ==2, "only defined for 2 input dims"
         super(ODE_UYC, self).__init__(input_dim, active_dims, name)
 
         self.variance_Y = Param('variance_Y', variance_Y, Logexp())
```

## PLATLIB/GPy/kern/src/rbf.py

```diff
@@ -2,14 +2,15 @@
 # Licensed under the BSD 3-clause license (see LICENSE.txt)
 
 
 import numpy as np
 from .stationary import Stationary
 from .psi_comp import PSICOMP_RBF, PSICOMP_RBF_GPU
 from ...core import Param
+from paramz.caching import Cache_this
 from paramz.transformations import Logexp
 from .grid_kerns import GridRBF
 
 class RBF(Stationary):
     """
     Radial Basis Function kernel, aka squared-exponential, exponentiated quadratic or Gaussian kernel:
 
@@ -46,22 +47,111 @@
         if input_dict["inv_l"] == True:
             input_dict["lengthscale"] = np.sqrt(1 / float(self.inv_l))
         return input_dict
 
     def K_of_r(self, r):
         return self.variance * np.exp(-0.5 * r**2)
 
+    @Cache_this(limit=3, ignore_args=())
+    def dK_dX(self, X, X2, dimX):
+        r = self._scaled_dist(X, X2)
+        K = self.K_of_r(r)
+        dist = X[:,None,dimX]-X2[None,:,dimX]
+        lengthscale2inv = (np.ones((X.shape[1]))/(self.lengthscale**2))[dimX]
+        return -1.*K*dist*lengthscale2inv
+    @Cache_this(limit=3, ignore_args=())
+    def dK_dX2(self, X, X2, dimX2):
+        return -self.dK_dX(X,X2, dimX2)
+    
+    @Cache_this(limit=3, ignore_args=())
+    def dK2_dXdX2(self, X, X2, dimX, dimX2):
+        r = self._scaled_dist(X, X2)
+        K = self.K_of_r(r)
+        if X2 is None:
+            X2=X
+        dist = X[:,None,:]-X2[None,:,:]
+        lengthscale2inv = np.ones((X.shape[1]))/(self.lengthscale**2)
+        return -1.*K*dist[:,:,dimX]*dist[:,:,dimX2]*lengthscale2inv[dimX]*lengthscale2inv[dimX2] + (dimX==dimX2)*K*lengthscale2inv[dimX]
+
     def dK_dr(self, r):
         return -r*self.K_of_r(r)
 
     def dK2_drdr(self, r):
         return (r**2-1)*self.K_of_r(r)
 
     def dK2_drdr_diag(self):
         return -self.variance # as the diagonal of r is always filled with zeros
+    
+    @Cache_this(limit=3, ignore_args=())
+    def dK_dvariance(self,X,X2):
+        return self.K(X,X2)/self.variance
+    
+    @Cache_this(limit=3, ignore_args=())
+    def dK2_dvariancedX(self, X, X2, dim):
+        return self.dK_dX(X,X2, dim)/self.variance
+    
+    @Cache_this(limit=3, ignore_args=())
+    def dK2_dvariancedX2(self, X, X2, dim):
+        return self.dK_dX2(X,X2, dim)/self.variance
+    
+    @Cache_this(limit=3, ignore_args=())
+    def dK3_dvariancedXdX2(self, X, X2, dim, dimX2):
+        return self.dK2_dXdX2(X, X2, dim, dimX2)/self.variance
+
+    @Cache_this(limit=3, ignore_args=())
+    def dK2_dlengthscaledX(self, X, X2, dimX):
+        r = self._scaled_dist(X, X2)
+        K = self.K_of_r(r)
+        if X2 is None:
+            X2=X
+        dist = X[:,None,:]-X2[None,:,:]
+        lengthscaleinv = np.ones((X.shape[1]))/(self.lengthscale)
+        if self.ARD:
+            g = []
+            for diml in range(X.shape[1]):
+                g += [-1.*K*dist[:,:,dimX]*(dist[:,:,diml]**2)*(lengthscaleinv[dimX]**2)*(lengthscaleinv[diml]**3) + 2.*dist[:,:,dimX]*(lengthscaleinv[diml]**3)*K*(dimX == diml)]
+        else:
+            g = -1.*K*dist[:,:,dimX]*np.sum(dist**2, axis=2)*(lengthscaleinv[dimX]**5) + 2.*dist[:,:,dimX]*(lengthscaleinv[dimX]**3)*K
+        return g
+    
+    @Cache_this(limit=3, ignore_args=())
+    def dK2_dlengthscaledX2(self, X, X2, dimX2):
+        tmp = self.dK2_dlengthscaledX(X, X2, dimX2)
+        if self.ARD:
+            return [-1.*g for g in tmp]
+        else:
+            return -1*tmp
+    
+    @Cache_this(limit=3, ignore_args=())
+    def dK3_dlengthscaledXdX2(self, X, X2, dimX, dimX2):
+        r = self._scaled_dist(X, X2)
+        K = self.K_of_r(r)
+        if X2 is None:
+            X2=X
+        dist = X[:,None,:]-X2[None,:,:]
+        lengthscaleinv = np.ones((X.shape[1]))/(self.lengthscale)
+        lengthscale2inv = lengthscaleinv**2
+        if self.ARD:
+            g = []
+            for diml in range(X.shape[1]):
+                tmp = -1.*K*dist[:,:,dimX]*dist[:,:,dimX2]*(dist[:,:,diml]**2)*lengthscale2inv[dimX]*lengthscale2inv[dimX2]*(lengthscaleinv[diml]**3)
+                if dimX == dimX2:
+                    tmp += K*lengthscale2inv[dimX]*(lengthscaleinv[diml]**3)*(dist[:,:,diml]**2)
+                if diml == dimX:
+                    tmp += 2.*K*dist[:,:,dimX]*dist[:,:,dimX2]*lengthscale2inv[dimX2]*(lengthscaleinv[dimX]**3)
+                if diml == dimX2:
+                    tmp += 2.*K*dist[:,:,dimX]*dist[:,:,dimX2]*lengthscale2inv[dimX]*(lengthscaleinv[dimX2]**3)
+                    if dimX == dimX2:
+                        tmp += -2.*K*(lengthscaleinv[dimX]**3)
+                g += [tmp]
+        else:
+            g = -1.*K*dist[:,:,dimX]*dist[:,:,dimX2]*np.sum(dist**2, axis=2)*(lengthscaleinv[dimX]**7) +4*K*dist[:,:,dimX]*dist[:,:,dimX2]*(lengthscaleinv[dimX]**5)
+            if dimX == dimX2:
+                g += -2.*K*(lengthscaleinv[dimX]**3) + K*(lengthscaleinv[dimX]**5)*np.sum(dist**2, axis=2)
+        return g
 
     def __getstate__(self):
         dc = super(RBF, self).__getstate__()
         if self.useGPU:
             dc['psicomp'] = PSICOMP_RBF()
             dc['useGPU'] = False
         return dc
```

## PLATLIB/GPy/kern/src/splitKern.py

```diff
@@ -1,14 +1,14 @@
 """
 A new kernel
 """
 
 import numpy as np
 from .kern import Kern, CombinationKernel
-from .independent_outputs import index_to_slices
+from ...util.multioutput import index_to_slices
 import itertools
 
 class DEtime(Kern):
 
     def __init__(self, kernel, idx_p, Xp, index_dim=-1, name='DiffGenomeKern'):
         self.idx_p = idx_p
         self.index_dim=index_dim
```

## PLATLIB/GPy/kern/src/stationary.py

```diff
@@ -208,15 +208,14 @@
                 self.lengthscale.gradient = self._lengthscale_grads_cython(tmp, X, X2)
             else:
                 self.lengthscale.gradient = self._lengthscale_grads_pure(tmp, X, X2)
         else:
             r = self._scaled_dist(X, X2)
             self.lengthscale.gradient = -np.sum(dL_dr*r)/self.lengthscale
 
-
     def update_gradients_direct(self, dL_dVar, dL_dLen):
         """
         Specially intended for the Grid regression case.
         Given the computed log likelihood derivates, update the corresponding
         kernel and likelihood gradients.
         Useful for when gradients have been computed a priori.
         """
@@ -303,14 +302,29 @@
         """
         dL_dK_diag = dL_dK_diag.copy().reshape(-1, 1, 1)
         assert (dL_dK_diag.size == X.shape[0]) or (dL_dK_diag.size == 1), "dL_dK_diag has to be given as row [N] or column vector [Nx1]"
 
         l4 =  np.ones(X.shape[1])*self.lengthscale**2
         return dL_dK_diag * (np.eye(X.shape[1]) * -self.dK2_drdr_diag()/(l4))[None, :,:]# np.zeros(X.shape+(X.shape[1],))
         #return np.ones(X.shape) * d2L_dK * self.variance/self.lengthscale**2 # np.zeros(X.shape)
+    
+    def dgradients_dX(self, X, X2, dimX):
+        g1 = self.dK2_dvariancedX(X, X2, dimX)
+        g2 = self.dK2_dlengthscaledX(X, X2, dimX)
+        return [g1, g2]
+
+    def dgradients_dX2(self, X, X2, dimX2):
+        g1 = self.dK2_dvariancedX2(X, X2, dimX2)
+        g2 = self.dK2_dlengthscaledX2(X, X2, dimX2)
+        return [g1, g2]
+
+    def dgradients2_dXdX2(self, X, X2, dimX, dimX2):
+        g1 = self.dK3_dvariancedXdX2(X, X2, dimX, dimX2)
+        g2 = self.dK3_dlengthscaledXdX2(X, X2, dimX, dimX2)
+        return [g1, g2]
 
     def _gradients_X_pure(self, dL_dK, X, X2=None):
         invdist = self._inv_dist(X, X2)
         dL_dr = self.dK_dr_via_X(X, X2) * dL_dK
         tmp = invdist*dL_dr
         if X2 is None:
             tmp = tmp + tmp.T
```

## PLATLIB/GPy/likelihoods/binomial.py

```diff
@@ -62,15 +62,14 @@
         :returns: log likelihood evaluated at points inverse link of f.
         :rtype: float
         """
         N = Y_metadata['trials']
         np.testing.assert_array_equal(N.shape, y.shape)
 
         nchoosey = special.gammaln(N+1) - special.gammaln(y+1) - special.gammaln(N-y+1)
-        
         Ny = N-y
         t1 = np.zeros(y.shape)
         t2 = np.zeros(y.shape)
         t1[y>0] = y[y>0]*np.log(inv_link_f[y>0])
         t2[Ny>0] = Ny[Ny>0]*np.log(1.-inv_link_f[Ny>0])
         
         return nchoosey + t1 + t2
@@ -173,14 +172,49 @@
         gp = gp.flatten()
         N = Y_metadata['trials']
         Ysim = np.random.binomial(N, self.gp_link.transf(gp))
         return Ysim.reshape(orig_shape)
 
     def exact_inference_gradients(self, dL_dKdiag,Y_metadata=None):
         pass
+    
+    def moments_match_ep(self,obs,tau,v,Y_metadata_i=None):
+        """
+        Calculation of moments using quadrature
+        :param obs: observed output
+        :param tau: cavity distribution 1st natural parameter (precision)
+        :param v: cavity distribution 2nd natural paramenter (mu*precision)
+        """
+        #Compute first integral for zeroth moment.
+        #NOTE constant np.sqrt(2*pi/tau) added at the end of the function
+        if (isinstance(self.gp_link, link_functions.Probit) or isinstance(self.gp_link, link_functions.ScaledProbit)) and (Y_metadata_i is None or int(Y_metadata_i.get('trials', 1)) == int(1)): #Special case for probit likelihood. Can be found from Riihimaki et Vehtari 2010
+            if isinstance(self.gp_link, link_functions.ScaledProbit):
+                nu = self.gp_link.nu
+            else:
+                nu = 1.0
+            nu = self.gp_link.nu
+            mu = v/tau
+            sigma2 = 1./tau
+            t = np.asarray(1 + sigma2*(nu**2))
+            t[t<1e-20] = 1e-20
+            a = np.sqrt(t)
+            z = obs*mu/a
+            normc_z = max(self.gp_link.transf(z), 1e-20)
+            m0 = normc_z
+            normp_z = self.gp_link.dtransf_df(z)
+            m1 = mu + (obs*sigma2*normp_z)/(normc_z*a)
+            #print('tau: {}, v: {}, nu: {}, z: {}, normc_z: {}, normp_z: {}'.format(tau, v, nu.values, z, normc_z, normp_z))
+            m2 = sigma2 - ((sigma2**2)*normp_z)/((1./(nu**2)+sigma2)*normc_z)*(z + normp_z/(nu**2)/normc_z)
+            #print("m0: {}, m1: {}, m2: {}".format(m0,m1,m2))
+            #m0a, m1a, m2a =  super(Binomial, self).moments_match_ep(obs,tau,v,Y_metadata_i)
+            #print("m0a: {}, m1a: {}, m2a: {}".format(m0a,m1a,m2a))
+            return m0, m1, m2
+        else:
+            return super(Binomial, self).moments_match_ep(obs,tau,v,Y_metadata_i)
+    
     def variational_expectations(self, Y, m, v, gh_points=None, Y_metadata=None):
         if isinstance(self.gp_link, link_functions.Probit):
 
             if gh_points is None:
                 gh_x, gh_w = self._gh_points()
             else:
                 gh_x, gh_w = gh_points
```

## PLATLIB/GPy/likelihoods/likelihood.py

```diff
@@ -292,15 +292,15 @@
                 f = partial(self.integrate_gk)
                 quads = zip(*map(f, Y.flatten(), mu.flatten(), np.sqrt(sigma2.flatten()), Y_metadata_list))
                 quads = np.vstack(quads)
                 quads.reshape(self.size, shape[0], shape[1])
             elif quad_mode == 'gh':
                 f = partial(self.integrate_gh)
                 quads = zip(*map(f, Y.flatten(), mu.flatten(), np.sqrt(sigma2.flatten())))
-                quads = np.hstack(quads)
+                quads = np.hstack(list(quads))
                 quads = quads.T
             else:
                 raise Exception("no other quadrature mode available")
             #     do a gaussian-hermite integration
             dL_dtheta_avg = boost_grad * np.nanmean(quads, axis=1)
             dL_dtheta = boost_grad * np.nansum(quads, axis=1)
             # dL_dtheta = boost_grad * np.nansum(dlik_dtheta, axis=1)
```

## PLATLIB/GPy/likelihoods/link_functions.py

```diff
@@ -134,14 +134,46 @@
         :return dict: json serializable dictionary containing the needed information to instantiate the object
         """
 
         input_dict = super(Probit, self)._save_to_input_dict()
         input_dict["class"] = "GPy.likelihoods.link_functions.Probit"
         return input_dict
 
+class ScaledProbit(Probit):
+    """
+    .. math::
+        g(f) = \\Phi^{-1} (nu*mu)
+    """
+    def __init__(self, nu=1.):
+        self.nu = float(nu)
+        
+    def transf(self,f):
+        return std_norm_cdf(f*self.nu)
+
+    def dtransf_df(self,f):
+        return std_norm_pdf(f*self.nu)*self.nu
+
+    def d2transf_df2(self,f):
+        return -(f*self.nu) * std_norm_pdf(f*self.nu)*(self.nu**2)
+
+    def d3transf_df3(self,f):
+        return (safe_square(f*self.nu)-1.)*std_norm_pdf(f*self.nu)*(self.nu**3)
+    
+    def to_dict(self):
+        """
+        Convert the object into a json serializable dictionary.
+
+        Note: It uses the private method _save_to_input_dict of the parent.
+
+        :return dict: json serializable dictionary containing the needed information to instantiate the object
+        """
+
+        input_dict = super(ScaledProbit, self)._save_to_input_dict()
+        input_dict["class"] = "GPy.likelihoods.link_functions.ScaledProbit"
+        return input_dict
 
 class Cloglog(GPTransformation):
     """
     Complementary log-log link
     .. math::
 
         p(f) = 1 - e^{-e^f}
```

## PLATLIB/GPy/likelihoods/multioutput_likelihood.py

```diff
@@ -10,15 +10,15 @@
 from . import link_functions
 from .likelihood import Likelihood
 from .mixed_noise import MixedNoise
 from .gaussian import Gaussian
 from ..core.parameterization import Param
 from paramz.transformations import Logexp
 from ..core.parameterization import Parameterized
-from ..kern.src.independent_outputs import index_to_slices
+from ..util.multioutput import index_to_slices
 import itertools
 
 class MultioutputLikelihood(MixedNoise):
     '''
     CombinedLikelihood is used to combine different likelihoods for 
     multioutput models, where different outputs have different observation models.
```

## PLATLIB/GPy/models/__init__.py

```diff
@@ -26,7 +26,8 @@
 from .state_space_model import StateSpace
 from .ibp_lfm import IBPLFM
 from .gp_offset_regression import GPOffsetRegression
 from .gp_grid_regression import GPRegressionGrid
 from .gp_multiout_regression import GPMultioutRegression
 from .gp_multiout_regression_md import GPMultioutRegressionMD
 from .tp_regression import TPRegression
+from .multioutput_gp import MultioutputGP
```

## PLATLIB/GPy/plotting/matplot_dep/base_plots.py

```diff
@@ -1,12 +1,14 @@
 # #Copyright (c) 2012, GPy authors (see AUTHORS.txt).
 # Licensed under the BSD 3-clause license (see LICENSE.txt)
 from matplotlib import pyplot as plt
 import numpy as np
 
+from .util import align_subplot_array, align_subplots
+
 def ax_default(fignum, ax):
     if ax is None:
         fig = plt.figure(fignum)
         ax = fig.add_subplot(111)
     else:
         fig = ax.figure
     return fig, ax
@@ -46,81 +48,81 @@
     plots = []
 
     #here's the box
     if 'linewidth' not in kwargs:
         kwargs['linewidth'] = 0.5
     if not 'alpha' in kwargs.keys():
         kwargs['alpha'] = 1./(len(percentiles))
-    
+
     # pop where from kwargs
     where = kwargs.pop('where') if 'where' in kwargs else None
     # pop interpolate, which we actually do not do here!
     if 'interpolate' in kwargs: kwargs.pop('interpolate')
-    
+
     def pairwise(inlist):
         l = len(inlist)
         for i in range(int(np.ceil(l/2.))):
             yield inlist[:][i], inlist[:][(l-1)-i]
-    
+
     polycol = []
     for y1, y2 in pairwise(percentiles):
         import matplotlib.mlab as mlab
         # Handle united data, such as dates
         ax._process_unit_info(xdata=x, ydata=y1)
         ax._process_unit_info(ydata=y2)
-    
+
         # Convert the arrays so we can work with them
         from numpy import ma
         x = ma.masked_invalid(ax.convert_xunits(x))
         y1 = ma.masked_invalid(ax.convert_yunits(y1))
         y2 = ma.masked_invalid(ax.convert_yunits(y2))
-    
+
         if y1.ndim == 0:
             y1 = np.ones_like(x) * y1
         if y2.ndim == 0:
             y2 = np.ones_like(x) * y2
-    
+
         if where is None:
             where = np.ones(len(x), np.bool)
         else:
             where = np.asarray(where, np.bool)
-    
+
         if not (x.shape == y1.shape == y2.shape == where.shape):
             raise ValueError("Argument dimensions are incompatible")
-    
+
         mask = reduce(ma.mask_or, [ma.getmask(a) for a in (x, y1, y2)])
         if mask is not ma.nomask:
             where &= ~mask
-        
+
         polys = []
         for ind0, ind1 in mlab.contiguous_regions(where):
             xslice = x[ind0:ind1]
             y1slice = y1[ind0:ind1]
             y2slice = y2[ind0:ind1]
-    
+
             if not len(xslice):
                 continue
-    
+
             N = len(xslice)
             X = np.zeros((2 * N + 2, 2), np.float)
-    
+
             # the purpose of the next two lines is for when y2 is a
             # scalar like 0 and we want the fill to go all the way
             # down to 0 even if none of the y1 sample points do
             start = xslice[0], y2slice[0]
             end = xslice[-1], y2slice[-1]
-    
+
             X[0] = start
             X[N + 1] = end
-    
+
             X[1:N + 1, 0] = xslice
             X[1:N + 1, 1] = y1slice
             X[N + 2:, 0] = xslice[::-1]
             X[N + 2:, 1] = y2slice[::-1]
-    
+
             polys.append(X)
         polycol.extend(polys)
     from matplotlib.collections import PolyCollection
     plots.append(PolyCollection(polycol, **kwargs))
     ax.add_collection(plots[-1], autolim=True)
     ax.autoscale_view()
     return plots
@@ -163,73 +165,14 @@
         if i%2 == 1:   # odd indices
             line.set_visible(False)
 
 def fewerXticks(ax=None,divideby=2):
     ax = ax or plt.gca()
     ax.set_xticks(ax.get_xticks()[::divideby])
 
-def align_subplots(N,M,xlim=None, ylim=None):
-    """make all of the subplots have the same limits, turn off unnecessary ticks"""
-    #find sensible xlim,ylim
-    if xlim is None:
-        xlim = [np.inf,-np.inf]
-        for i in range(N*M):
-            plt.subplot(N,M,i+1)
-            xlim[0] = min(xlim[0],plt.xlim()[0])
-            xlim[1] = max(xlim[1],plt.xlim()[1])
-    if ylim is None:
-        ylim = [np.inf,-np.inf]
-        for i in range(N*M):
-            plt.subplot(N,M,i+1)
-            ylim[0] = min(ylim[0],plt.ylim()[0])
-            ylim[1] = max(ylim[1],plt.ylim()[1])
-
-    for i in range(N*M):
-        plt.subplot(N,M,i+1)
-        plt.xlim(xlim)
-        plt.ylim(ylim)
-        if (i)%M:
-            plt.yticks([])
-        else:
-            removeRightTicks()
-        if i<(M*(N-1)):
-            plt.xticks([])
-        else:
-            removeUpperTicks()
-
-def align_subplot_array(axes,xlim=None, ylim=None):
-    """
-    Make all of the axes in the array hae the same limits, turn off unnecessary ticks
-    use plt.subplots() to get an array of axes
-    """
-    #find sensible xlim,ylim
-    if xlim is None:
-        xlim = [np.inf,-np.inf]
-        for ax in axes.flatten():
-            xlim[0] = min(xlim[0],ax.get_xlim()[0])
-            xlim[1] = max(xlim[1],ax.get_xlim()[1])
-    if ylim is None:
-        ylim = [np.inf,-np.inf]
-        for ax in axes.flatten():
-            ylim[0] = min(ylim[0],ax.get_ylim()[0])
-            ylim[1] = max(ylim[1],ax.get_ylim()[1])
-
-    N,M = axes.shape
-    for i,ax in enumerate(axes.flatten()):
-        ax.set_xlim(xlim)
-        ax.set_ylim(ylim)
-        if (i)%M:
-            ax.set_yticks([])
-        else:
-            removeRightTicks(ax)
-        if i<(M*(N-1)):
-            ax.set_xticks([])
-        else:
-            removeUpperTicks(ax)
-
 def x_frame1D(X,plot_limits=None,resolution=None):
     """
     Internal helper function for making plots, returns a set of input values to plot as well as lower and upper limits
     """
     assert X.shape[1] ==1, "x_frame1D is defined for one-dimensional inputs"
     if plot_limits is None:
         from ...core.parameterization.variational import VariationalPosterior
```

## PLATLIB/GPy/plotting/plotly_dep/defaults.py

```diff
@@ -40,15 +40,15 @@
 
 In the code, always ise plotting.gpy_plots.defaults to get the defaults, as
 it gives back an empty default, when defaults are not defined.
 '''
 
 # Data plots:
 data_1d = dict(marker_kwargs=dict(), marker='x', color='black')
-data_2d = dict(marker='o', cmap='Hot', marker_kwargs=dict(opacity=1., size='5', line=Line(width=.5, color='black')))
+data_2d = dict(marker='o', cmap='Hot', marker_kwargs=dict(opacity=1., size=5, line=Line(width=.5, color='black')))
 inducing_1d = dict(color=Tango.colorsHex['darkRed'])
 inducing_2d = dict(marker_kwargs=dict(size='5', opacity=.7, line=Line(width=.5, color='black')), opacity=.7, color='white', marker='star-triangle-up')
 inducing_3d = dict(marker_kwargs=dict(symbol='diamond', size='5', opacity=.7, line=Line(width=.1, color='black')), color='#F5F5F5')
 xerrorbar = dict(color='black', error_kwargs=dict(thickness=.5), opacity=.5)
 yerrorbar = dict(color=Tango.colorsHex['darkRed'], error_kwargs=dict(thickness=.5), opacity=.5)
 #
 # # GP plots:
```

## PLATLIB/GPy/plotting/plotly_dep/plot_definitions.py

```diff
@@ -35,23 +35,23 @@
 from plotly import tools
 from plotly.graph_objs import Scatter, Scatter3d, Line,\
     Marker, ErrorX, ErrorY, Bar, Heatmap, Trace,\
     Annotations, Annotation, Contour, Font, Surface
 from plotly.exceptions import PlotlyDictKeyError
 
 SYMBOL_MAP = {
-    'o': 'dot',
+    'o': 'circle-dot',
     'v': 'triangle-down',
     '^': 'triangle-up',
     '<': 'triangle-left',
     '>': 'triangle-right',
     's': 'square',
     '+': 'cross',
     'x': 'x',
-    '*': 'x',  # no star yet in plotly!!
+    '*': 'star',
     'D': 'diamond',
     'd': 'diamond',
 }
 
 class PlotlyPlotsBase(AbstractPlottingLibrary):
     def __init__(self):
         super(PlotlyPlotsBase, self).__init__()
```

## PLATLIB/GPy/testing/kernel_tests.py

```diff
@@ -3,15 +3,15 @@
 
 import unittest
 from unittest.case import skip
 
 import GPy
 from GPy.core.parameterization.param import Param
 import numpy as np
-
+import random
 from ..util.config import config
 
 
 verbose = 0
 
 try:
     from ..kern.src import coregionalize_cython
```

## PLATLIB/GPy/testing/link_function_tests.py

```diff
@@ -1,16 +1,17 @@
 import numpy as np
 import scipy
 from scipy.special import cbrt
 from GPy.models import GradientChecker
+import random
 _lim_val = np.finfo(np.float64).max
 _lim_val_exp = np.log(_lim_val)
 _lim_val_square = np.sqrt(_lim_val)
 _lim_val_cube = cbrt(_lim_val)
-from GPy.likelihoods.link_functions import Identity, Probit, Cloglog, Log, Log_ex_1, Reciprocal, Heaviside
+from GPy.likelihoods.link_functions import Identity, Probit, Cloglog, Log, Log_ex_1, Reciprocal, Heaviside, ScaledProbit
 
 class LinkFunctionTests(np.testing.TestCase):
     def setUp(self):
         self.small_f = np.array([[-1e-4]])
         self.zero_f = np.array([[1e-4]])
         self.mid_f = np.array([[5.0]])
         self.large_f = np.array([[1e4]])
@@ -119,14 +120,19 @@
         #FIXME: Should be able to think of a way to test the limits of this
         self.check_gradient(link, lim_of_inf, test_lim=False)
 
     def test_probit_gradients(self):
         link = Probit()
         lim_of_inf = _lim_val
         self.check_gradient(link, lim_of_inf, test_lim=True)
+        
+    def test_scaledprobit_gradients(self):
+        link = ScaledProbit(nu=random.random())
+        lim_of_inf = _lim_val
+        self.check_gradient(link, lim_of_inf, test_lim=True)
 
     def test_Cloglog_gradients(self):
         link = Cloglog()
         lim_of_inf = _lim_val_exp
         self.check_gradient(link, lim_of_inf, test_lim=True)
 
     def test_Log_ex_1_gradients(self):
```

## PLATLIB/GPy/testing/model_tests.py

```diff
@@ -1176,14 +1176,75 @@
     def test_posterior_covariance_missing_data(self):
         Q = 4
         k = GPy.kern.Linear(Q, ARD=True)
         m = _create_missing_data_model(k, Q)
 
         with self.assertRaises(RuntimeError):
             m.posterior_covariance_between_points(np.array([[1], [2]]), np.array([[3], [4]]))
+    
+    def test_multioutput_model_with_derivative_observations(self):
+        f = lambda x: np.sin(x)+0.1*(x-2.)**2-0.005*x**3
+        fd = lambda x: np.cos(x)+0.2*(x-2.)-0.015*x**2
+        N=10
+        M=10
+        sigma=0.05
+        sigmader=0.05
+        x = np.array([np.linspace(1,10,N)]).T
+        y = f(x) + np.array(sigma*np.random.normal(0,1,(N,1)))
+
+        xd = np.array([np.linspace(2,8,M)]).T
+        yd = fd(xd) + np.array(sigmader*np.random.normal(0,1,(M,1)))
+
+        # squared exponential kernel:
+        se = GPy.kern.RBF(input_dim = 1, lengthscale=1.5, variance=0.2)
+        # We need to generate separate kernel for the derivative observations and give the created kernel as an input:
+        se_der = GPy.kern.DiffKern(se, 0)
+
+        #Then 
+        gauss = GPy.likelihoods.Gaussian(variance=sigma**2)
+        gauss = GPy.likelihoods.Gaussian(variance=0.1)
+        gauss_der = GPy.likelihoods.Gaussian(variance=sigma**2)
+
+        # Then create the model, we give everything in lists, the order of the inputs indicates the order of the outputs
+        # Now we have the regular observations first and derivative observations second, meaning that the kernels and
+        # the likelihoods must follow the same order
+        m = GPy.models.MultioutputGP(X_list=[x, xd], Y_list=[y, yd], kernel_list=[se, se_der], likelihood_list = [gauss, gauss])
+        m.randomize()
+        self.assertTrue(m.checkgrad())
+
+        m.optimize(messages=0, ipython_notebook=False)
+
+        self.assertTrue(m.checkgrad())
+
+    def test_multioutput_model_with_ep(self):
+        f = lambda x: np.sin(x)+0.1*(x-2.)**2-0.005*x**3
+        fd = lambda x: np.cos(x)+0.2*(x-2.)-0.015*x**2
+        N=10
+        sigma=0.05
+        sigmader=0.05
+        x = np.array([np.linspace(1,10,N)]).T
+        y = f(x) + np.array(sigma*np.random.normal(0,1,(N,1)))
+
+        M=7
+        xd = np.array([np.linspace(2,8,M)]).T
+        yd = 2*(fd(xd)>0) -1
+
+        # squared exponential kernel:
+        se = GPy.kern.RBF(input_dim = 1, lengthscale=1.5, variance=0.2)
+        # We need to generate separate kernel for the derivative observations and give the created kernel as an input:
+        se_der = GPy.kern.DiffKern(se, 0)
+
+        #Then 
+        gauss = GPy.likelihoods.Gaussian(variance=sigma**2)
+        probit = GPy.likelihoods.Binomial(gp_link = GPy.likelihoods.link_functions.ScaledProbit(nu=100))
+
+        # Then create the model, we give everything in lists
+        m = GPy.models.MultioutputGP(X_list=[x, xd], Y_list=[y, yd], kernel_list=[se, se_der], likelihood_list = [gauss, probit], inference_method=GPy.inference.latent_function_inference.EP(ep_mode="nested"))
+        
+        self.assertTrue(m.checkgrad())       
 
 def _create_missing_data_model(kernel, Q):
     D1, D2, D3, N, num_inducing = 13, 5, 8, 400, 3
     _, _, Ylist = GPy.examples.dimensionality_reduction._simulate_matern(D1, D2, D3, N, num_inducing, False)
     Y = Ylist[0]
 
     inan = np.random.binomial(1, .9, size=Y.shape).astype(bool) # 80% missing data
```

## PLATLIB/GPy/testing/plotting_tests.py

```diff
@@ -34,24 +34,25 @@
 # SYSTEMS, AND WILL MISBEHAVE
 from nose import SkipTest
 #raise SkipTest("Skipping Matplotlib testing")
 #===============================================================================
 
 try:
     import matplotlib
-    # matplotlib.use('agg')
+    matplotlib.use('agg', warn=False)
 except ImportError:
     # matplotlib not installed
     from nose import SkipTest
     raise SkipTest("Error importing matplotlib")
 
 from unittest.case import TestCase
 
 import numpy as np
 import GPy, os
+import logging
 
 from GPy.util.config import config
 from GPy.plotting import change_plotting_library, plotting_library
 
 class ConfigTest(TestCase):
     def tearDown(self):
         change_plotting_library('matplotlib')
@@ -94,26 +95,34 @@
     raise SkipTest("Not installed from source, baseline not available. Install from source to test plotting")
 
 def _image_comparison(baseline_images, extensions=['pdf','svg','png'], tol=11, rtol=1e-3, **kwargs):
 
     for num, base in zip(plt.get_fignums(), baseline_images):
         for ext in extensions:
             fig = plt.figure(num)
-            fig.canvas.draw()
+            try:
+                fig.canvas.draw()
+            except Exception as e:
+                logging.error(base)
+                #raise SkipTest(e)
             #fig.axes[0].set_axis_off()
             #fig.set_frameon(False)
             if ext in ['npz']:
                 figdict = flatten_axis(fig)
                 np.savez_compressed(os.path.join(result_dir, "{}.{}".format(base, ext)), **figdict)
-                fig.savefig(os.path.join(result_dir, "{}.{}".format(base, 'png')),
-                            transparent=True,
-                            edgecolor='none',
-                            facecolor='none',
-                            #bbox='tight'
-                            )
+                try:
+                    fig.savefig(os.path.join(result_dir, "{}.{}".format(base, 'png')),
+                                transparent=True,
+                                edgecolor='none',
+                                facecolor='none',
+                                #bbox='tight'
+                                )
+                except:
+                    logging.error(base)
+                    # raise
             else:
                 fig.savefig(os.path.join(result_dir, "{}.{}".format(base, ext)),
                             transparent=True,
                             edgecolor='none',
                             facecolor='none',
                             #bbox='tight'
                             )
@@ -327,18 +336,17 @@
     m.plot_samples(projection='3d', samples=1)
     m.plot_samples(projection='3d', plot_raw=False, samples=1)
     plt.close('all')
     m.plot_data(projection='3d')
     m.plot_mean(projection='3d', rstride=10, cstride=10)
     m.plot_inducing(projection='3d')
     #m.plot_errorbars_trainset(projection='3d')
-    for do_test in _image_comparison(baseline_images=['gp_3d_{}'.format(sub) for sub in ["data", "mean", 'inducing',
-                                                                                         #'error',
-                                                                                          #"samples", "samples_lik"
-                                                                                          ]], extensions=extensions):
+    for do_test in _image_comparison(baseline_images=[
+        'gp_3d_{}'.format(sub) for sub in ["data", "mean", 'inducing',
+    ]], extensions=extensions):
         yield (do_test, )
 
 def test_sparse():
     np.random.seed(11111)
     import matplotlib
     matplotlib.rcParams.update(matplotlib.rcParamsDefault)
     #matplotlib.rcParams[u'figure.figsize'] = (4,3)
```

## PLATLIB/GPy/util/multioutput.py

```diff
@@ -1,11 +1,38 @@
 import numpy as np
 import warnings
 import GPy
 
+def index_to_slices(index):
+    """
+    take a numpy array of integers (index) and return a  nested list of slices such that the slices describe the start, stop points for each integer in the index.
+
+    e.g.
+    >>> index = np.asarray([0,0,0,1,1,1,2,2,2])
+    returns
+    >>> [[slice(0,3,None)],[slice(3,6,None)],[slice(6,9,None)]]
+
+    or, a more complicated example
+    >>> index = np.asarray([0,0,1,1,0,2,2,2,1,1])
+    returns
+    >>> [[slice(0,2,None),slice(4,5,None)],[slice(2,4,None),slice(8,10,None)],[slice(5,8,None)]]
+    """
+    if len(index)==0:
+        return[]
+
+    #contruct the return structure
+    ind = np.asarray(index,dtype=np.int)
+    ret = [[] for i in range(ind.max()+1)]
+
+    #find the switchpoints
+    ind_ = np.hstack((ind,ind[0]+ind[-1]+1))
+    switchpoints = np.nonzero(ind_ - np.roll(ind_,+1))[0]
+
+    [ret[ind_i].append(slice(*indexes_i)) for ind_i,indexes_i in zip(ind[switchpoints[:-1]],zip(switchpoints,switchpoints[1:]))]
+    return ret
 
 def get_slices(input_list):
     num_outputs = len(input_list)
     _s = [0] + [ _x.shape[0] for _x in input_list ]
     _s = np.cumsum(_s)
     slices = [slice(a,b) for a,b in zip(_s[:-1],_s[1:])]
     return slices
```

## Comparing `PLATLIB/GPy-1.9.8-py3.7.egg-info/PKG-INFO` & `PLATLIB/GPy-1.9.9-py3.7.egg-info/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: GPy
-Version: 1.9.8
+Version: 1.9.9
 Summary: The Gaussian Process Toolbox
 Home-page: http://sheffieldml.github.com/GPy/
 Author: GPy Authors: https://github.com/SheffieldML/GPy/graphs/contributors
 Author-email: gpy.authors@gmail.com
 License: BSD 3-clause
 Download-URL: https://github.com/SheffieldML/GPy/
 Description: 
@@ -23,11 +23,11 @@
 Classifier: Programming Language :: Python :: 3.5
 Classifier: Programming Language :: Python :: 3.6
 Classifier: Framework :: IPython
 Classifier: Intended Audience :: Science/Research
 Classifier: Intended Audience :: Developers
 Classifier: Topic :: Software Development
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
-Provides-Extra: notebook
+Provides-Extra: docs
 Provides-Extra: optional
 Provides-Extra: plotting
-Provides-Extra: docs
+Provides-Extra: notebook
```

## Comparing `PLATLIB/GPy-1.9.8-py3.7.egg-info/SOURCES.txt` & `PLATLIB/GPy-1.9.9-py3.7.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -74,25 +74,27 @@
 GPy/kern/src/__init__.py
 GPy/kern/src/add.py
 GPy/kern/src/basis_funcs.py
 GPy/kern/src/brownian.py
 GPy/kern/src/coregionalize.py
 GPy/kern/src/coregionalize_cython.c
 GPy/kern/src/coregionalize_cython.pyx
+GPy/kern/src/diff_kern.py
 GPy/kern/src/eq_ode1.py
 GPy/kern/src/eq_ode2.py
 GPy/kern/src/grid_kerns.py
 GPy/kern/src/independent_outputs.py
 GPy/kern/src/integral.py
 GPy/kern/src/integral_limits.py
 GPy/kern/src/kern.py
 GPy/kern/src/kernel_slice_operations.py
 GPy/kern/src/linear.py
 GPy/kern/src/mlp.py
 GPy/kern/src/multidimensional_integral_limits.py
+GPy/kern/src/multioutput_derivative_kern.py
 GPy/kern/src/multioutput_kern.py
 GPy/kern/src/periodic.py
 GPy/kern/src/poly.py
 GPy/kern/src/prod.py
 GPy/kern/src/rbf.py
 GPy/kern/src/sde_brownian.py
 GPy/kern/src/sde_linear.py
@@ -163,14 +165,15 @@
 GPy/models/gp_regression.py
 GPy/models/gp_var_gauss.py
 GPy/models/gplvm.py
 GPy/models/gradient_checker.py
 GPy/models/ibp_lfm.py
 GPy/models/input_warped_gp.py
 GPy/models/mrd.py
+GPy/models/multioutput_gp.py
 GPy/models/one_vs_all_classification.py
 GPy/models/one_vs_all_sparse_classification.py
 GPy/models/sparse_gp_classification.py
 GPy/models/sparse_gp_coregionalized_regression.py
 GPy/models/sparse_gp_minibatch.py
 GPy/models/sparse_gp_regression.py
 GPy/models/sparse_gp_regression_md.py
```

