# Comparing `tmp/illyrian-0.2.2-py3-none-any.whl.zip` & `tmp/illyrian-0.3.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,25 +1,29 @@
-Zip file size: 65235 bytes, number of entries: 23
--rw-r--r--  2.0 unx      107 b- defN 22-Oct-17 06:15 illyrian/__init__.py
--rw-r--r--  2.0 unx      123 b- defN 22-Oct-17 06:15 illyrian/__main__.py
--rw-r--r--  2.0 unx       19 b- defN 22-Oct-17 06:15 illyrian/cpython/__init__.py
--rw-r--r--  2.0 unx      837 b- defN 22-Oct-17 06:15 illyrian/cpython/code.py
--rw-r--r--  2.0 unx    41669 b- defN 22-Oct-17 06:15 illyrian/cpython/cpython310.py
--rw-r--r--  2.0 unx    34441 b- defN 22-Oct-17 06:15 illyrian/cpython/cpython36.py
--rw-r--r--  2.0 unx    46182 b- defN 22-Oct-17 06:15 illyrian/cpython/cpython37.py
--rw-r--r--  2.0 unx    49547 b- defN 22-Oct-17 06:15 illyrian/cpython/cpython38.py
--rw-r--r--  2.0 unx    42747 b- defN 22-Oct-17 06:15 illyrian/cpython/cpython39.py
--rw-r--r--  2.0 unx      292 b- defN 22-Oct-17 06:15 illyrian/env.py
--rw-r--r--  2.0 unx       19 b- defN 22-Oct-17 06:15 illyrian/manylinux/__init__.py
--rw-r--r--  2.0 unx     1261 b- defN 22-Oct-17 06:15 illyrian/manylinux/code.py
--rw-r--r--  2.0 unx      477 b- defN 22-Oct-17 06:15 illyrian/run.py
--rw-r--r--  2.0 unx       48 b- defN 22-Oct-17 06:24 illyrian/version.py
--rw-r--r--  2.0 unx    13153 b- defN 22-Oct-17 06:15 illyrian/wheel.py
--rw-r--r--  2.0 unx     1531 b- defN 22-Oct-17 06:15 illyrian/LICENSE
--rw-r--r--  2.0 unx     2584 b- defN 22-Oct-17 06:24 illyrian/cmake/FindIllyrian.cmake
--rw-r--r--  2.0 unx    16231 b- defN 22-Oct-17 06:15 illyrian/cmake/illyrian.cmake
--rwxrwxrwx  2.0 unx       40 b- defN 22-Oct-17 06:15 illyrian-0.2.2.data/scripts/illyrian
-?rw-------  2.0 unx    11107 b- defN 22-Oct-17 06:24 illyrian-0.2.2.dist-info/METADATA
-?rw-------  2.0 unx        8 b- defN 22-Oct-17 06:24 illyrian-0.2.2.dist-info/top_list.txt
-?rw-------  2.0 unx       87 b- defN 22-Oct-17 06:24 illyrian-0.2.2.dist-info/WHEEL
-?rw-------  2.0 unx     1920 b- defN 22-Oct-17 06:24 illyrian-0.2.2.dist-info/RECORD
-23 files, 264430 bytes uncompressed, 62255 bytes compressed:  76.5%
+Zip file size: 70360 bytes, number of entries: 27
+-rw-r--r--  2.0 unx      124 b- defN 23-Apr-20 13:19 illyrian/__init__.py
+-rw-r--r--  2.0 unx      123 b- defN 23-Apr-20 13:19 illyrian/__main__.py
+-rw-r--r--  2.0 unx       19 b- defN 23-Apr-20 13:19 illyrian/cpython/__init__.py
+-rw-r--r--  2.0 unx      837 b- defN 23-Apr-20 13:19 illyrian/cpython/code.py
+-rw-r--r--  2.0 unx    41669 b- defN 23-Apr-20 13:19 illyrian/cpython/cpython310.py
+-rw-r--r--  2.0 unx    34441 b- defN 23-Apr-20 13:19 illyrian/cpython/cpython36.py
+-rw-r--r--  2.0 unx    46182 b- defN 23-Apr-20 13:19 illyrian/cpython/cpython37.py
+-rw-r--r--  2.0 unx    49547 b- defN 23-Apr-20 13:19 illyrian/cpython/cpython38.py
+-rw-r--r--  2.0 unx    42747 b- defN 23-Apr-20 13:19 illyrian/cpython/cpython39.py
+-rw-r--r--  2.0 unx      292 b- defN 23-Apr-20 13:19 illyrian/env.py
+-rw-r--r--  2.0 unx     3026 b- defN 23-Apr-20 13:19 illyrian/info.py
+-rw-r--r--  2.0 unx       19 b- defN 23-Apr-20 13:19 illyrian/manylinux/__init__.py
+-rw-r--r--  2.0 unx     1261 b- defN 23-Apr-20 13:19 illyrian/manylinux/code.py
+-rw-r--r--  2.0 unx     1389 b- defN 23-Apr-20 13:19 illyrian/run.py
+-rw-r--r--  2.0 unx       19 b- defN 23-Apr-20 13:19 illyrian/util/__init__.py
+-rw-r--r--  2.0 unx      722 b- defN 23-Apr-20 13:19 illyrian/util/code.py
+-rw-r--r--  2.0 unx     3322 b- defN 23-Apr-20 13:19 illyrian/verify.py
+-rw-r--r--  2.0 unx       48 b- defN 23-Apr-26 07:47 illyrian/version.py
+-rw-r--r--  2.0 unx    15303 b- defN 23-Apr-20 13:19 illyrian/wheel.py
+-rw-r--r--  2.0 unx     2584 b- defN 23-Apr-26 07:47 illyrian/cmake/FindIllyrian.cmake
+-rw-r--r--  2.0 unx    17881 b- defN 23-Apr-20 13:19 illyrian/cmake/illyrian.cmake
+-rwxrwxrwx  2.0 unx       40 b- defN 23-Apr-20 13:19 illyrian-0.3.0.data/scripts/illyrian
+-rw-r--r--  2.0 unx     1531 b- defN 23-Apr-20 13:19 illyrian-0.3.0.dist-info/LICENSE
+-rw-------  2.0 unx    12578 b- defN 23-Apr-26 07:47 illyrian-0.3.0.dist-info/METADATA
+-rw-------  2.0 unx       87 b- defN 23-Apr-26 07:47 illyrian-0.3.0.dist-info/WHEEL
+-rw-------  2.0 unx        8 b- defN 23-Apr-26 07:47 illyrian-0.3.0.dist-info/top_list.txt
+-rw-------  2.0 unx     2228 b- defN 23-Apr-26 07:47 illyrian-0.3.0.dist-info/RECORD
+27 files, 278027 bytes uncompressed, 66884 bytes compressed:  75.9%
```

## zipnote {}

```diff
@@ -24,47 +24,59 @@
 
 Filename: illyrian/cpython/cpython39.py
 Comment: 
 
 Filename: illyrian/env.py
 Comment: 
 
+Filename: illyrian/info.py
+Comment: 
+
 Filename: illyrian/manylinux/__init__.py
 Comment: 
 
 Filename: illyrian/manylinux/code.py
 Comment: 
 
 Filename: illyrian/run.py
 Comment: 
 
-Filename: illyrian/version.py
+Filename: illyrian/util/__init__.py
 Comment: 
 
-Filename: illyrian/wheel.py
+Filename: illyrian/util/code.py
+Comment: 
+
+Filename: illyrian/verify.py
 Comment: 
 
-Filename: illyrian/LICENSE
+Filename: illyrian/version.py
+Comment: 
+
+Filename: illyrian/wheel.py
 Comment: 
 
 Filename: illyrian/cmake/FindIllyrian.cmake
 Comment: 
 
 Filename: illyrian/cmake/illyrian.cmake
 Comment: 
 
-Filename: illyrian-0.2.2.data/scripts/illyrian
+Filename: illyrian-0.3.0.data/scripts/illyrian
+Comment: 
+
+Filename: illyrian-0.3.0.dist-info/LICENSE
 Comment: 
 
-Filename: illyrian-0.2.2.dist-info/METADATA
+Filename: illyrian-0.3.0.dist-info/METADATA
 Comment: 
 
-Filename: illyrian-0.2.2.dist-info/top_list.txt
+Filename: illyrian-0.3.0.dist-info/WHEEL
 Comment: 
 
-Filename: illyrian-0.2.2.dist-info/WHEEL
+Filename: illyrian-0.3.0.dist-info/top_list.txt
 Comment: 
 
-Filename: illyrian-0.2.2.dist-info/RECORD
+Filename: illyrian-0.3.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## illyrian/__init__.py

```diff
@@ -1,6 +1,6 @@
 from .version import *
-import illyrian.cpython
-
 from .wheel import *
+from .info import *
+from .verify import *
 from .env import *
 from .run import *
```

## illyrian/run.py

```diff
@@ -1,19 +1,55 @@
 # Copyright 2022 NEC Laboratories Europe
 # Author: Nicolas Weber <nicolas.weber@neclab.eu>
 
 __all__ = ['run']
 
 import sys
+import os
 import illyrian
+import glob
+from illyrian.util import L_EMPH, L_RESET
+import pydot
+import shutil
 
 def run():
-	print("#### Illyrian v{} ####".format(illyrian.__version__))
+	print(f'{L_EMPH}#### Illyrian v{illyrian.__version__} ####{L_RESET}')
 	print()
 
 	cnt = len(sys.argv)
+	if cnt == 1:
+		print('usage:')
+		print('    - build:  illyrian config.json')
+		print('    - info:   illyrian wheel.whl')
+		print('    - cmake:  illyrian /path/to/cmake ...')
+		print('    - verify: illyrian /path/to/install/folder')
+		return
 
-	if cnt == 1:			raise Exception('usage: illyrian config.json or illyrian /path/to/cmake ...')
-	if cnt == 2:
-		if sys.argv[1] == "--version":	exit(0)
-		else:							illyrian.wheel	(sys.argv[1])
-	else:								illyrian.env	(sys.argv[1:])
+	cmake = shutil.which(sys.argv[1])
+	if cmake is not None and cmake.endswith(('cmake', 'cmake3')) and os.path.isfile(cmake) and os.access(cmake, os.X_OK):
+		illyrian.env(sys.argv[1:])
+		return
+
+	graph, nodes = None, None
+
+	for x in sys.argv[1:]:
+		if x == "--version":
+			exit(0)
+
+		for y in glob.glob(x):
+			if os.path.isdir(y):
+				illyrian.verify(y)
+			elif os.path.isfile(y):
+				if y.endswith('.whl'):
+					if graph is None:
+						graph, nodes = pydot.Dot('Illyrian dependency graph', graph_type='graph'), dict()
+					illyrian.info(x, graph, nodes)
+				elif y.endswith('.json'):
+					illyrian.wheel(x)
+				else:
+					raise Exception(f'Unsupported file type: {y}')
+
+	if graph is not None:
+		try:
+			graph.write_svg('illyrian_dependencies.svg')
+		except OSError:
+			pass # it seems no dot is available
```

## illyrian/version.py

```diff
@@ -1,2 +1,2 @@
 __all__ = ['__version__']
-__version__ = '0.2.2'
+__version__ = '0.3.0'
```

## illyrian/wheel.py

```diff
@@ -4,28 +4,75 @@
 __all__ = ['wheel']
 
 import json
 import zipfile
 import re
 import os
 import glob
-import hashlib
-import base64
 import illyrian
 import subprocess
-from illyrian import cpython, manylinux
+from illyrian import cpython, manylinux, util
+from illyrian.util import L_EMPH, L_RESET
+
+class File:
+	def __init__(self, src, dst=None, chmod=None, content=None):
+		self.src = src
+		self.dst = src if dst is None else dst
+		self.chmod = chmod
+		self.content = content
+
+	def __str__(self):
+		out = f'{self.src}'
+		if self.src != self.dst:	out += f' > {self.dst}'
+		if self.chmod is not None:	out += f' ({oct(self.chmod)})'
+		return out
+
+	def __ref__(self):
+		return str(self)
+
+	def __lt__(self, o):
+		assert isinstance(o, File)
+		if self.src < o.src:	return True
+		if self.src > o.src:	return False
+		if self.dst < o.dst:	return True
+		if self.dst > o.dst:	return False
+		return self.chmod < o.chmod
+
+	def write(self, handle):
+		if self.content is None:
+			if os.path.islink(self.src):
+				raise Exception(f'{self.src} is a symlink. Symlinks are not supported by PIP!')
+			handle.write(self.src, arcname=self.dst)
+		else:
+			handle.writestr(self.dst, self.content)
+		
+		info = handle.getinfo(self.dst)
+		info.external_attr |= 0x80000000 # required to mark this as a real file?
+
+		if self.chmod:
+			info.external_attr |= self.chmod << 16
+
+	def read(self):
+		if self.content is None:
+			if os.path.exists(self.src):
+				return open(self.src, 'rb').read()
+			return None
+		return self.content.encode('UTF-8')
 
 def wheel(config_file):
 	global config
 
 	# Load Config File ---------------------------------------------------------
-	supported = {'author', 'author-email', 'classifier', 'download-url', 'homepage', 'keywords', 'license', 'maintainer', 'maintainer-email',
-		'obsoletes-dist', 'platform', 'project-url', 'provides-dist', 'requires-dist', 'requires-external', 'supported-platform',
-		'requires-python', 'summary', 'readme', 'name', 'version', 'abi-tag', 'platform-tag', '__include__', 'packages', 'scripts',
-		'payload', 'python-tag'}
+	supported = {'author', 'author-email', 'classifier', 'download-url', 'homepage',
+		'keywords', 'license', 'license-file', 'maintainer', 'maintainer-email',
+		'obsoletes-dist', 'platform', 'project-url', 'provides-dist',
+		'requires-dist', 'requires-external', 'supported-platform', 'requires-python',
+		'summary', 'readme', 'name', 'version', 'abi-tag', 'platform-tag',
+		'__include__', 'packages', 'scripts', 'payload', 'python-tag', 'provides-extra',
+		'links'}
 
 	def read_json(file):
 		j = None
 		try:
 			j = json.load(open(file, 'r'))
 		except Exception as e:
 			raise Exception(f'Cannot open {config_file}: {e}')
@@ -78,55 +125,64 @@
 		
 		value = config.pop(name).strip()
 		if len(value) == 0:
 			raise Exception(f'Empty field "{name}" in {config_file}')
 		
 		return value
 
+	def check_version(version):
+		# remove leading zeros
+		version = re.sub(r'^[0]+([0-9]+)', '\1', version)
+		version = re.sub(r'\.[0]+([0-9]+)', '\.\1', version)
+		if re.match(r'^([0-9]+!)?[0-9]+(\.[0-9]+)*((a|b|rc)[0-9]+)?(\.post[0-9]+)?(\.dev[0-9]+)?$', version) is None:
+			raise Exception(f'{version} is no valid python version in format: [N!]N(.N)*[{"a|b|rc"}N][.postN][.devN] (see PEP440)')
+		return version
+
 	name			= check('name')
-	version			= check('version')
+	version			= check_version(check('version'))
 	abi_tag			= config.pop('abi-tag', 'auto')
 	platform_tag	= config.pop('platform-tag', 'auto')
 
 	# https://www.python.org/dev/peps/pep-0427/#id13
 	distribution	= re.sub("[^\w\d.]+", "_", name, re.UNICODE)
 
 	#---------------------------------------------------------------------------
-	def generate_meta_data():
-		def required(key, fmt, can_be_list=False, regex=None):
-			def format(v):
-				if not isinstance(v, str):
-					raise Exception(f'Expected str for {fmt} but found {type(v)}')
+	def generate_meta_data(dist_info):
+		def process(value, key, fmt, can_be_list=False, regex=None):
+			def format(value):
+				if not isinstance(value, str):
+					raise Exception(f'Expected str for {fmt} but found {type(value)}')
 
-				v = v.strip()
+				value = value.strip()
 
-				if len(v) == 0:
+				if len(value) == 0:
 					raise Exception(f'Empty str found for {fmt}')
 
 				if regex:
-					if re.search(regex, value) is None:
+					if regex.search(value) is None:
 						raise Exception(f'Illegal value "{value}" in for {fmt}')
 				
-				return f'{fmt}: {v}\n'
-
-			value = config[key]
+				return f'{fmt}: {value}\n'
 
 			if isinstance(value, (list, tuple)):
 				if not can_be_list:
 					raise Exception(f'{key} can\'t be a list')
 				out = ''
 				for v in value:
 					out += format(v)
 				return out
 
 			return format(value)
 
-		def optional(key, fmt, can_be_list=False):
+		def required(key, fmt, can_be_list=False, regex=None):
+			return process(config[key], key, fmt, can_be_list, regex)			
+
+		def optional(key, fmt, can_be_list=False, regex=None):
 			if key in config:
-				return required(key, fmt, can_be_list)
+				return required(key, fmt, can_be_list, regex)
 			return ''
 
 		def git(key, git):
 			value = config.get(key, None)
 			if value == '__GIT__':
 				p = subprocess.run(['git', 'config', git], stdout=subprocess.PIPE)
 				if p.returncode != 0:
@@ -135,93 +191,84 @@
 
 		git('author',		'user.name')
 		git('author-email',	'user.email')
 
 		meta  = 'Metadata-Version: 2.1\n'
 		meta += f'Name: {name}\n'
 		meta += f'Version: {version}\n'
-		meta += required('requires-python',		'Requires-Python', regex='^[>=<\s]+[\.0-9]+[>=<\s,\.0-9]*$')
+		meta += required('requires-python',		'Requires-Python', regex=re.compile(r'^[>=<\s]+[\.0-9]+[>=<\s,\.0-9]*$'))
 		meta += required('summary',				'Summary')
 		meta += optional('author',				'Author')
 		meta += optional('author-email',		'Author-email')
 		meta += optional('classifier',			'Classifier',			True)
 		meta += optional('download-url',		'Download-URL')
 		meta += optional('homepage',			'Home-page')
 		meta += optional('keywords',			'Keywords')
 		meta += optional('license',				'License')
 		meta += optional('maintainer',			'Maintainer')
 		meta += optional('maintainer-email',	'Maintainer-Email')
 		meta += optional('obsoletes-dist',		'Obsoletes-Dist',		True)
 		meta += optional('platform',			'Platform',				True)
 		meta += optional('project-url',			'Project-URL',			True)
 		meta += optional('provides-dist',		'Provides-Dist',		True)
+		meta += optional('provides-extra',		'Provides-Extra',		True, regex=re.compile('^([a-z0-9]|[a-z0-9]([a-z0-9\-](?!--))*[a-z0-9])$'))
 		meta += optional('requires-dist', 		'Requires-Dist',		True)
 		meta += optional('requires-external',	'Requires-External',	True)
 		meta += optional('supported-platform',	'Supported-Platform',	True)
-		
-		print('## METADATA')
+
+		print(f'{L_EMPH}## METADATA{L_RESET}')
 		print(meta)
 
 		if 'readme' in config:
 			meta += 'Description-Content-Type: text/markdown\n\n'
 			meta += open(config['readme'], 'r').read()
 		else:
 			meta += 'Description-Content-Type: text/markdown\n\n'
 
-		return meta
+		return File(os.path.join(dist_info, 'METADATA'), content=meta)
 
 	#---------------------------------------------------------------------------
-	def generate_top_list():
+	def generate_top_list(dist_info):
 		top_list = distribution
-		return top_list
+		return File(os.path.join(dist_info, 'top_list.txt'), content=top_list)
 
 	#---------------------------------------------------------------------------
-	def generate_wheel():
+	def generate_wheel(dist_info):
 		wheel_  = 'Wheel-Version: 1.0\n'
 		wheel_ += f'Generator: illyrian ({illyrian.__version__})\n'
 		wheel_ += 'Root-Is-Purelib: true\n'
 		wheel_ += f'Tag: {abi_tag}-{platform_tag}\n'
-		print("## WHEEL")
+		print(f'{L_EMPH}## WHEEL{L_RESET}')
 		print(wheel_)
 		print()
-		return wheel_
+		return File(os.path.join(dist_info, 'WHEEL'), content=wheel_)
 
 	#---------------------------------------------------------------------------
-	def hash(content):
-		m = hashlib.sha256()
-		m.update(content)
-		return f'sha256={base64.b64encode(m.digest()).decode("UTF-8")}'
-
-	#---------------------------------------------------------------------------
-	def generate_record(file_lists, string_list):
+	def generate_record(files):
+		self = File(os.path.join(dist_info, 'RECORD'))
 		record = ''
-		for files in file_lists:
-			for file in files:
-				if isinstance(file, tuple):	src, dst = file[:2]
-				else:						src, dst = file, file
-				content = open(src, 'rb').read()
-				record += f'{dst}, {hash(content)}, {len(content)}\n'
-
-		for file, string in string_list:
-			if string is None:
-				h, l = '', ''
-			else:
-				content = string.encode('UTF-8')
-				h, l = hash(content), len(content)
-			record += f'{file}, {h}, {l}\n'
 
-		return record
+		def add(file, content):
+			nonlocal record
+			if content is None:	h, l = '', ''
+			else:				h, l = util.hash(content), len(content)
+			record += f'{file.dst}, {h}, {l}\n'
+
+		for file in files:
+			add(file, file.read())
+		add(self, None)
+
+		self.content = record
+		return self
 
 	#---------------------------------------------------------------------------
 	def get_condition(name):
 		split = name.strip().split('?')
-		if len(split) == 1:
-			return name, lambda x: x > 0, lambda x: f'{x} > 0'
-		if len(split) > 2:
-			raise Exception(f'Illegal search literal: {name}')
+		if len(split) == 1:	return name, lambda x: x > 0, lambda x: f'{x} > 0'
+		if len(split) > 2:	raise Exception(f'Illegal search literal: {name}')
 
 		name, conditions = split
 		if conditions == '':
 			conditions = '>=1' if '*' in name else '==1'
 
 		def parse(condition):
 			cond = re.match(r'\s*([!=><][=]?)\s*([0-9]+)', condition)
@@ -253,58 +300,66 @@
 				for package in packages:
 					package, condition, msg = get_condition(package.replace('.', '/'))
 					dir_list = []
 
 					try:
 						for file in os.listdir(package):
 							if os.path.isfile(os.path.join(package, file)) and os.path.splitext(file)[1] == '.py':
-								dir_list.append(os.path.join(package, file))
+								dir_list.append(File(os.path.join(package, file)))
 					except Exception as e:
 						if not condition(0):
 							raise Exception(f'Unable to find package "{package}"')
 
 					cnt = len(dir_list)
 					if not condition(cnt):
 						raise Exception(f'{msg(cnt)} failed for {package}')
 
 					python_files += dir_list
 
 				python_files.sort()
-				print('## Python Files')
+				print(f'{L_EMPH}## Python Files{L_RESET}')
 				print(*python_files, sep='\n')
 				print()
 		return python_files
 
 	#---------------------------------------------------------------------------
+	def find_headers(dist_info):
+		header_files = []
+		if 'license-file' in config:
+			license_file = config['license-file']
+			header_files.append(File(license_file, os.path.join(dist_info, 'LICENSE')))
+
+		if len(header_files):
+			print(f'{L_EMPH}## Header Files{L_RESET}')
+			print(*header_files, sep='\n')
+			print()
+		return header_files
+
+	#---------------------------------------------------------------------------
 	def find_scripts(data_path):
 		script_files = []
 		if 'scripts' in config:
 			for script in config['scripts']:
-				script_files.append((script, os.path.join(data_path, 'scripts', os.path.basename(script)), 0o777))
+				script_files.append(File(script, os.path.join(data_path, 'scripts', os.path.basename(script)), 0o777))
 
 			script_files.sort()
-			print('## Script Files')
-			print(*tuple(f[0] for f in script_files), sep='\n')
+		
+		if len(script_files):
+			print(f'{L_EMPH}## Script Files{L_RESET}')
+			print(*script_files, sep='\n')
 			print()
 		return script_files
 
 	#---------------------------------------------------------------------------
-	def check_platform_tag(platform_tag, platform_tag_):
-		if platform_tag == 'auto':			return platform_tag_
-		if platform_tag != platform_tag_:	raise Exception(f'Platform tag {platform_tag} is incompatible to {platform_tag_}')
-		return platform_tag
-
-	#---------------------------------------------------------------------------
 	def run_objdump(files):
 		VERSION				= re.compile(r'[a-z0-9\s]+([A-Z]+)_([0-9\.]+)')
 		PYTHON_SYMBOL		= re.compile(r'.*\s([_]?Py[A-Za-z0-9_]+)')
 		
-		p   				= subprocess.run(['objdump', '-x'] + files, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
+		p   				= subprocess.run(['objdump', '-x'] + [f.src for f in files], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
 		# we can't check the return_code, as it is non-zero if we add any non lib files, which is very likely.
-		objdump				= p.stdout.decode('utf-8').split('\n')
 		symbols, versions	= set(), dict()
 
 		for line in p.stdout.decode('utf-8').split('\n'):
 			m = PYTHON_SYMBOL.match(line)
 			if m: symbols.add(m[1]);							continue
 			m = VERSION.match(line)
 			if m: versions.setdefault(m[1], set()).add(m[2]);	continue
@@ -319,84 +374,97 @@
 				payload, condition, msg = get_condition(payload)
 				files	= glob.glob(payload, recursive=True)
 				files	= list(filter(lambda f: os.path.isfile(f), files))
 				cnt		= len(files)
 				if not condition(cnt):
 					raise Exception(f'{msg(cnt)} failed for {payload}')
 				
-				payload_files += files
+				for f in files:
+					payload_files.append(File(f))
 
 			payload_files.sort()
 
 			if platform_tag == 'auto' or abi_tag == 'auto':
 				symbols, versions = run_objdump(payload_files)
 				if platform_tag == 'auto':	platform_tag	= manylinux.check(versions)
 				if abi_tag      == 'auto':	abi_tag			= cpython  .check(symbols)
 
-			print('## Payload Files')
+			print(f'{L_EMPH}## Payload Files{L_RESET}')
 			print(*payload_files, sep='\n')
 			print()
 
 		if platform_tag	== 'auto':	platform_tag	= 'any'
 		if abi_tag		== 'auto':	abi_tag			= 'py3-none'
 
 		return payload_files, abi_tag, platform_tag
 
 	#---------------------------------------------------------------------------
-	def write_file(handle, f):
-		if isinstance(f, tuple):
-			if len(f) == 2:			src, dst, attr = f, None
-			else:					src, dst, attr = f
-		else:						src, dst, attr = f, f, None
-
-		if os.path.islink(src):
-			raise Exception(f'{f} is a symlink. Symlinks are not supported by PIP!')
-			#handle.writestr(f, os.readlink(f))
-			#info = handle.getinfo(f)
-			#info.external_attr |= (0xA1FF) << 16
-		else:
-			handle.write(src, arcname=dst)
-			if attr:
-				info = handle.getinfo(dst)
-				info.external_attr |= attr << 16
+	def find_links(data_path):
+		link_files = []
+		if 'links' in config:
+			links = config['links']
+			for src in links:
+				script = f"""#!python3
+# Generated by Illrian {illyrian.__version__}
+import site
+import os
+import subprocess
+import sys
+sitepackages = site.getsitepackages()
+if site.ENABLE_USER_SITE:
+	sitepackages += [site.getusersitepackages()]
+for path in sitepackages:
+	file = os.path.join(path, '{src}')
+	if os.path.exists(file):
+		exit(subprocess.run([file] + sys.argv[1:]).returncode)
+raise Exception('Unable to find {src}')
+"""
+				link_files.append(File(src, os.path.join(data_path, 'scripts', os.path.basename(src)), 0o777, script))
+
+			link_files.sort()
+
+			print(f'{L_EMPH}## Link Files{L_RESET}')
+			print(*link_files, sep='\n')
+			print()
+
+		return link_files
 
 	#---------------------------------------------------------------------------
 	data_path		= f'{distribution}-{version}.data'
 	dist_info		= f'{distribution}-{version}.dist-info'
 	python_files	= find_python()
 	script_files	= find_scripts(data_path)
+	header_files	= find_headers(dist_info)
+	link_files		= find_links(data_path)
 	payload_files, abi_tag, platform_tag = find_payload(abi_tag, platform_tag)
 
 	whl_file = f'{distribution}-{version}-{abi_tag}-{platform_tag}.whl'
 
 	if os.path.exists(whl_file):
 		os.remove(whl_file)
 
 	with zipfile.ZipFile(whl_file, mode='w', compression=zipfile.ZIP_DEFLATED) as handle:
-		for f in python_files:	write_file(handle, f)
-		for f in payload_files:	write_file(handle, f)
-		for f in script_files:	write_file(handle, f)
-
-		metadata_file	= os.path.join(dist_info, 'METADATA')
-		toplist_file	= os.path.join(dist_info, 'top_list.txt')
-		wheel_file		= os.path.join(dist_info, 'WHEEL')
-		record_file		= os.path.join(dist_info, 'RECORD')
-
-		metadata	= generate_meta_data()
-		wheel_		= generate_wheel()
-		toplist		= generate_top_list()
+		for f in python_files:	f.write(handle)
+		for f in payload_files:	f.write(handle)
+		for f in script_files:	f.write(handle)
+		for f in header_files:	f.write(handle)
+		for f in link_files:	f.write(handle)
+
+		metadata	= generate_meta_data(dist_info)
+		wheel_		= generate_wheel	(dist_info)
+		toplist		= generate_top_list	(dist_info)
 		record		= generate_record(
-			[python_files, payload_files, script_files],
-			[
-				(metadata_file,	metadata),
-				(toplist_file,	toplist),
-				(wheel_file,	wheel_),
-				(record_file,	None)
-			]
+			python_files + 
+			payload_files + 
+			script_files + 
+			header_files + 
+			link_files +
+			[metadata, toplist, wheel_]
 		)
 
-		handle.writestr(metadata_file, 	metadata)
-		handle.writestr(toplist_file,	toplist)
-		handle.writestr(wheel_file,		wheel_)
-		handle.writestr(record_file,	record)
+		metadata.write(handle)
+		wheel_.write(handle)
+		toplist.write(handle)
+		record.write(handle)
 
 	print(f'Generated: {whl_file}')
+	print()
```

## illyrian/cmake/illyrian.cmake

```diff
@@ -53,15 +53,15 @@
 	UNSET(ILLYRIAN_ARGS_CXX_STANDARD)
 	UNSET(ILLYRIAN_ARGS_INSTALL_PREFIX)
 	UNSET(ILLYRIAN_ARGS_SUPPORTED_OS)
 ENDMACRO()
 
 FUNCTION(ILLYRIAN_INSTALL_PYTHON_PACKAGE)
 	ILLYRIAN_FIND_PYTHON()
-	EXECUTE_PROCESS(COMMAND ${Python3_EXECUTABLE} -m pip install ${ARGN} RESULT_VARIABLE RES)
+	EXECUTE_PROCESS(COMMAND ${Python3_EXECUTABLE} -m pip install ${ARGN} RESULT_VARIABLE RES COMMAND_ERROR_IS_FATAL ANY)
 	IF(NOT RES EQUAL 0)
 		MESSAGE(SEND_ERROR "Failed to run PIP install ${ARGN}")
 	ENDIF()
 ENDFUNCTION()
 
 MACRO(ILLYRIAN_FIND_PYTHON)
 	IF(ILLYRIAN_NO_PYTHON)
@@ -90,35 +90,44 @@
 
 		FIND_PACKAGE(Python3 ${ILLYRIAN_ARGS_VERSION} ${ILLYRIAN_ARGS_EXACT} REQUIRED)
 		
 		SET(Python3_EXECUTABLE ${Python3_EXECUTABLE} CACHE STRING "")
 		SET(Python3_VERSION_MAJOR ${Python3_VERSION_MAJOR} CACHE STRING "")
 		SET(Python3_VERSION_MINOR ${Python3_VERSION_MINOR} CACHE STRING "")
 		SET(Python3_SITELIB ${Python3_SITELIB} CACHE STRING "")
-		SET(Python3_USERLIB "$ENV{HOME}/.local/lib/python${Python3_VERSION_MAJOR}.${Python3_VERSION_MINOR}/site-packages" CACHE STRING "")
+		EXECUTE_PROCESS(COMMAND ${Python3_EXECUTABLE} -m site --user-site OUTPUT_VARIABLE Python3_USERLIB COMMAND_ERROR_IS_FATAL ANY OUTPUT_STRIP_TRAILING_WHITESPACE)
+		SET(Python3_USERLIB "${Python3_USERLIB}" CACHE STRING "")
 
 		UNSET(ILLYRIAN_ARGS_EXACT)
 		UNSET(ILLYRIAN_ARGS_VERSION)
 	ENDIF()
 
 	MARK_AS_ADVANCED(Python3_EXECUTABLE Python3_VERSION_MAJOR Python3_VERSION_MINOR Python3_SITELIB Python3_USERLIB)
 ENDMACRO()
 
 MACRO(ILLYRIAN_FIND_PACKAGE NAME)
 	CMAKE_PARSE_ARGUMENTS(ILLYRIAN_ARGS
-		"REQUIRED"
+		"REQUIRED;EXACT"
 		"VERSION"
 		"PATHS;PYTHON"
 		"${ARGN}"
 	)
 
 	SET(ILLYRIAN_ARGS_CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH})
 
 	IF(ILLYRIAN_ARGS_REQUIRED)
 		SET(ILLYRIAN_ARGS_REQUIRED REQUIRED)
+	ELSE()
+		SET(ILLYRIAN_ARGS_REQUIRED "")
+	ENDIF()
+
+	IF(ILLYRIAN_ARGS_EXACT)
+		SET(ILLYRIAN_ARGS_EXACT EXACT)
+	ELSE()
+		SET(ILLYRIAN_ARGS_EXACT "")
 	ENDIF()
 
 	IF(ILLYRIAN_ARGS_PATHS)
 		FOREACH(PATH ${ILLYRIAN_ARGS_PATHS})
 			SET(CMAKE_MODULE_PATH "${CMAKE_MODULE_PATH};${PATH}")
 		ENDFOREACH()
 	ENDIF()
@@ -126,31 +135,63 @@
 	IF(ILLYRIAN_ARGS_PYTHON)
 		ILLYRIAN_FIND_PYTHON()
 		FOREACH(PATH ${ILLYRIAN_ARGS_PYTHON})
 			SET(CMAKE_MODULE_PATH "${CMAKE_MODULE_PATH};${Python3_SITELIB}/${PATH};${Python3_USERLIB}/${PATH}")
 		ENDFOREACH()
 	ENDIF()
 
-	FIND_PACKAGE(${NAME} ${ILLYRIAN_ARGS_VERSION} ${ILLYRIAN_ARGS_REQUIRED})
+	FIND_PACKAGE(${NAME} ${ILLYRIAN_ARGS_VERSION} ${ILLYRIAN_ARGS_EXACT} ${ILLYRIAN_ARGS_REQUIRED})
 
 	IF(${NAME}_VERSION)
 		IF(ILLYRIAN_ARGS_VERSION)
 			SET(${NAME}_VERSION_MIN ${ILLYRIAN_ARGS_VERSION})
 		ELSE()
 			SET(${NAME}_VERSION_MIN ${${NAME}_VERSION})
 		ENDIF()
+		
+		STRING(REPLACE "." ";" ILLYRIAN_VERSION_LIST ${${NAME}_VERSION_MIN})
+		LIST(LENGTH ILLYRIAN_VERSION_LIST ILLYRIAN_VERSION_LEN)
+
+		IF(${ILLYRIAN_VERSION_LEN} GREATER 0)
+			LIST(GET ILLYRIAN_VERSION_LIST 0 ${NAME}_VERSION_MAJOR)
+			MATH(EXPR ${NAME}_VERSION_NEXT_MAJOR "${${NAME}_VERSION_MAJOR} + 1")
+		ELSE()
+			SET(${NAME}_VERSION_NEXT_MAJOR "0")
+		ENDIF()
 
-		STRING(REGEX MATCH "[0-9]+" ${NAME}_VERSION_MAX ${${NAME}_VERSION})
-		MATH(EXPR ${NAME}_VERSION_MAX "${${NAME}_VERSION_MAX} + 1")
+		IF(${ILLYRIAN_VERSION_LEN} GREATER 1)
+			LIST(GET ILLYRIAN_VERSION_LIST 1 ${NAME}_VERSION_MINOR)
+			MATH(EXPR ${NAME}_VERSION_NEXT_MINOR "${${NAME}_VERSION_MINOR} + 1")
+		ELSE()
+			SET(${NAME}_VERSION_NEXT_MINOR "0")
+		ENDIF()
+		SET(${NAME}_VERSION_NEXT_MINOR "${${NAME}_VERSION_MAJOR}.${${NAME}_VERSION_NEXT_MINOR}")
+
+		IF(${ILLYRIAN_VERSION_LEN} GREATER 2)
+			LIST(GET ILLYRIAN_VERSION_LIST 2 ${NAME}_VERSION_PATCH)
+			MATH(EXPR ${NAME}_VERSION_NEXT_PATCH "${${NAME}_VERSION_PATCH} + 1")
+		ELSE()
+			SET(${NAME}_VERSION_NEXT_PATCH "0")
+		ENDIF()
+		SET(${NAME}_VERSION_NEXT_PATCH "${${NAME}_VERSION_MAJOR}.${${NAME}_VERSION_MINOR}.${${NAME}_VERSION_NEXT_PATCH}")
+
+		IF(${ILLYRIAN_VERSION_LEN} GREATER 3)
+			LIST(GET ILLYRIAN_VERSION_LIST 3 ${NAME}_VERSION_TWEAK)
+			MATH(EXPR ${NAME}_VERSION_NEXT_TWEAK "${${NAME}_VERSION_TWEAK} + 1")
+		ELSE()
+			SET(${NAME}_VERSION_NEXT_TWEAK "0")
+		ENDIF()
+		SET(${NAME}_VERSION_NEXT_TWEAK "${${NAME}_VERSION_MAJOR}.${${NAME}_VERSION_MINOR}.${${NAME}_VERSION_PATCH}.${${NAME}_VERSION_NEXT_TWEAK}")
 	ENDIF()
 
 	# RESET MODULE PATH
 	SET(CMAKE_MODULE_PATH ${ILLYRIAN_ARGS_CMAKE_MODULE_PATH})
 	UNSET(ILLYRIAN_ARGS_CMAKE_MODULE_PATH)
 	UNSET(ILLYRIAN_ARGS_REQUIRED)
+	UNSET(ILLYRIAN_ARGS_EXACT)
 	UNSET(ILLYRIAN_ARGS_VERSION)
 	UNSET(ILLYRIAN_ARGS_PATHS)
 ENDMACRO()
 
 FUNCTION(ILLYRIAN_INSTALL_SYMLINK DST SRC)
 	CMAKE_PARSE_ARGUMENTS(ILLYRIAN_ARGS
 		"DIRECTORY;PYTHON"
@@ -166,15 +207,15 @@
 	IF(EXISTS ${SRC})
 		FILE(REMOVE ${SRC})
 	ENDIF()
 
 	IF(ILLYRIAN_ARGS_PYTHON)
 		FILE(WRITE ${SRC} "INPUT(${DST})")
 	ELSE()
-		EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} -E create_symlink ${DST} ${SRC})
+		EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} -E create_symlink ${DST} ${SRC} COMMAND_ERROR_IS_FATAL ANY)
 	ENDIF()
 	
 	IF(NOT ILLYRIAN_ARGS_DESTINATION)	
 		SET(ILLYRIAN_ARGS_DESTINATION ".")
 	ENDIF()
 
 	IF(ILLYRIAN_ARGS_DIRECTORY)
@@ -287,15 +328,15 @@
 	ADD_CUSTOM_TARGET(${TARGET_NAME}
 		COMMAND ${Python3_EXECUTABLE} -m illyrian ${CONFIGURED_JSON}
 		DEPENDS ${TARGET_NAME}-pre
 		WORKING_DIRECTORY ${CMAKE_INSTALL_PREFIX})
 
 	ADD_CUSTOM_TARGET(${TARGET_NAME}-install
 		COMMAND	${Python3_EXECUTABLE} -m pip uninstall ${NAME} -y
-		COMMAND ${Python3_EXECUTABLE} -m pip install -f . ${NAME}
+		COMMAND ${Python3_EXECUTABLE} -m pip install --no-cache-dir -f ${CMAKE_INSTALL_PREFIX} ${NAME}
 		DEPENDS ${TARGET_NAME}
 		WORKING_DIRECTORY ${CMAKE_INSTALL_PREFIX})
 ENDFUNCTION()
 
 FUNCTION(ILLYRIAN_INSTALL_FIND_WRITE MODE NAME)
 	CMAKE_PARSE_ARGUMENTS(ILLYRIAN_ARGS
 		"APPEND"
```

## Comparing `illyrian/LICENSE` & `illyrian-0.3.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `illyrian-0.2.2.dist-info/METADATA` & `illyrian-0.3.0.dist-info/METADATA`

 * *Files 9% similar despite different names*

```diff
@@ -1,35 +1,54 @@
 Metadata-Version: 2.1
 Name: illyrian
-Version: 0.2.2
+Version: 0.3.0
 Requires-Python: >=3.6
 Summary: Illyrian is CMake extension for easily creating Python packages.
 Author: Nicolas Weber
 Author-email: nicolas.weber@neclab.eu
 Classifier: License :: OSI Approved :: BSD License
 Classifier: Programming Language :: Python :: 3 :: Only
 Download-URL: https://github.com/nec-research/illyrian/tags
 License: 3 BSD-License
 Platform: linux_x86_x64
 Requires-Dist: auditwheel
 Requires-Dist: importlib-resources; python_version < "3.7"
+Requires-Dist: pydot
 Description-Content-Type: text/markdown
 
 # Illyrian
 
 Illyrian is CMake extension for easily creating Python packages. The drawback of
 setuptools is that it is supposed to be encapsulate CMake. However, if your
 CMake produces multiple Python libraries, you would need to split your CMake
 project. With Illyrian you don't need to do it! With Illyrian CMake encapsulates
 the Python Wheel build process!
 
+[![Github](https://img.shields.io/github/v/tag/nec-research/illyrian?display_name=tag&sort=semver)](https://github.com/sx-aurora/veda)
+[![PyPI](https://img.shields.io/pypi/v/illyrian)](https://pypi.org/project/illyrian)
+[![License](https://img.shields.io/pypi/l/illyrian)](https://pypi.org/project/illyrian)
+![Python Versions](https://img.shields.io/pypi/pyversions/illyrian)
+![Linux](https://svgshare.com/i/Zhy.svg)
+![Maintenance](https://img.shields.io/badge/Maintained%3F-yes-green.svg)
+![Maintenance](https://img.shields.io/pypi/dm/illyrian)
+
 ## Release Notes
 <table>
 <tr><th>Version</th><th>Comment</th></tr>
 
+<tr><td>v0.3.0</td><td>
+<ul>
+<li>Improved error handling within CMake extension</li>
+<li>Added version number format checking</li>
+<li>Increased CMake min version to 3.19</li>
+<li>Added support to run multiple files at once: <code>illyrian A.json B.json C.json</code></li>
+<li>Fixed hashing for dist-info/RECORD</code></li>
+</ul>
+</td></tr>
+
 <tr><td>v0.2.2</td><td>
 <ul>
 <li>Added option to fetch name + email from <code>git</code> using '__GIT__' value</li>
 <li>Fixed bug where Illyrian deleted all WHL in the target folder</li>
 <li>Added Python 3.6 compatibility</li>
 </ul>
 </td></tr>
@@ -44,14 +63,16 @@
 <ul>
 <li><b>**BREAKING CHANGE**</b> Changed optional syntax to allow conditionals such as <code>/some/path/pattern*.* ? >= 5 && <7</code></li>
 <li>Illyrian now automatically determines your Manylinux and CPython compatibility if you don't explicitly set it via <code>abi-tag</code> and <code>platform-tag</code>.</li>
 <li>Added <code>EXACT</code> keyword to <code>ILLYRIAN_FIND_PYTHON</code></li>
 <li>Fixed generation of <code>RECORD</code> file when package contains script files</li>
 <li>Generated FindScripts now recheck if the version number gets increased</li>
 <li>Added <code>ILLYRIAN_PYTHON_VERSION</code> env var to override default version for <code>ILLYRIAN_FIND_PYTHON</code>.</li>
+<li>Added <code>license-file</code> option.</li>
+<li>Added <code>links</code> option, that allows to add links to executables.</li>
 </ul>
 </td></tr>
 
 <tr><td>v0.1.4</td><td>
 <ul>
 <li>Removed <code>-Wl,--no-as-needed</code> from <code>ILLYRIAN_TARGET_FLAGS</code>.</li>
 <li>Fixed uninitialized var in <code>ILLYRIAN_TARGET_FLAGS</code></li>
@@ -215,36 +236,39 @@
 ## Illyrian Config File
 
 The Illyrian config file is a plain JSON file that supports the following fields. See https://peps.python.org/pep-0345/ for explanation of the fields.
 
 | Fields | Type | Comment |
 | --- | --- | --- |
 | ```__include__``` | str/list | Allows to include other config JSON files. If a key exists in both, the value will be casted to a list and get appended. |
+| abi-tag | str | default: auto |
 | author | str | |
 | author-email | str | |
 | classifier | str/list | |
 | download-url | str | |
 | homepage | str | |
 | keywords | str | |
 | license | str | |
+| license-file | str | Will be stored in package-name.dist/LICENSE |
+| links | list | Creates global links to executables. |
 | maintainer | str  | |
 | maintainer-email | str | | 
 | name | str | required |
 | obsoletes-dist | str/list | |
 | platform | str/list | |
+| platform-tag | str | default: auto |
 | project-url | str/list | |
 | provides-dist | str/list | |
+| provides-extra | str/list | |
 | readme | ```path/to/readme.md``` | Expects the path to a Markdown file. The file DOES NOT get stored within the wheel. Use ```payload``` for that. |
 | requires-dist | str/list | |
 | requires-external | str/list | |
 | requires-python | ```>= 3.X``` | required |
 | summary | str | required |
 | supported-platform | str/list | |
-| abi-tag | str | default: auto |
-| platform-tag | str | default: auto |
 | version | ```[0-9\.]+``` | required |
 
 Additionally there the ```packages``` key expects a list of paths to python
 packages, i.e. ```"packages": ["bla", "bla/sub"]```. ALL subpackages need to be
 manually specified AND only ```*.py``` files will be includes.
 
 The ```payload``` key expects a list of paths. Here you can use GLOB syntax
@@ -274,8 +298,14 @@
 		"illyrian/LICENSE",
 		"illyrian/cmake/*.cmake"
 	],
 	"scripts": [
 		"scripts/illyrian"
 	]
 }
-```
+```
+
+## Illyrian Debug Features
+If you want to investigate the meta data of a WHL file, just run `illyrian
+file.whl`. Illyrian will extract all available metadata (.dist-info/METADATA,
+WHEEL and RECORD) and evaluate also the correctness of the entries within the
+RECORD file.
```

### html2text {}

```diff
@@ -1,37 +1,53 @@
-Metadata-Version: 2.1 Name: illyrian Version: 0.2.2 Requires-Python: >=3.6
+Metadata-Version: 2.1 Name: illyrian Version: 0.3.0 Requires-Python: >=3.6
 Summary: Illyrian is CMake extension for easily creating Python packages.
 Author: Nicolas Weber Author-email: nicolas.weber@neclab.eu Classifier: License
 :: OSI Approved :: BSD License Classifier: Programming Language :: Python :: 3
 :: Only Download-URL: https://github.com/nec-research/illyrian/tags License: 3
 BSD-License Platform: linux_x86_x64 Requires-Dist: auditwheel Requires-Dist:
-importlib-resources; python_version < "3.7" Description-Content-Type: text/
-markdown # Illyrian Illyrian is CMake extension for easily creating Python
-packages. The drawback of setuptools is that it is supposed to be encapsulate
-CMake. However, if your CMake produces multiple Python libraries, you would
-need to split your CMake project. With Illyrian you don't need to do it! With
-Illyrian CMake encapsulates the Python Wheel build process! ## Release Notes
+importlib-resources; python_version < "3.7" Requires-Dist: pydot Description-
+Content-Type: text/markdown # Illyrian Illyrian is CMake extension for easily
+creating Python packages. The drawback of setuptools is that it is supposed to
+be encapsulate CMake. However, if your CMake produces multiple Python
+libraries, you would need to split your CMake project. With Illyrian you don't
+need to do it! With Illyrian CMake encapsulates the Python Wheel build process!
+[![Github](https://img.shields.io/github/v/tag/nec-research/
+illyrian?display_name=tag&sort=semver)](https://github.com/sx-aurora/veda) [!
+[PyPI](https://img.shields.io/pypi/v/illyrian)](https://pypi.org/project/
+illyrian) [![License](https://img.shields.io/pypi/l/illyrian)](https://
+pypi.org/project/illyrian) ![Python Versions](https://img.shields.io/pypi/
+pyversions/illyrian) ![Linux](https://svgshare.com/i/Zhy.svg) ![Maintenance]
+(https://img.shields.io/badge/Maintained%3F-yes-green.svg) ![Maintenance]
+(https://img.shields.io/pypi/dm/illyrian) ## Release Notes
 Version Comment
+            * Improved error handling within CMake extension
+            * Added version number format checking
+v0.3.0      * Increased CMake min version to 3.19
+            * Added support to run multiple files at once: illyrian A.json
+              B.json C.json
+            * Fixed hashing for dist-info/RECORD
             * Added option to fetch name + email from git using '__GIT__' value
 v0.2.2      * Fixed bug where Illyrian deleted all WHL in the target folder
             * Added Python 3.6 compatibility
 v0.2.1      * Added ILLYRIAN_NO_PYTHON option to CMake for non-python builds
               that use Illyrian
             * **BREAKING CHANGE** Changed optional syntax to allow conditionals
               such as /some/path/pattern*.* ? >= 5 && <7
             * Illyrian now automatically determines your Manylinux and CPython
               compatibility if you don't explicitly set it via abi-tag and
               platform-tag.
-v0.2.0      * Added EXACT keyword to ILLYRIAN_FIND_PYTHON
-            * Fixed generation of RECORD file when package contains script
+            * Added EXACT keyword to ILLYRIAN_FIND_PYTHON
+v0.2.0      * Fixed generation of RECORD file when package contains script
               files
             * Generated FindScripts now recheck if the version number gets
               increased
             * Added ILLYRIAN_PYTHON_VERSION env var to override default version
               for ILLYRIAN_FIND_PYTHON.
+            * Added license-file option.
+            * Added links option, that allows to add links to executables.
 v0.1.4      * Removed -Wl,--no-as-needed from ILLYRIAN_TARGET_FLAGS.
             * Fixed uninitialized var in ILLYRIAN_TARGET_FLAGS
 v0.1.3  Split "tag" into "abi-tag" and "platform-tag" as described in PEP491.
 v0.1.2  Improved Illyrian command argument parsing.
 v0.1.1  Added EXACT to ILLYRIAN_FIND_PYTHON
 v0.1.0  Initial Release
 ## How to build? ```base git clone ... cmake3 -S illyrian -B illyrian/build #
@@ -112,25 +128,27 @@
 ```PATHS``` and stores the PATH or FILE in ```VAR```. --- ## Manually running
 Illyrian You can use Illyrian also without CMake. For this just run ```illyrian
 your_config.json``` in the root folder of your project. --- ## Illyrian Config
 File The Illyrian config file is a plain JSON file that supports the following
 fields. See https://peps.python.org/pep-0345/ for explanation of the fields. |
 Fields | Type | Comment | | --- | --- | --- | | ```__include__``` | str/list |
 Allows to include other config JSON files. If a key exists in both, the value
-will be casted to a list and get appended. | | author | str | | | author-email
-| str | | | classifier | str/list | | | download-url | str | | | homepage | str
-| | | keywords | str | | | license | str | | | maintainer | str | | |
+will be casted to a list and get appended. | | abi-tag | str | default: auto |
+| author | str | | | author-email | str | | | classifier | str/list | | |
+download-url | str | | | homepage | str | | | keywords | str | | | license |
+str | | | license-file | str | Will be stored in package-name.dist/LICENSE | |
+links | list | Creates global links to executables. | | maintainer | str | | |
 maintainer-email | str | | | name | str | required | | obsoletes-dist | str/
-list | | | platform | str/list | | | project-url | str/list | | | provides-dist
-| str/list | | | readme | ```path/to/readme.md``` | Expects the path to a
+list | | | platform | str/list | | | platform-tag | str | default: auto | |
+project-url | str/list | | | provides-dist | str/list | | | provides-extra |
+str/list | | | readme | ```path/to/readme.md``` | Expects the path to a
 Markdown file. The file DOES NOT get stored within the wheel. Use ```payload```
 for that. | | requires-dist | str/list | | | requires-external | str/list | | |
 requires-python | ```>= 3.X``` | required | | summary | str | required | |
-supported-platform | str/list | | | abi-tag | str | default: auto | | platform-
-tag | str | default: auto | | version | ```[0-9\.]+``` | required |
+supported-platform | str/list | | | version | ```[0-9\.]+``` | required |
 Additionally there the ```packages``` key expects a list of paths to python
 packages, i.e. ```"packages": ["bla", "bla/sub"]```. ALL subpackages need to be
 manually specified AND only ```*.py``` files will be includes. The
 ```payload``` key expects a list of paths. Here you can use GLOB syntax
 ```path/to/*.h``` or use ```**``` for recursive inclusion, i.e., ```path/to/
 **```. ```packages``` and ```payload``` fail if no files are found in the
 specified path. This can be overwritten by adding an ```?``` with a condition
@@ -138,8 +156,12 @@
 path/* ? == 5```. You can chain multiple and-conditions using ```&&```. Here an
 example: ```json { "name": "illyrian", "version": "@Illyrian_VERSION@",
 "platform": "linux_x86_x64", "summary": "Illyrian is CMake extension for easily
 creating Python packages.", "readme": "illyrian/README.md", "author": "User
 Name
 name@company.com>", "license": "3 BSD-License", "requires-python": ">=3.7",
 "packages": [ "illyrian" ], "payload": [ "illyrian/LICENSE", "illyrian/cmake/
-*.cmake" ], "scripts": [ "scripts/illyrian" ] } ```
+*.cmake" ], "scripts": [ "scripts/illyrian" ] } ``` ## Illyrian Debug Features
+If you want to investigate the meta data of a WHL file, just run `illyrian
+file.whl`. Illyrian will extract all available metadata (.dist-info/METADATA,
+WHEEL and RECORD) and evaluate also the correctness of the entries within the
+RECORD file.
```

