# Comparing `tmp/pawnlib-0.1.9-py3-none-any.whl.zip` & `tmp/pawnlib-0.2.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,46 +1,50 @@
-Zip file size: 78811 bytes, number of entries: 44
+Zip file size: 108324 bytes, number of entries: 48
 -rw-r--r--  2.0 unx     1188 b- defN 23-Jan-31 08:49 pawnlib/__init__.py
 -rw-r--r--  2.0 unx     1224 b- defN 23-Jan-31 08:49 pawnlib/__main__.py
--rw-r--r--  2.0 unx      292 b- defN 23-Feb-08 03:20 pawnlib/__version__.py
+-rw-r--r--  2.0 unx      296 b- defN 23-Apr-28 03:08 pawnlib/__version__.py
 -rw-r--r--  2.0 unx       19 b- defN 22-Jul-21 06:00 pawnlib/asyncio/__init__.py
--rw-r--r--  2.0 unx     2952 b- defN 23-Jan-31 06:38 pawnlib/asyncio/run.py
+-rw-r--r--  2.0 unx     4261 b- defN 23-Feb-22 08:29 pawnlib/asyncio/run.py
 -rw-r--r--  2.0 unx       36 b- defN 22-Jul-28 01:54 pawnlib/builder/__init__.py
 -rw-r--r--  2.0 unx     5382 b- defN 23-Jan-31 06:30 pawnlib/builder/generator.py
 -rw-r--r--  2.0 unx        0 b- defN 22-Jul-28 04:35 pawnlib/builder/templates/__init__.py
--rw-r--r--  2.0 unx     2195 b- defN 22-Dec-01 01:31 pawnlib/builder/templates/app_with_logging.tmpl
+-rw-r--r--  2.0 unx     2343 b- defN 23-Feb-16 09:40 pawnlib/builder/templates/app_with_logging.tmpl
 -rw-r--r--  2.0 unx        0 b- defN 22-Jul-28 04:34 pawnlib/cli/__init__.py
 -rw-r--r--  2.0 unx     1328 b- defN 23-Jan-31 04:22 pawnlib/cli/aws.py
--rw-r--r--  2.0 unx     2904 b- defN 23-Jan-31 03:32 pawnlib/cli/icon.py
+-rw-r--r--  2.0 unx     9975 b- defN 23-Apr-18 05:35 pawnlib/cli/http.py
+-rw-r--r--  2.0 unx     2910 b- defN 23-Apr-18 05:35 pawnlib/cli/icon.py
 -rw-r--r--  2.0 unx     1305 b- defN 22-Sep-22 06:43 pawnlib/cli/init.py
--rw-r--r--  2.0 unx     4079 b- defN 23-Jan-31 03:33 pawnlib/cli/main_cli.py
+-rw-r--r--  2.0 unx     5242 b- defN 23-Apr-18 05:35 pawnlib/cli/main_cli.py
 -rw-r--r--  2.0 unx     6605 b- defN 23-Jan-31 06:39 pawnlib/cli/proxy.py
+-rw-r--r--  2.0 unx     3269 b- defN 23-Apr-27 06:14 pawnlib/cli/wallet.py
 -rw-r--r--  2.0 unx     1380 b- defN 22-Aug-29 07:53 pawnlib/config/__fix_import.py
--rw-r--r--  2.0 unx      108 b- defN 22-Dec-01 03:13 pawnlib/config/__init__.py
+-rw-r--r--  2.0 unx      121 b- defN 23-Feb-27 02:19 pawnlib/config/__init__.py
 -rw-r--r--  2.0 unx     4523 b- defN 22-Oct-21 09:48 pawnlib/config/configure.py
 -rw-r--r--  2.0 unx     4165 b- defN 23-Jan-31 05:50 pawnlib/config/console.py
--rw-r--r--  2.0 unx    26200 b- defN 23-Jan-31 06:36 pawnlib/config/globalconfig.py
--rw-r--r--  2.0 unx      545 b- defN 22-Nov-24 02:27 pawnlib/output/__init__.py
--rw-r--r--  2.0 unx    20445 b- defN 23-Jan-31 09:09 pawnlib/output/color_print.py
+-rw-r--r--  2.0 unx    29830 b- defN 23-Apr-27 13:15 pawnlib/config/globalconfig.py
+-rw-r--r--  2.0 unx      432 b- defN 23-Apr-18 05:35 pawnlib/input/__init__.py
+-rw-r--r--  2.0 unx    21792 b- defN 23-Apr-19 03:05 pawnlib/input/prompt.py
+-rw-r--r--  2.0 unx      650 b- defN 23-Apr-19 01:22 pawnlib/output/__init__.py
+-rw-r--r--  2.0 unx    37342 b- defN 23-Apr-28 03:07 pawnlib/output/color_print.py
 -rw-r--r--  2.0 unx     6198 b- defN 23-Jan-31 06:29 pawnlib/output/file.py
--rw-r--r--  2.0 unx      288 b- defN 22-Sep-13 06:52 pawnlib/resource/__init__.py
+-rw-r--r--  2.0 unx      445 b- defN 23-Feb-17 09:14 pawnlib/resource/__init__.py
 -rw-r--r--  2.0 unx     6568 b- defN 23-Jan-31 04:59 pawnlib/resource/net.py
 -rw-r--r--  2.0 unx    11387 b- defN 22-Nov-22 01:36 pawnlib/resource/server.py
--rw-r--r--  2.0 unx     1653 b- defN 23-Jan-31 08:53 pawnlib/typing/__init__.py
--rw-r--r--  2.0 unx     4402 b- defN 23-Jan-31 09:06 pawnlib/typing/check.py
--rw-r--r--  2.0 unx      689 b- defN 23-Jan-31 06:03 pawnlib/typing/constants.py
--rw-r--r--  2.0 unx    54524 b- defN 23-Feb-08 03:20 pawnlib/typing/converter.py
+-rw-r--r--  2.0 unx     2022 b- defN 23-Apr-26 02:59 pawnlib/typing/__init__.py
+-rw-r--r--  2.0 unx     9094 b- defN 23-Apr-26 05:18 pawnlib/typing/check.py
+-rw-r--r--  2.0 unx      823 b- defN 23-Apr-18 05:35 pawnlib/typing/constants.py
+-rw-r--r--  2.0 unx    59328 b- defN 23-Apr-28 01:05 pawnlib/typing/converter.py
 -rw-r--r--  2.0 unx     7137 b- defN 23-Jan-31 09:13 pawnlib/typing/date_utils.py
--rw-r--r--  2.0 unx     1898 b- defN 22-Aug-17 08:57 pawnlib/typing/defines.py
+-rw-r--r--  2.0 unx     3365 b- defN 23-Apr-18 05:35 pawnlib/typing/defines.py
 -rw-r--r--  2.0 unx    12711 b- defN 23-Jan-31 06:35 pawnlib/typing/generator.py
--rw-r--r--  2.0 unx      349 b- defN 22-Dec-01 06:49 pawnlib/utils/__init__.py
--rw-r--r--  2.0 unx    12506 b- defN 23-Jan-31 02:59 pawnlib/utils/http.py
--rw-r--r--  2.0 unx    12365 b- defN 23-Jan-31 02:23 pawnlib/utils/icx_signer.py
+-rw-r--r--  2.0 unx      552 b- defN 23-Apr-18 05:35 pawnlib/utils/__init__.py
+-rw-r--r--  2.0 unx    48448 b- defN 23-Apr-28 03:06 pawnlib/utils/http.py
+-rw-r--r--  2.0 unx    25587 b- defN 23-Apr-28 03:07 pawnlib/utils/icx_signer.py
 -rw-r--r--  2.0 unx    12172 b- defN 23-Jan-31 05:22 pawnlib/utils/log.py
--rw-r--r--  2.0 unx     5929 b- defN 23-Jan-31 06:40 pawnlib/utils/notify.py
--rw-r--r--  2.0 unx    22138 b- defN 23-Jan-31 06:38 pawnlib/utils/operate_handler.py
--rw-r--r--  2.0 unx     5042 b- defN 23-Feb-08 03:22 pawnlib-0.1.9.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Feb-08 03:22 pawnlib-0.1.9.dist-info/WHEEL
--rw-r--r--  2.0 unx       52 b- defN 23-Feb-08 03:22 pawnlib-0.1.9.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        8 b- defN 23-Feb-08 03:22 pawnlib-0.1.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3601 b- defN 23-Feb-08 03:22 pawnlib-0.1.9.dist-info/RECORD
-44 files, 268584 bytes uncompressed, 73123 bytes compressed:  72.8%
+-rw-r--r--  2.0 unx     7014 b- defN 23-Apr-18 05:35 pawnlib/utils/notify.py
+-rw-r--r--  2.0 unx    23248 b- defN 23-Apr-18 05:35 pawnlib/utils/operate_handler.py
+-rw-r--r--  2.0 unx     5131 b- defN 23-Apr-28 03:09 pawnlib-0.2.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Apr-28 03:09 pawnlib-0.2.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       52 b- defN 23-Apr-28 03:09 pawnlib-0.2.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        8 b- defN 23-Apr-28 03:09 pawnlib-0.2.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3917 b- defN 23-Apr-28 03:09 pawnlib-0.2.0.dist-info/RECORD
+48 files, 390917 bytes uncompressed, 102156 bytes compressed:  73.9%
```

## zipnote {}

```diff
@@ -27,26 +27,32 @@
 
 Filename: pawnlib/cli/__init__.py
 Comment: 
 
 Filename: pawnlib/cli/aws.py
 Comment: 
 
+Filename: pawnlib/cli/http.py
+Comment: 
+
 Filename: pawnlib/cli/icon.py
 Comment: 
 
 Filename: pawnlib/cli/init.py
 Comment: 
 
 Filename: pawnlib/cli/main_cli.py
 Comment: 
 
 Filename: pawnlib/cli/proxy.py
 Comment: 
 
+Filename: pawnlib/cli/wallet.py
+Comment: 
+
 Filename: pawnlib/config/__fix_import.py
 Comment: 
 
 Filename: pawnlib/config/__init__.py
 Comment: 
 
 Filename: pawnlib/config/configure.py
@@ -54,14 +60,20 @@
 
 Filename: pawnlib/config/console.py
 Comment: 
 
 Filename: pawnlib/config/globalconfig.py
 Comment: 
 
+Filename: pawnlib/input/__init__.py
+Comment: 
+
+Filename: pawnlib/input/prompt.py
+Comment: 
+
 Filename: pawnlib/output/__init__.py
 Comment: 
 
 Filename: pawnlib/output/color_print.py
 Comment: 
 
 Filename: pawnlib/output/file.py
@@ -111,23 +123,23 @@
 
 Filename: pawnlib/utils/notify.py
 Comment: 
 
 Filename: pawnlib/utils/operate_handler.py
 Comment: 
 
-Filename: pawnlib-0.1.9.dist-info/METADATA
+Filename: pawnlib-0.2.0.dist-info/METADATA
 Comment: 
 
-Filename: pawnlib-0.1.9.dist-info/WHEEL
+Filename: pawnlib-0.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: pawnlib-0.1.9.dist-info/entry_points.txt
+Filename: pawnlib-0.2.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: pawnlib-0.1.9.dist-info/top_level.txt
+Filename: pawnlib-0.2.0.dist-info/top_level.txt
 Comment: 
 
-Filename: pawnlib-0.1.9.dist-info/RECORD
+Filename: pawnlib-0.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pawnlib/__version__.py

```diff
@@ -1,9 +1,9 @@
 ####
 __title__ = 'pawnlib'
 __description__ = 'pawnlib is a collection of libraries for IaC.'
 __url__ = 'https://github.com/jinwoo-j/pawnlib'
-__version__ = '0.1.9'
+__version__ = '0.2.0'
 __author__ = 'Jinwoo Jeong'
-__author_email__ = 'jinwoo@iconloop.com'
+__author_email__ = 'jinwoo@parametacorp.com'
 __license__ = 'MIT'
 __copyright__ = 'Copyright 2022 JINWOO'
```

## pawnlib/asyncio/run.py

```diff
@@ -1,20 +1,30 @@
 from functools import wraps, partial
 import asyncio
 import aiometer
-from pawnlib.output import debug_print
+from aiometer._impl import utils
+from pawnlib.output import debug_print, classdump
+from pawnlib.config import pawnlib_config as pawn
 
 
 class AsyncTasks:
-    def __init__(self, max_at_once: int = 10, max_per_second: int = 10, debug: bool = False, **kwargs):
+    def __init__(self,
+                 max_at_once: int = 10,
+                 max_per_second: int = 10,
+                 title="Working on async tasks ...",
+                 debug: bool = False,
+                 status: bool = False,
+                 **kwargs):
         """
         This Class is to run asyncio using aiometer.
 
         :param max_at_once: Limit maximum number of concurrently running tasks.
         :param max_per_second: Limit request rate to not overload the server.
+        :param title: Title of the tasks
+        :param status: Status of the tasks
         :param debug: Whether to use debug
         :param kwargs:
 
         Example:
 
             .. code-block:: python
 
@@ -33,24 +43,31 @@
         self.debug = debug
         self._debug_print(self)
 
         self.get_list_function = None
 
         self.async_partial_target_func = None
         self.async_partial_task_func = None
+        self.status_console = None
+
+        self._title = title
+        self._view_status = status
+        self._function_name = ""
 
     def generate_tasks(self, target_list=None, function=None, **kwargs):
         """
         This function generates the async tasks list
 
         :param target_list: List of targets for asynchronous execution
         :param function: Name of the function to execute
         :param kwargs:
         :return:
         """
+        if function and getattr(function, "__qualname__"):
+            self._function_name = function.__qualname__
 
         self._debug_print(f"{target_list}, {type(target_list)}")
         if kwargs.get('kwargs'):
             kwargs = kwargs['kwargs']
 
         if target_list is None:
             target_list = []
@@ -61,24 +78,43 @@
 
     def run(self):
         """
         This function executes an asynchronous operation.
 
         :return:
         """
-        return asyncio.run(self._runner())
 
-    async def _runner(self):
-        result = []
-        if len(self.tasks) > 0:
-            result = await aiometer.run_all(self.tasks, max_at_once=self.max_at_once, max_per_second=self.max_per_second)
+        if self._view_status:
+            with pawn.console.status(self._title) as status:
+                result = asyncio.run(self._runner(status))
         else:
-            print("ERROR: tasks is null")
+            result = asyncio.run(self._runner())
+
         return result
 
+    async def _runner(self, status=None):
+        result = {}
+        tasks_length = len(self.tasks)
+
+        if tasks_length > 0:
+            async with aiometer.amap(
+                    async_fn=lambda fn: fn(),
+                    args=self.tasks,
+                    max_at_once=self.max_at_once,
+                    max_per_second=self.max_per_second,
+                    _include_index=True,
+            ) as amap_results:
+                async for _index, _result in amap_results:
+                    result[_index] = _result
+                    if status and self._view_status:
+                        status.update(f"{self._title} <{self._function_name}> [{_index}/{tasks_length}] {_result}")
+        else:
+            print("ERROR: tasks is null")
+        return utils.list_from_indexed_dict(result)
+
     def _debug_print(self, *args, **kwargs):
         if self.debug:
             debug_print(*args, **kwargs)
 
 
 def async_partial(async_fn, *args, **kwargs):
     async def wrapped():
```

## pawnlib/builder/templates/app_with_logging.tmpl

```diff
@@ -1,11 +1,10 @@
 #!/usr/bin/env python3
 from pawnlib.config import pawnlib_config as pawn
-from pawnlib.utils.log import AppLogger
-from pawnlib.output import *
+from pawnlib.output import dump, get_script_path, debug_logging
 {% if use_daemon == true -%}
 import sys
 import time
 from pawnlib.utils.operate_handler import Daemon
 {% endif %}
 
 __version = "0.0.1"
@@ -16,34 +15,34 @@
     {%- for banner_string in banner %}
     print(f'{{banner_string}}')
     {%- endfor %}
 {%- endif %}
 
 
 def main():
-    APP_NAME = "{{ app_name }}"
+    app_name = "{{ app_name }}"
     log_time_format = '%Y-%m-%d %H:%M:%S.%f'
     current_path = get_script_path(__file__)
-    STDOUT = True
+    stdout = True
     pawn.set(
         PAWN_PATH=current_path,
         PAWN_LOGGER=dict(
             log_level="INFO",
             stdout_level="INFO",
             log_path=f"{current_path}/logs",
-            stdout=STDOUT,
+            stdout=stdout,
             use_hook_exception=True,
         ),
         PAWN_TIME_FORMAT=log_time_format,
         PAWN_CONSOLE=dict(
             redirect=True,
             record=True
         ),
         PAWN_DEBUG=True, # Don't use production, because it's not stored exception log.
-        app_name=APP_NAME,
+        app_name=app_name,
         data={}
     )
 
     pawn.app_logger.info("App logger initializing")
     pawn.error_logger.debug("Debug logger initializing")
     pawn.error_logger.error("Error logger initializing")
     pawn.console.log(pawn.to_dict())
@@ -80,8 +79,14 @@
         else:
             print("Command not found [start/stop]")
         {%- else %}
         main()
         {% endif %}
     except KeyboardInterrupt:
         pawn.console.log("Keyboard Interrupted")
+    except Exception as e:
+        pawn.console.print_exception(
+            show_locals=pawn.get("PAWN_DEBUG", False),
+            width=160
+        )
+
```

## pawnlib/cli/icon.py

```diff
@@ -3,31 +3,32 @@
 from pawnlib.builder.generator import generate_banner
 from pawnlib.__version__ import __version__ as _version
 from pawnlib.config import pawnlib_config as pawn
 
 icx = 0.001
 
 def get_parser():
-    parser = get_arguments()
+    parser = argparse.ArgumentParser(description='Command Line Interface for ICX')
+    parser = get_arguments(parser)
     return parser
 
 
 def get_arguments(parser=None):
-    parser = argparse.ArgumentParser(description='Command Line Interface for ICX')
+
     parser.add_argument(
         'command',
         help='account, icx_sendTransaction, icx_sendTransaction_v3, get_transactionResult, icx_getBalance, icx_getTotalSupply')
     parser.add_argument('--url', metavar='url', help=f'loopchain baseurl. default: None', default=None)
     parser.add_argument('--from', metavar='address', dest='from_addr', help=f'from address. default: None', default=None)
     parser.add_argument('--to', metavar='address', dest="to_addr", help=f'to address. default: None', default=None)
     parser.add_argument('--address', metavar='address', help=f'icx address. default: None', default=None)
     parser.add_argument('--txhash', metavar='txhash', help='txhash')
     parser.add_argument('--icx', metavar='amount', type=float, help=f'icx amount to transfer. unit: icx. ex) 1.0. default:{icx}', default=icx)
     parser.add_argument('--fee', metavar='amount', type=float, help='transfer fee. default: 0.01', default=0.001)
-    parser.add_argument('--pk', metavar='private_key', help=f'hexa string. default: None', default=None)
+    parser.add_argument('--pk', metavar='private_key', help=f'hex string. default: None', default=None)
     parser.add_argument('--debug', action='store_true', help=f'debug mode. True/False')
     parser.add_argument('-n', '--number', metavar='number', type=int, help=f'try number. default: 1', default=1)
     parser.add_argument('--nid', metavar='nid', type=str, help=f'network id default: 0x1', default="0x1")
     parser.add_argument('-c', '--config', metavar='config', help=f'config name')
     parser.add_argument('-k', '--keystore-name', metavar='key_store', help=f'keystore file name')
     parser.add_argument('-p', '--password', metavar='password', help=f'keystore file password')
     parser.add_argument('-t', '--timeout', metavar='timeout', type=float, help=f'timeout')
```

## pawnlib/cli/main_cli.py

```diff
@@ -94,33 +94,67 @@
         parser.parse_args(argv, namespace=n)
     return args, command
 
 
 def get_args():
     parser = argparse.ArgumentParser(
         usage=generate_banner(app_name="PAWNS", version=_version, author="jinwoo", font="graffiti"),
-        formatter_class=argparse.RawTextHelpFormatter)
+        formatter_class=argparse.RawTextHelpFormatter
+    )
 
     commands = parser.add_subparsers(title='sub-module')
     for module_name in get_submodule_names():
         _parser = commands.add_parser(module_name, help=f'{module_name} module')
         module = importlib.import_module(f"pawnlib.cli.{module_name}")
         module.get_arguments(_parser)
 
     args, command = parse_args(parser, commands)
     return args, command, parser
 
 
+# def main():
+#     pawn.console.log(f"main_cli wrapper")
+#     args, command, parser = get_args()
+#     pawn.console.log(f"args = {args}, command = {command}")
+#     if command:
+#         run_with_keyboard_interrupt(run_module, command)
+#     else:
+#         parser.print_help()
+#         sys.exit(1)
+
+def cleanup_args():
+    if len(sys.argv) > 2:
+        if "-" not in sys.argv[2]:
+            pawn.console.debug(f"Remove argument -> {sys.argv[1]}")
+            del sys.argv[1]
+
 def main():
-    pawn.console.log(f"main_cli wrapper")
-    args, command, parser = get_args()
-    pawn.console.log(f"args = {args}, command = {command}")
+    pawn.console.debug("Starting main_cli wrapper")
+    args, command, parser = None, None, None
+    try:
+        args, command, parser = get_args()
+        cleanup_args()
+    except Exception as e:
+        pawn.console.log(f"[red]Exception while parsing an argument = {e}")
+    pawn.console.debug(f"{args}, {command}, {parser}")
+
     if command:
-        run_with_keyboard_interrupt(run_module, command)
+        pawn.console.debug(f"command = {command}, PAWN_DEBUG={pawn.get('PAWN_DEBUG')}")
+        try:
+            # run_with_keyboard_interrupt(run_module, command)
+            run_module(command)
+        except KeyboardInterrupt:
+            pawn.console.log("[red]KeyboardInterrupt")
+        except Exception as e:
+            if pawn.get('PAWN_DEBUG'):
+                pawn.console.print_exception(show_locals=pawn.get("PAWN_DEBUG", False), width=160)
+            else:
+                pawn.console.log(f"[red]Exception -- {e}")
     else:
         parser.print_help()
         sys.exit(1)
 
 
 if __name__ == '__main__':
     run_with_keyboard_interrupt(main)
+    # main()
```

## pawnlib/config/__init__.py

```diff
@@ -1,2 +1,2 @@
-from .globalconfig import nestednamedtuple, PawnlibConfig, pawnlib_config, global_verbose, NestedNamespace
+from .globalconfig import nestednamedtuple, PawnlibConfig, pawnlib_config, global_verbose, NestedNamespace, pawn, pconf
```

## pawnlib/config/globalconfig.py

```diff
@@ -10,14 +10,17 @@
 from pawnlib.__version__ import __title__, __version__
 from pawnlib.config.__fix_import import Null
 from pawnlib.config.console import Console
 from collections import OrderedDict
 from rich.traceback import install as rich_traceback_install
 import copy
 from types import SimpleNamespace
+from functools import partial
+import collections
+import re
 
 
 class NestedNamespace(SimpleNamespace):
     @staticmethod
     def _______map_____entry(entry):
         if isinstance(entry, dict):
             return NestedNamespace(**entry)
@@ -34,16 +37,67 @@
 
     def _keys(self) -> list:
         return list(self.__dict__.keys())
 
     def _values(self) -> list:
         return list(self.__dict__.values())
 
+    # def as_dict(self) -> dict:
+    #     return self.__dict__
 
-def nestednamedtuple(dict_items: dict) -> namedtuple:
+    def as_dict(self) -> dict:
+        return self._namespace_to_dict(self.__dict__)
+
+    def _namespace_to_dict(self, _dict):
+        dict2 = {}
+        for k in _dict.keys():
+            if isinstance(_dict[k], dict) or isinstance(_dict[k], NestedNamespace):
+                dict2[k] = self._namespace_to_dict(_dict[k]._asdict())
+            else:
+                dict2[k] = _dict[k]
+        return dict2
+
+    def _asdict(self) -> dict:
+        return self.__dict__
+
+    # def __repr__(self):
+    #     'Return a nicely formatted representation string'
+    #     field_names = tuple(self.as_dict().keys())
+    #     field_values = tuple(self.as_dict().values())
+    #     indent = "\n    "
+    #     # indent = ""
+    #     repr_fmt = '(' + ', '.join(f'{indent}{name}=%r' for name in field_names) + f'{indent})'
+    #     return self.__class__.__name__ + repr_fmt % field_values
+
+    def __repr__(self, indent=4):
+        result = self.__class__.__name__ + '('
+        items_len = len(self.__dict__)
+        _first = 0
+        _indent_space = ''
+
+        for k, v in self.__dict__.items():
+            if _first == 0 and items_len > 0:
+                result += "\n"
+                _first = 1
+            if k.startswith('__'):
+                continue
+            if isinstance(v, NestedNamespace):
+                value_str = v.__repr__(indent + 4)
+            else:
+                value_str = str(v)
+
+            if k and value_str:
+                if _first:
+                    _indent_space = ' ' * indent
+                result += _indent_space + k + '=' + value_str + ",\n"
+        result += ' ' * (len(_indent_space) - 4) + f')'
+        return result
+
+
+def nestednamedtuple(dict_items: dict, ignore_keys: list = []) -> namedtuple:
     """
     Converts dictionary to a nested namedtuple recursively.
 
 
     :param: dictionary: Dictionary to convert into a nested namedtuple.
 
     :example:
@@ -52,25 +106,28 @@
 
             from pawnlib.config.globalconfig import nestednamedtuple
             nt = nestednamedtuple({"hello": {"ola": "mundo"}})
             print(nt) # >>> namedtupled(hello=namedtupled(ola='mundo'))
 
     """
     dictionary = copy.copy(dict_items)
-
     if isinstance(dictionary, Mapping) and not isinstance(dictionary, fdict):
         # for ignore_type in ["configparser.SectionProxy", "configparser.ConfigParser"]:
         for ignore_type in ["configparser.ConfigParser"]:
             if ignore_type in str(type(dictionary)):
                 for key, value in list(dictionary.items()):
                     dictionary[key] = value
                 return dictionary
 
         for key, value in list(dictionary.items()):
+            # if  key in ignore_keys:
+            #     dictionary[key] = value
+            # else:
             dictionary[key] = nestednamedtuple(value)
+
         return namedtuple("namedtupled", dictionary)(**dictionary)
     elif isinstance(dictionary, list):
         return [nestednamedtuple(item) for item in dictionary]
 
     return dictionary
 
 
@@ -114,14 +171,18 @@
             config = ConfigSectionMap()
             config.read('config.ini')
 
             config_file = config.as_dict()
 
     """
 
+    def __init__(self):
+        # https://stackoverflow.com/questions/47640354/reading-special-characters-text-from-ini-file-in-python
+        super(configparser.ConfigParser, self).__init__(interpolation=None)
+
     def as_dict(self, section=None):
         d = dict(self._sections)
         if self._defaults:
             d["DEFAULT"] = self._defaults
         for k in d:
             d[k] = dict(self._defaults, **d[k])
             d[k].pop('__name__', None)
@@ -220,14 +281,16 @@
         self._none_string = "____NONE____"
 
         self._loaded = {
             "console": False,
             "on_ready": False
 
         }
+
+        self._do_not_execute_namespace_keys = [f"{self.env_prefix}_LOGGER", f"{self.env_prefix}_CONSOLE"]
         self.log_time_format = None
 
         globals()[self.global_name] = {}
         self._init_console(force_init=True)
 
     def _log_formatter(self, dt):
 
@@ -263,46 +326,62 @@
                     self.stdout_log_formatter = self.console_options['log_time_format']
                 _console_options.update(self.console_options)
             self.console = Console(**_console_options)
 
     def _load_config_file(self, config_path=None):
         if self._loaded['on_ready']:
             config = ConfigSectionMap()
+            config.optionxform = str
             _config_filename = self.get_path(self._config_file)
+            try:
+                if _config_filename.is_file():
+                    config.read(_config_filename)
+                    self.set(PAWN_CONFIG=config.as_dict())
+                else:
+                    self.set(PAWN_CONFIG={})
+                    self.console.debug(f"[bold red] cannot found config_file - {_config_filename}")
+                for config_category, config_value in config.items():
+                    lower_keys = [key.lower() for key in config[config_category].keys()]
+                    duplicate_keys = _list_duplicates(lower_keys)
+                    for conf_key, conf_value in config[config_category].items():
+                        if conf_key.lower() in duplicate_keys:
+                            self.console.log(f"[yellow]\[WARN] Similar keys exist in config.ini - \[{config_category}] {conf_key}={conf_value}")
+            except Exception as e:
+                self.console.log(f"[bold red]Error occurred while loading config.ini - {e}")
 
-            if _config_filename.is_file():
-                config.read(_config_filename)
-                self.set(PAWN_CONFIG=config.as_dict())
-            else:
-                self.set(PAWN_CONFIG={})
-                self.console.debug(f"[bold red] cannot found config_file - {_config_filename}")
-            # self._loaded['on_ready'] = False
-
-    def get_path(self, path: str) -> Path:
+    def get_path(self, path: str = "") -> Path:
         """Get Path from the directory where the configure.json file is.
         :param path: file_name or path
         :return:
         """
         if self._current_path:
             root_path = Path(self._current_path)
         else:
             root_path = Path(os.path.join(os.getcwd()))
         return root_path.joinpath(path)
 
+    @staticmethod
+    def pawnlib_path():
+        _dir = os.path.dirname(__file__)
+        if "/config" in _dir:
+            return _dir.replace("/config", "")
+        return _dir
+
     def init_with_env(self, **kwargs):
         """
         Initialize with environmental variables.
 
         :param kwargs: dict
         :return:
         """
         self.fill_config_from_environment()
         self.set(**kwargs)
         # self._load_config_file()
         self._loaded['on_ready'] = True
+        self.console.debug(f"{__title__}/{__version__}, PATH={self.pawnlib_path()}")
         self._load_config_file()
         return self
 
     # def set_config_ini(self):
     #     from configparser import ConfigParser
     #     self.configure = ConfigParser()
     #     self.configure.optionxform = str  # change to uppercase
@@ -500,15 +579,14 @@
 
         if self.global_name in globals():
             for p_key, p_value in order_dict.items():
                 if self._environments.get(p_key, self._none_string) != self._none_string \
                         and self._environments[p_key].get("input"):
                     if self._environments[p_key].get('input') and \
                             self._environments[p_key].get('value') != p_value:
-
                         self.console.log(f"[yellow][WARN] Environment variables and settings are different. "
                                          f"'{p_key}': {self._environments[p_key]['value']}(ENV) != {p_value}(Config)")
                         p_value = self._environments[p_key]['value']
 
                 if p_key == f"{self.env_prefix}_LOGGER" and p_value:
                     from pawnlib.utils.log import AppLogger
                     if isinstance(p_value, dict):
@@ -522,15 +600,15 @@
                     self.app_logger = self._check_logger_not_null(p_key, p_value)
                 elif p_key == f"{self.env_prefix}_ERROR_LOGGER" and p_value:
                     self.error_logger = self._check_logger_not_null(p_key, p_value)
                 elif p_key == f"{self.env_prefix}_DEBUG":
                     self.debug = self.str2bool(p_value)
                     self.console.pawn_debug = self.str2bool(p_value)
                     if self.debug:
-                        rich_traceback_install(show_locals=True)
+                        rich_traceback_install(show_locals=True, width=160)
                         if self.app_logger:
                             set_debug_logger(self.app_logger)
                         # if self.error_logger:
                         #     set_debug_logger(self.error_logger)
                         # from pawnlib import logger
                         # logger.propagate = 0
                         # logger.addHandler(self.app_logger)
@@ -733,17 +811,18 @@
 
                 from pawnlib.config.globalconfig import pawnlib_config
                 print(pawnlib_config.conf().hello) # >>> 'world'
 
         """
         g = globals()
         if self.global_name in g:
-            return nestednamedtuple(g[self.global_name])
+            # return nestednamedtuple(g[self.global_name], ignore_keys=self._do_not_execute_namespace_keys)
+            return NestedNamespace(**g[self.global_name])
         else:
-            return nestednamedtuple({})
+            return NestedNamespace({})
 
     def to_dict(self) -> dict:
         """Access global configuration as a dict.
 
         Example:
 
             .. code-block:: python
@@ -766,17 +845,28 @@
     #     g = globals()
     #     if self.global_name in g:
     #         return self.data
     #
     #     return self.data
 
 
+def _list_duplicates(seq):
+    seen = set()
+    seen_add = seen.add
+    # adds all elements it doesn't know yet to seen and all other to seen_twice
+    seen_twice = set(x for x in seq if x in seen or seen_add(x))
+    # turn the set into a list (as requested)
+    return list(seen_twice)
+
+
 def set_debug_logger(logger_name=None, propagate=0, get_logger_name='PAWNS', level='DEBUG'):
     if logger_name:
         __logger = logging.getLogger(get_logger_name)
         __logger.propagate = propagate
         __logger.setLevel(level)
         __logger.addHandler(logger_name)
 
 
 pawnlib_config = PawnlibConfig(global_name="pawnlib_global_config").init_with_env()
+pawn = pawnlib_config
+pconf = partial(pawn.conf)
 global_verbose = pawnlib_config.get('PAWN_VERBOSE', 0)
```

## pawnlib/output/__init__.py

```diff
@@ -25,10 +25,15 @@
     get_bcolors,
     colored_input,
     dump,
     debug_print,
     classdump,
     kvPrint,
     print_json,
+    print_var,
     debug_logging,
     print_progress_bar,
+    get_colorful_object,
+    syntax_highlight,
+    ProgressTime,
+    NoTraceBackException
 )
```

## pawnlib/output/color_print.py

```diff
@@ -2,19 +2,28 @@
 # -*- coding: utf-8 -*-
 import sys
 import os
 import json
 import getpass
 import traceback
 import inspect
-from pawnlib.typing import converter, date_utils, list_to_oneline_string, const
+from contextlib import contextmanager, AbstractContextManager
+
+from pawnlib.typing import converter, date_utils, list_to_oneline_string, const, is_include_list
 from pawnlib.config import pawnlib_config as pawn, global_verbose
+from pygments import highlight
+from pygments.lexers import get_lexer_by_name
+from pygments.formatters import Terminal256Formatter
 from rich.table import Table
-from typing import Union
+from rich.progress import Progress, SpinnerColumn, TimeElapsedColumn
+from typing import Union, Callable
 from datetime import datetime
+import textwrap
+from requests.structures import CaseInsensitiveDict
+
 
 _ATTRIBUTES = dict(
     list(zip([
         'bold',
         'dark',
         '',
         'underline',
@@ -137,15 +146,16 @@
 
     Print a table using a rich.table module.
 
     :param title: Title of table
     :param data: Data of table
     :param columns: Columns of table. Print only column parameter values.
     :param with_idx: Print the row count.
-    :param call_hook_value: The row value must be a string. If you want to perform other tasks, please add the function name.
+    :param call_value_func: The row value must be a string. If you want to perform other tasks, please add the function name.
+    :param call_desc_func: Invoke a function that describes the value.
 
     Example:
 
         .. code-block:: python
 
         from pawnlib.output.color_print import PrintRichTable
 
@@ -189,64 +199,140 @@
         │ 1   │ 2x038bd14d5ce28a4ac713c21e89f0e6ca5f107f08 │
         ├─────┼────────────────────────────────────────────┤
         │ 2   │ 3x038bd14d5ce28a4ac713c21e89f0e6ca5f107f08 │
         └─────┴────────────────────────────────────────────┘
 
     """
 
-    def __init__(self, title: str = "", data: Union[dict, list] = None, columns: list = None, with_idx: bool = True, call_hook_value=str,
-                 **kwargs) -> None:
+    def __init__(
+                self,
+                title: str = "",
+                data: Union[dict, list] = None,
+                columns: list = None,
+                remove_columns: list = None,
+                with_idx: bool = True,
+                call_value_func = str,
+                call_desc_func = None,
+                **kwargs
+                ) -> None:
 
         if columns is None:
             columns = list()
         if data is None:
             data = dict()
         self.title = f"[bold cyan] {title}"
-        self.table = Table(title=self.title, **kwargs)
+        self.table_options = kwargs
+        # self.table = Table(title=self.title, **kwargs)
+        self.table = None
         self.data = data
         self.table_data = []
         self.columns = columns
+        self.remove_columns = remove_columns
         self.rows = []
         self.row_count = 0
         self.with_idx = with_idx
-        self.call_hook_value = call_hook_value
+        self.call_value_func = call_value_func
+        self.call_desc_func = call_desc_func
 
+        self._initialize_table()
         self._set_table_data()
         self._print_table()
 
-    def _set_table_data(self):
+    def _initialize_table(self):
         if isinstance(self.data, dict):
-            self.table_data = [self.data]
+            self.table_data = self.data
+            if not self.table_options.get('show_header'):
+                self.table_options['show_header'] = False
+            if self.table_options.get('show_lines', "NOT_DEFINED") == "NOT_DEFINED":
+                self.table_options['show_lines'] = False
+
         elif isinstance(self.data, list):
             self.table_data = self.data
         else:
             self.table_data = []
 
-        if self.table_data and len(self.columns) == 0 and isinstance(self.table_data[0], dict):
-            self.columns = list(self.table_data[0].keys())
+        self.table = Table(title=self.title, **self.table_options)
+
+    # def _specify_columns
+    def _is_showing_columns(self, item):
+        if len(self.columns) == 0:
+            return True
+        if item in self.columns:
+            return True
+        return False
+
+    def _draw_vertical_table(self):
+        pawn.console.debug(f"Drawing vertical table")
+        if self.with_idx:
+            self.table.add_column("idx")
+        self.table.add_column("key", justify="left")
+        self.table.add_column("value", justify="right")
+
+        if self.call_desc_func and callable(self.call_desc_func):
+            self.table.add_column("description", justify="right")
+
+        _count = 0
+        row_dict = {}
+        for item, value in self.table_data.items():
+            if self._is_showing_columns(item):
+                row_dict[item] = value
+                if callable(self.call_value_func):
+                    value = self.call_value_func(value)
+
+                columns = [f"{item}", f"{value}"]
+                if self.with_idx:
+                    columns.insert(0, f"{_count}")
+                if self.call_desc_func and callable(self.call_desc_func):
+                    columns.append(self.call_desc_func(*columns, **row_dict))
 
-            if self.with_idx:
-                self.columns.insert(0, "idx")
+                self.table.add_row(*columns)
+                _count += 1
 
+    def _draw_horizontal_table(self):
+        pawn.console.debug("Drawing horizontal table")
         for item in self.table_data:
             if isinstance(item, dict):
                 line_row = []
+                row_dict = {}
                 for column in self.columns:
                     if self.with_idx and column == "idx":
-                        value = self.call_hook_value(self.row_count)
+                        value = str(self.row_count)
+                    elif column == "desc":
+                        value = self.call_desc_func(*line_row, **row_dict)
                     else:
-                        value = self.call_hook_value(item.get(column))
+                        value = self.call_value_func(item.get(column))
+                    row_dict[column] = value
                     line_row.append(value)
                 self.rows.append(line_row)
             self.row_count += 1
 
-    def _print_table(self):
         for col in self.columns:
             self.table.add_column(col)
 
+    def _extract_columns(self):
+        # if self.table_data and len(self.columns) == 0 and isinstance(self.table_data[0], dict):
+        if self.table_data and len(self.columns) == 0:
+            self.columns = list(self.table_data[0].keys())
+        if self.with_idx:
+            self.columns.insert(0, "idx")
+        if callable(self.call_desc_func):
+            self.columns.append("desc")
+
+        if self.columns and isinstance(self.remove_columns, list):
+            for r_column in self.remove_columns:
+                self.columns.remove(r_column)
+
+    def _set_table_data(self):
+        if isinstance(self.table_data, list):
+            self._extract_columns()
+            self._draw_horizontal_table()
+        elif isinstance(self.table_data, dict):
+            self._draw_vertical_table()
+
+    def _print_table(self):
         for row in self.rows:
             self.table.add_row(*row)
 
         if self.table.columns:
             pawn.console.print(self.table)
         else:
             pawn.console.print(f"{self.title} \n  [i]No data ... [/i]")
@@ -411,14 +497,16 @@
     :param _last_key:
     :return:
     """
     spacing = '   '
     def_spacing = '   '
     format_number = lambda n: n if n % 1 else int(n)
 
+    ignore_keys = ["Hash"]
+
     if type(obj) == dict:
         if nested_level == 0 or _is_list:
             print('%s{' % (def_spacing + (nested_level) * spacing))
         else:
             print("{")
 
         for k, v in obj.items():
@@ -438,35 +526,37 @@
                 dump(v, nested_level + 1, output, hex_to_int, debug, _is_list=True)
             else:
                 print(bcolors.WARNING + '%s%s' % (def_spacing + (nested_level + 1) * spacing, get_colorful_object(v)) + bcolors.ENDC, file=output)
         print('%s]' % (def_spacing + (nested_level) * spacing), file=output)
     else:
         if debug:
             converted_hex = ""
-            if hex_to_int and converter.is_hex(obj):
 
+            if hex_to_int and converter.is_hex(obj) and not is_include_list(target=_last_key, include_list=ignore_keys, ignore_case=False) :
                 if _last_key == "timestamp":
                     t_value = round(int(obj, 16) / 1_000_000)
                     converted_str = f"(from {_last_key})"
                     converted_date = datetime.fromtimestamp(format_number(t_value)).strftime('%Y-%m-%d %H:%M:%S')
                     converted_hex = f"{converted_date} {converted_str}"
 
+                elif isinstance(obj, str) and len(obj) >= 60:
+                    pass
                 else:
                     if len(obj) < 14:
                         TINT = 1
                         TINT_STR = ""
                     else:
                         TINT = const.TINT
                         TINT_STR = f"(from TINT) {_last_key}"
 
                     converted_float = format_number(round(int(obj, 16) / TINT, 4))
                     converted_hex = f"{converted_float:,} {TINT_STR}"
 
-            obj = f"{get_colorful_object(obj)} " \
-                  f"{bcolors.LIGHT_GREY}{converted_hex}{bcolors.ENDC}" \
+            obj = f"{get_colorful_object(obj)}  " \
+                  f"{bcolors.ITALIC}{bcolors.LIGHT_GREY}{converted_hex}{bcolors.ENDC}" \
                   f"{bcolors.HEADER} {str(type(obj)):>20}{bcolors.ENDC}" \
                   f"{bcolors.DARK_GREY} len={len(str(obj))}{bcolors.ENDC}"
         print(bcolors.WARNING + '%s%s' % (def_spacing + nested_level * spacing, obj) + bcolors.ENDC)
 
 
 def debug_print(text, color="green", on_color=None, attrs=None, view_time=True, **kwargs):
     """Print colorize text.
@@ -575,18 +665,18 @@
     :param decimals:
     :param bar_length:
     :param overlay:
     :return:
 
     Example:
 
-        from pawnlib import output
-
         .. code-block:: python
 
+            from pawnlib import output
+
             for i in range(1, 100):
                 time.sleep(0.05)
                 output.print_progress_bar(i, total=100, prefix="start", suffix="suffix")
 
             # >> start |\#\#\#\#\#\#\#\| 100.0% suffix
 
     """
@@ -600,7 +690,395 @@
         sys.stdout.write("\033[F")  # back to previous line
         sys.stdout.write("\033[K")  # clear line
     sys.stdout.write('%s |%s| %s%s %s \n' %
                      (prefix, bar, percent, '%', suffix)),
 
     if iteration == total:
         sys.stdout.write('\n')
+
+
+def _patched_make_iterencode(markers, _default, _encoder, _indent, _floatstr,
+                     _key_separator, _item_separator, _sort_keys, _skipkeys, _one_shot,
+                     ## HACK: hand-optimized bytecode; turn globals into locals
+                     ValueError=ValueError,
+                     dict=dict,
+                     float=float,
+                     id=id,
+                     int=int,
+                     isinstance=isinstance,
+                     list=list,
+                     str=str,
+                     tuple=tuple,
+                     _intstr=int.__repr__,
+                     ):
+
+    if _indent is not None and not isinstance(_indent, str):
+        _indent = ' ' * _indent
+
+    def _iterencode_list(lst, _current_indent_level):
+        if not lst:
+            yield '[]'
+            return
+        if markers is not None:
+            markerid = id(lst)
+            if markerid in markers:
+                raise ValueError("Circular reference detected")
+            markers[markerid] = lst
+        buf = '['
+        if _indent is not None:
+            _current_indent_level += 1
+            newline_indent = '\n' + _indent * _current_indent_level
+            # separator = _item_separator + newline_indent
+            separator = ", "
+            buf += newline_indent
+
+        else:
+            newline_indent = None
+            separator = _item_separator
+        first = True
+        for value in lst:
+            if first:
+                first = False
+            else:
+                buf = separator
+            if isinstance(value, str):
+                yield buf + _encoder(value)
+            elif value is None:
+                yield buf + 'null'
+            elif value is True:
+                yield buf + 'true'
+            elif value is False:
+                yield buf + 'false'
+            elif isinstance(value, int):
+                # Subclasses of int/float may override __repr__, but we still
+                # want to encode them as integers/floats in JSON. One example
+                # within the standard library is IntEnum.
+                yield buf + _intstr(value)
+            elif isinstance(value, float):
+                # see comment above for int
+                yield buf + _floatstr(value)
+            else:
+                yield buf
+                if isinstance(value, (list, tuple)):
+                    chunks = _iterencode_list(value, _current_indent_level)
+                elif isinstance(value, dict):
+
+                    chunks = _iterencode_dict(value, _current_indent_level)
+
+                else:
+                    chunks = _iterencode(value, _current_indent_level)
+                yield from chunks
+        if newline_indent is not None:
+            _current_indent_level -= 1
+            yield '\n' + _indent * _current_indent_level
+        yield ']'
+        if markers is not None:
+            del markers[markerid]
+
+    def _iterencode_dict(dct, _current_indent_level):
+        if not dct:
+            yield '{}'
+            return
+        if markers is not None:
+            markerid = id(dct)
+            if markerid in markers:
+                raise ValueError("Circular reference detected")
+            markers[markerid] = dct
+        yield '{'
+        if _indent is not None:
+            _current_indent_level += 1
+            newline_indent = '\n' + _indent * _current_indent_level
+            item_separator = _item_separator + newline_indent
+            yield newline_indent
+        else:
+            newline_indent = None
+            item_separator = _item_separator
+        first = True
+        if _sort_keys:
+            items = sorted(dct.items())
+        else:
+            items = dct.items()
+        for key, value in items:
+            if isinstance(key, str):
+                pass
+            # JavaScript is weakly typed for these, so it makes sense to
+            # also allow them.  Many encoders seem to do something like this.
+            elif isinstance(key, float):
+                # see comment for int/float in _make_iterencode
+                key = _floatstr(key)
+            elif key is True:
+                key = 'true'
+            elif key is False:
+                key = 'false'
+            elif key is None:
+                key = 'null'
+            elif isinstance(key, int):
+                # see comment for int/float in _make_iterencode
+                key = _intstr(key)
+            elif _skipkeys:
+                continue
+            else:
+                raise TypeError(f'keys must be str, int, float, bool or None, '
+                                f'not {key.__class__.__name__}')
+            if first:
+                first = False
+            else:
+                yield item_separator
+            yield _encoder(key)
+            yield _key_separator
+            if isinstance(value, str):
+                yield _encoder(value)
+            elif value is None:
+                yield 'null'
+            elif value is True:
+                yield 'true'
+            elif value is False:
+                yield 'false'
+            elif isinstance(value, int):
+                # see comment for int/float in _make_iterencode
+                yield _intstr(value)
+            elif isinstance(value, float):
+                # see comment for int/float in _make_iterencode
+                yield _floatstr(value)
+            else:
+                if isinstance(value, (list, tuple)):
+                    chunks = _iterencode_list(value, _current_indent_level)
+                elif isinstance(value, dict):
+                    chunks = _iterencode_dict(value, _current_indent_level)
+                else:
+                    chunks = _iterencode(value, _current_indent_level)
+                yield from chunks
+        if newline_indent is not None:
+            _current_indent_level -= 1
+            yield '\n' + _indent * _current_indent_level
+        yield '}'
+        if markers is not None:
+            del markers[markerid]
+
+    def _iterencode(o, _current_indent_level):
+        if isinstance(o, str):
+            yield _encoder(o)
+        elif o is None:
+            yield 'null'
+        elif o is True:
+            yield 'true'
+        elif o is False:
+            yield 'false'
+        elif isinstance(o, int):
+            # see comment for int/float in _make_iterencode
+            yield _intstr(o)
+        elif isinstance(o, float):
+            # see comment for int/float in _make_iterencode
+            yield _floatstr(o)
+        elif isinstance(o, (list, tuple)):
+            yield from _iterencode_list(o, _current_indent_level)
+
+        elif isinstance(o, dict):
+            yield from _iterencode_dict(o, _current_indent_level)
+        else:
+            if markers is not None:
+                markerid = id(o)
+                if markerid in markers:
+                    raise ValueError("Circular reference detected")
+                markers[markerid] = o
+            o = _default(o)
+            yield from _iterencode(o, _current_indent_level)
+            if markers is not None:
+                del markers[markerid]
+    return _iterencode
+
+
+def json_compact_dumps(data, indent=4, monkey_patch=True):
+    if monkey_patch:
+        json.encoder._make_iterencode = _patched_make_iterencode
+    return json.dumps(data,  indent=indent)
+
+
+class NoIndent(object):
+    """ Value wrapper. """
+    def __init__(self, value):
+        self.value = value
+
+
+class NoListIndentEncoder(json.JSONEncoder):
+    def __init__(self, *args, **kwargs):
+        # Save copy of any keyword argument values needed for use here.
+        super(NoListIndentEncoder, self).__init__(*args, **kwargs)
+
+    def iterencode(self, o, _one_shot=False):
+        list_lvl = 0
+        for s in super(NoListIndentEncoder, self).iterencode(o, _one_shot=_one_shot):
+            if s.startswith('['):
+                list_lvl += 1
+                s = s.replace('\n', '').rstrip()
+                s = s.replace(' ', '')
+            elif 0 < list_lvl:
+                s = s.replace('\n', '').rstrip()
+                s = s.replace(' ', '')
+                if s and s[-1] == ',':
+                    s = s[:-1] + self.item_separator
+                elif s and s[-1] == ':':
+                    s = s[:-1] + self.key_separator
+            if s.endswith(']'):
+                list_lvl -= 1
+            s = s.replace(",", ", ")
+            yield s
+
+
+class ProgressTime(Progress):
+    def __init__(self, **kwargs):
+
+        if kwargs.get('transient', "__NOT_DEFINED__") == "__NOT_DEFINED__":
+            kwargs['transient'] = True
+
+        super().__init__(
+            SpinnerColumn(),
+            *Progress.get_default_columns(),
+            TimeElapsedColumn(),
+            console=pawn.console,
+            **kwargs
+        )
+
+
+def syntax_highlight(data, name="json", indent=4, style="material", oneline_list=True, line_indent=''):
+    """
+    Syntax highlighting function
+
+    :param data:
+    :param name:
+    :param indent:
+    :param style:
+    :param oneline_list:
+    :param line_indent:
+    :return:
+
+    Example:
+
+        .. code-block:: python
+
+            from pawnlib import output
+
+            print(output.syntax_highlight("<html><head><meta name='viewport' content='width'>", "html", style=style))
+
+    """
+    # styles available as of pygments 2.8.1.
+    # ['default', 'emacs', 'friendly', 'colorful', 'autumn', 'murphy', 'manni',
+    # 'material', 'monokai', 'perldoc', 'pastie', 'borland', 'trac', 'native',
+    # 'fruity', 'bw', 'vim', 'vs', 'tango', 'rrt', 'xcode', 'igor', 'paraiso-light',
+    # 'paraiso-dark', 'lovelace', 'algol', 'algol_nu', 'arduino', 'rainbow_dash',
+    # 'abap', 'solarized-dark', 'solarized-light', 'sas', 'stata', 'stata-light',
+    # 'stata-dark', 'inkpot', 'zenburn']
+    if name == "json" and isinstance(data, (dict, list)):
+        data = dict_clean(data)
+        code_data = json_compact_dumps(dict(data), indent=indent, monkey_patch=oneline_list)
+    elif data:
+        code_data = data
+    else:
+        code_data = ""
+
+    if line_indent:
+        code_data = textwrap.indent(code_data, line_indent)
+
+    return highlight(
+        code=code_data,
+        lexer=get_lexer_by_name(name),
+        formatter=Terminal256Formatter(style=style))
+
+
+def print_here():
+    from inspect import currentframe, getframeinfo
+    frame_info = getframeinfo(currentframe().f_back)
+    filename = frame_info.filename.split('/')[-1]
+    line_number = frame_info.lineno
+    # loc_str = '%s:%d' % (filename, line_number)
+    location_str = f"{filename}:{line_number}"
+    print(location_str)
+
+
+def retrieve_name(var):
+    callers_local_vars = inspect.currentframe().f_back.f_locals.items()
+    return [var_name for var_name, var_val in callers_local_vars if var_val is var]
+
+
+def retrieve_name_ex(var):
+    stacks = inspect.stack()
+    try:
+        func = stacks[0].function
+        code = stacks[1].code_context[0]
+        s = code.index(func)
+        s = code.index("(", s + len(func)) + 1
+        e = code.index(")", s)
+        return code[s:e].strip()
+    except:
+        return ""
+
+
+def dict_clean(data):
+    result = {}
+    for key, value in data.items():
+        if isinstance(value, CaseInsensitiveDict):
+            value = dict(value)
+        elif value is None:
+            value = ''
+        result[key] = value
+    return result
+
+
+def print_var(data=None, title='', **kwargs):
+    if kwargs.get('line_indent', '__NOT_DEFINED__') == "__NOT_DEFINED__":
+        kwargs['line_indent'] = '      '
+    if kwargs.get('data', '__NOT_DEFINED__') != "__NOT_DEFINED__":
+        del kwargs['data']
+
+    var_name = ""
+    try:
+        import executing
+        call_frame = sys._getframe(1)
+        source = executing.Source.for_frame(call_frame)
+        ex = source.executing(call_frame)
+        func_ast = ex.node
+        for ast in func_ast.args:
+            var_name = ast.id
+    except:
+        var_name = ""
+
+    if not data:
+        data_length = 0
+    else:
+        data_length = len(data)
+
+    pawn.console.log(f"🎁 [yellow bold]{title}[/yellow bold][blue bold]{var_name}[/blue bold] "
+                     f"\t[italic] ({type(data).__name__}), len={data_length}", _stack_offset=2)
+    print(syntax_highlight(data, **kwargs))
+
+
+@contextmanager
+def disable_exception_traceback():
+    """
+    All traceback information is suppressed and only the exception type and value are printed
+    """
+    default_value = getattr(sys, "tracebacklimit", 1000)  # `1000` is a Python's default value
+    sys.tracebacklimit = 0
+    yield
+    sys.tracebacklimit = default_value  # revert changes
+    # try:
+    #     sys.tracebacklimit = 0
+    #     yield
+    # finally:
+    #     sys.tracebacklimit = default_value  # revert changes
+
+
+class NoTraceBackException(Exception):
+    def __init__(self, msg):
+        try:
+            line_no = sys.exc_info()[-1].tb_lineno
+            filename = sys.exc_info()[-1].tb_filename
+        except AttributeError:
+            previous_frame = inspect.currentframe().f_back
+            line_no = inspect.currentframe().f_back.f_lineno
+            (filename, line_number,
+             function_name, ln, index) = inspect.getframeinfo(previous_frame)
+        # self.args = "<{0.__name__}> ({2} line {2}): \n {3}".format(type(self), filename, line_no, msg),
+        self.args = "{0}<{1.__name__}>{2} ({3} line {4}): \n {5}".format(bcolors.FAIL, type(self), bcolors.ENDC, filename, line_no, msg),
+        # ex_type, ex_value, traceback = sys.exc_info()
+        raise Exception(self)
+
```

## pawnlib/resource/__init__.py

```diff
@@ -10,8 +10,15 @@
 
 from .server import (
     get_cpu_usage_percentage,
     get_rlimit_nofile,
     get_platform_info,
     get_cpu_load,
     get_mem_info,
+    get_uptime_cmd,
+    get_total_memory_usage,
+    get_mac_platform_info,
+    get_mem_osx_info,
+    get_cpu_time,
+    get_aws_metadata,
+    aws_data_crawl,
 )
```

## pawnlib/typing/__init__.py

```diff
@@ -1,41 +1,56 @@
 from .check import (
     is_json,
     is_float,
     is_int,
     is_hex,
+    is_regex_keyword,
     is_regex_keywords,
     list_depth,
-    is_valid_ipv4
+    is_valid_ipv4,
+    is_valid_ipv6,
+    is_valid_url,
+    is_valid_private_key,
+    is_valid_token_address,
+    guess_type,
+    return_guess_type,
+    sys_exit,
+    is_include_list,
+    keys_exists,
 )
 from .defines import (
-    Namespace
+    Namespace,
+    set_namespace_default_value,
+    fill_required_data_arguments,
 )
 from .converter import (
     StackList,
+    ErrorCounter,
     MedianFinder,
     FlatDict,
     MedianFinder,
     base64ify,
     base64_decode,
     UpdateType,
     convert_hex_to_int,
     convert_dict_hex_to_int,
     hex_to_number,
     get_size,
     convert_bytes,
     str2bool,
+    flatten,
     flatten_list,
     flatten_dict,
     recursive_update_dict,
     dict_to_line,
     dict_none_to_zero,
     list_to_oneline_string,
     long_to_bytes,
     ordereddict_to_dict,
+    extract_values_in_list,
     execute_function,
     influxdb_metrics_dict,
     metrics_key_push,
     dict2influxdb_line,
     rm_space,
     replace_ignore_char,
     replace_ignore_dict_kv,
@@ -46,14 +61,15 @@
     append_suffix,
     append_prefix,
     camel_case_to_space_case,
     camel_case_to_lower_case,
     lower_case_to_camel_case,
     camel_case_to_upper_case,
     upper_case_to_camel_case,
+    shorten_text
 )
 
 from .constants import (
     const
 )
 
 from .generator import (
@@ -71,20 +87,21 @@
     random_private_key,
     random_token_address,
     increase_token_address,
     increase_hex,
     increase_number,
     hexadecimal,
     decimal,
-    uuid_generator,
-    id_generator,
+    uuid,
 
 )
 
 from .date_utils import (
     TimeCalculator,
     convert_unix_timestamp,
     get_range_day_of_month,
     todaydate,
     format_seconds_to_hhmmss,
+    timestamp_to_string,
+    second_to_dayhhmm,
 )
```

## pawnlib/typing/check.py

```diff
@@ -1,9 +1,12 @@
+import copy
 import re
 import json
+import sys
+from pawnlib.config import pawn
 
 
 def is_json(s) -> bool:
     """
     Check if a string is valid JSON
     :param s:
     :return:
@@ -173,12 +176,203 @@
         )
         \s*                         # Trailing whitespace
         $
     """, re.VERBOSE | re.IGNORECASE | re.DOTALL)
     return pattern.match(ip) is not None
 
 
+def is_valid_url(url):
+    if "http://" not in url and "https://" not in url:
+        url = f"http://{url}"
+
+    regex = re.compile(
+        r'^https?://'  # http:// or https://
+        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|'  # domain...
+        r'localhost|'  # localhost...
+        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
+        r'(?::\d+)?'  # optional port
+        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
+    return url is not None and regex.search(url)
+
+
+def is_valid_private_key(text=None):
+    private_length = 64
+    if text and is_hex(text):
+        if text.startswith("0x"):
+            text = text[2:]
+        if len(text) == private_length:
+            return True
+    return False
+
+
+def is_valid_token_address(text=None, prefix="hx"):
+    if text and prefix \
+            and len(text) == 42 \
+            and text.startswith(prefix)\
+            and is_hex(text[2:]):
+        return True
+    return False
+
+
 def list_depth(l):
     if isinstance(l, list):
         return 1 + max(list_depth(item) for item in l)
     else:
         return 0
+
+
+def guess_type(s):
+    """
+    Guess the type of string.
+
+    :param s:
+    :return:
+
+    Example:
+
+    .. code-block:: python
+
+        from pawnlib.typing import check
+
+        check.guess_type("True")
+        # >> <class 'bool'>
+
+        check.guess_type("2.2")
+        # >> <class 'float'>
+
+    """
+    s = str(s)
+    if s == "":
+        return None
+    elif re.match(r"^(\d+)\.(\d+)$", s):
+        return float
+    elif re.match(r"^(\d)+$", s):
+        return int
+    elif re.match(r"^(true|false)$", s, re.IGNORECASE):
+        return bool
+    else:
+        return str
+
+    # else:
+    #     return type(s)
+
+
+def _str2bool(v) -> bool:
+    """
+    this function get the boolean type
+
+    :param v:
+    :return:
+    """
+    if v is None:
+        return False
+    elif type(v) == bool:
+        return v
+    if isinstance(v, str):
+        if v.lower() in ('yes', 'true', 't', 'y', '1'):
+            return True
+        elif v.lower() in ('no', 'false', 'f', 'n', '0'):
+            return False
+    elif v == 1:
+        return True
+
+    return False
+
+
+def return_guess_type(value):
+    guessed_type = guess_type(value)
+
+    if guessed_type is None or guessed_type == "":
+        return value
+
+    if isinstance(guessed_type(), bool):
+        return _str2bool(value)
+    elif value is not None and value != "":
+        return guessed_type(value)
+    else:
+        return value
+
+
+def sys_exit(message="", return_code=-1):
+    """
+    This function executes the sys.exit() method
+
+    :param message: print message
+    :param return_code: exit code
+    :return:
+
+    """
+    if message:
+        pawn.console.log(f"[red]\[Exit {return_code}] {message}")
+    sys.exit(return_code)
+
+
+def is_include_list(target=None, include_list=[], ignore_case=True):
+    """
+    check if target string exists in list
+    :param target: target string
+    :param include_list: List of strings to check
+    :param ignore_case: ignore case sensitive
+    :return:
+    """
+    if target and include_list:
+        for include_key in include_list:
+            if ignore_case and include_key.lower() in target.lower():
+                return True
+            if include_key in target:
+                return True
+    return False
+
+
+def keys_exists(element, *keys):
+    """
+    Check if *keys (nested) exists in `element` (dict).
+    You don't have to implement it like this.
+
+    [X] if response.get('json') and response['json'].get('result') and response['json']['result'].get('tx_hash'):
+    [O] if keys_exists(response, 'json', 'result', 'tx_hash'):
+
+    :param element:
+    :param keys:
+    :return:
+
+    Example:
+
+        .. code-block:: python
+
+            from pawnlib.typing.check import keys_exists
+
+            dict_example = {
+                "name": "example",
+                "description": {
+                    "description_2": "222",
+                    "description_3": "333",
+                },
+                "none_value_key": None,
+
+            }
+
+            keys_exists(dict_example, 'name', 'description')
+            # >> True
+
+            keys_exists(dict_example, 'name', 'none_value_key')
+            # >> True
+
+            keys_exists(dict_example, 'name', 'none_key')
+            # >> False
+
+    """
+    not_defined = "__NOT_DEFINED__"
+    next_element = ""
+    for index, key in enumerate(keys):
+        if next_element:
+            _element = next_element
+        else:
+            _element = copy.deepcopy(element)
+        if isinstance(_element, dict):
+            if _element.get(key, not_defined) != not_defined:
+                next_element = _element.pop(key, not_defined)
+            else:
+                return False
+        else:
+            return False
+    return True
```

## pawnlib/typing/constants.py

```diff
@@ -23,8 +23,14 @@
 class UnixtimeStampDigits(EtcNamespace):
     __slots__ = ()
     SECONDS_DIGITS = 10
     MILLI_SECONDS_DIGITS = 13
     MICRO_SECONDS_DIGITS = 16
 
 
-const = UnixtimeStampDigits()
+class IconAddress(UnixtimeStampDigits):
+    __slots__ = ()
+    CHAIN_SCORE_ADDRESS = f"cx{'0'*39}0"
+    GOVERNANCE_ADDRESS = f"cx{'0'*39}1"
+
+
+const = IconAddress()
```

## pawnlib/typing/converter.py

```diff
@@ -1,24 +1,26 @@
 import sys
 import os
 import binascii
 import re
 import heapq
 from termcolor import cprint
+import decimal
+import math
+import base64
 from .check import is_int, is_hex
 from deprecated import deprecated
-
 from typing import Union, Any, Type
-import base64
 from pawnlib.config.globalconfig import pawnlib_config as pawn
 from collections.abc import MutableMapping
 from pawnlib import logger
 from pawnlib.typing.constants import const
 from pawnlib.config.__fix_import import Null
 import statistics
+from datetime import datetime
 
 NO_DEFAULT = object()
 
 
 class StackList:
     """
     Stack List
@@ -55,27 +57,108 @@
 
     def median(self):
         return statistics.median(self.data)
 
     def mean(self):
         return statistics.mean(self.data)
 
+    def max(self):
+        return max(self.data)
+
+    def min(self):
+        return min(self.data)
+
     def get_list(self):
         return self.data
 
     def __repr__(self):
         return str(f"<StackList> {self.data}")
 
     def __str__(self):
         return str(f"<StackList> {self.data}")
 
     def reset(self):
         self.data = []
 
 
+# class ConsecutiveCounter:
+class ErrorCounter:
+
+    def __init__(self, max_consecutive_count=10, increase_index=0.5, reset_threshold_rate=80):
+        self.max_consecutive_count = max_consecutive_count
+        self.increase_index = increase_index
+        self.reset_threshold_rate = reset_threshold_rate
+        self.consecutive_count = 0
+        self.total_count = 0
+        self.dynamic_count = 0
+        self.stack = StackList(max_length=max_consecutive_count)
+        self._hit = 0
+        self._hit_rate = 0
+        self.last_message = ""
+
+        self.last_hit = False
+
+    def push(self, error_boolean=True):
+        self.stack.push(
+            (
+                datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3],
+                error_boolean
+            )
+        )
+        if error_boolean is True:
+            self.consecutive_count += 1
+            self.total_count += 1
+        else:
+            self.consecutive_count = 0
+        self.calculate_dynamic_count()
+
+    def calculate_dynamic_count(self):
+        self.dynamic_count = self.total_count ** self.increase_index
+        if self.dynamic_count % 1 == 0:
+            self.last_hit = True
+            self._hit += 1
+            self._hit_rate = truncate_decimal((self._hit/self.total_count)*100)
+
+            if self._hit_rate != 100 and self._hit_rate >= self.reset_threshold_rate:
+                self._reset_counter()
+            self.last_message = f"[red]hit/total={self._hit}/{self.total_count} ({self._hit_rate}%)"
+            pawn.console.debug(self.last_message)
+        else:
+            self.last_hit = False
+
+    def _reset_counter(self):
+        self.total_count = 0
+        self._hit = 0
+        self._hit_rate = 0
+        self.dynamic_count = 0
+
+    def is_ok(self):
+        if self.consecutive_count >= self.max_consecutive_count:
+            return False
+        return True
+
+    def push_ok(self, error_boolean=True):
+        self.push(error_boolean)
+        return self.is_ok()
+
+    def push_hit(self, error_boolean=True):
+        self.push(error_boolean)
+        return self.last_hit
+
+    def get_data(self):
+        return self.__dict__
+
+    def __repr__(self):
+        return str(f"<ErrorCounter> consecutive_count={self.consecutive_count}, "
+                   f"total_count={self.total_count}, max={self.max_consecutive_count}, is_ok={self.is_ok()}, last_hit={self.last_hit}")
+
+    def __str__(self):
+        return self.__repr__()
+
+
 class MedianFinder:
 
     def __init__(self):
         # initialize data structure
         self.max_heap = []
         self.min_heap = []
         self.num_list = []
@@ -739,38 +822,42 @@
     ITALIC = '\033[1;3m'
     UNDERLINE = '\033[4m'
     WHITE = '\033[97m'
     DARK_GREY = '\033[38;5;243m'
     LIGHT_GREY = '\033[37m'
 
 
-def hex_to_number(hex_value: str = "", is_comma: bool = False, debug: bool = False, change: bool = False, ansi: bool = False):
+def hex_to_number(hex_value: str = "", is_comma: bool = False, debug: bool = False, change: bool = False, ansi: bool = False, is_tint: bool = False):
     """
 
     this function will change the hex to number(int)
 
     :param ansi:
     :param hex_value:
     :param is_comma:
     :param debug:
     :param change:
+    :param is_tint:
     :return:
 
     Example:
 
         .. code-block:: python
 
             from pawnlib.typing import converter
 
             converter.hex_to_number("0x22223232d")
             # >> 9162662701
 
             converter.hex_to_number("0x22223232d", is_comma=True)
             # >> '9,162,662,701'
 
+            converter.hex_to_number("0x2386f26fc10000", is_tint=True)
+            # >> 0.01
+
     """
     _changed = False
     _not_change = False
 
     if not ansi:
         _bcolors = Null()
     else:
@@ -782,15 +869,15 @@
         _changed = True
     elif is_hex(hex_value):
         converted_value = int(hex_value, 16)
         _changed = True
     else:
         converted_value = hex_value
     if (_changed and change) or is_int(converted_value):
-        if converted_value >= const.TINT:
+        if converted_value >= const.TINT or is_tint:
             converted_value = converted_value / const.TINT
             changed_text = f"{_bcolors.WARNING}(tint){_bcolors.ENDC}"
 
         if is_comma:
             converted_value = f"{converted_value:,}"
 
         if ansi:
@@ -899,14 +986,36 @@
             return False
     elif v == 1:
         return True
 
     return False
 
 
+def flatten(dictionary, parent_key=False, separator='.'):
+    """
+    Turn a nested dictionary into a flattened dictionary
+    :param dictionary: The dictionary to flatten
+    :param parent_key: The string to prepend to dictionary's keys
+    :param separator: The string used to separate flattened keys
+    :return: A flattened dictionary
+    """
+
+    items = []
+    for key, value in dictionary.items():
+        new_key = str(parent_key) + separator + key if parent_key else key
+        if isinstance(value, MutableMapping):
+            items.extend(flatten(value, new_key, separator).items())
+        elif isinstance(value, list):
+            for k, v in enumerate(value):
+                items.extend(flatten({str(k): v}, new_key).items())
+        else:
+            items.append((new_key, value))
+    return dict(items)
+
+
 def flatten_list(list_items: list, uniq=False) -> list:
     """
     this function will convert complex list to  flatten list
 
 
     :param list_items:
     :param uniq:
@@ -973,37 +1082,38 @@
                 else:
                     ret[f"{key}{separator}{i}"] = value
         else:
             ret[key] = val
     return ret
 
 
-def dict_to_line(dict_param: dict, quotes: bool = False, separator: str = "=") -> str:
+def dict_to_line(dict_param: dict, quotes: bool = False, separator: str = "=", end_separator: str = ",") -> str:
     """
     This function converts a dict to a line.
 
     :param dict_param:
     :param quotes:
     :param separator:
+    :param end_separator:
     :return:
 
     Example:
 
         .. code-block:: python
 
             # >> {"a": "1234", "b": "1235"} => "a=1234,b=1235"
 
     """
     return_value = ""
     for k, v in sorted(dict_param.items()):
         if quotes:
-            return_value += f"{k}{separator}\"{v}\","
+            return_value += f"{k}{separator}\"{v}\"{end_separator}"
         else:
-            return_value += f"{k}{separator}{v},"
-    return return_value.rstrip(",")
+            return_value += f"{k}{separator}{v}{end_separator}"
+    return return_value.rstrip(end_separator)
 
 
 def dict_none_to_zero(data: dict) -> dict:
     """
     Convert the None type of the dictionary to zero.
 
 
@@ -1792,7 +1902,43 @@
             from pawnlib.typing import converter
             converter.upper_case_to_camel_case('HelloWorld')
             # >> 'HelloWorld'
 
     """
 
     return lower_case_to_camel_case(s.lower())
+
+
+def shorten_text(text="", width=None, placeholder='[...]' ):
+    """
+    Shortens a text string to the specified width and placeholders.
+    :param text: text to shorten
+    :param width: maximum width of the string
+    :param placeholder: placeholder string of the text
+    :return:
+    """
+    _text = str(text)
+    if not width or not text:
+        return text
+
+    total_length = len(_text) - len(placeholder)
+    max_length = total_length - 1
+
+    if _text and max_length >= width:
+        return f"{_text[0:width]} {placeholder}"
+    return text
+
+
+def truncate_float(number, digits=2) -> float:
+    # Improve accuracy with floating point operations, to avoid truncate(16.4, 2) = 16.39 or truncate(-1.13, 2) = -1.12
+    nb_decimals = len(str(number).split('.')[1])
+    if nb_decimals <= digits:
+        return number
+    stepper = 10.00 ** digits
+    return math.trunc(stepper * number) / stepper
+
+
+def truncate_decimal(number, digits: int = 2) -> decimal.Decimal:
+    round_down_ctx = decimal.getcontext()
+    round_down_ctx.rounding = decimal.ROUND_DOWN
+    new_number = round_down_ctx.create_decimal(number)
+    return round(new_number, digits)
```

## pawnlib/typing/defines.py

```diff
@@ -1,7 +1,8 @@
+from pawnlib.config import pawn, pconf
 
 class _AttributeHolder(object):
     """Abstract base class that provides __repr__.
 
     The __repr__ method returns a string in the format::
         ClassName(attr=name, attr=name, ...)
     The attributes are determined either by a class-level attribute,
@@ -62,7 +63,54 @@
     def __eq__(self, other):
         if not isinstance(other, Namespace):
             return NotImplemented
         return vars(self) == vars(other)
 
     def __contains__(self, key):
         return key in self.__dict__
+
+
+def set_namespace_default_value(namespace=None, key='', default=""):
+    """
+    Set a default value when a key in a namespace has no value
+    :param namespace:
+    :param key:
+    :param default:
+    :return:
+
+    Example:
+
+        .. code-block:: python
+
+            from pawnlib.config import pawn, pconf
+            from pawnlib.typing import set_namespace_default_value
+
+            pawn.set(
+            data={"aaaa": "bbbb"}
+            )
+            pawn.console.log(pconf())
+            undefined_key = set_namespace_default_value(
+                namespace=pconf().data,
+                key="cccc",
+                default="ddddd"
+            )
+            pawn.console.log(undefined_key)
+
+    """
+    if key and hasattr(namespace, key):
+        return getattr(namespace, key)
+    return default
+
+
+def fill_required_data_arguments(required={}):
+    none_string = "__NOT_DEFINED_VALUE__"
+    if getattr(pconf(), "data", None) and getattr(pconf().data, "args", None):
+        args = pconf().data.args
+        for req_key, req_value in required.items():
+            args_value = getattr(args, req_key, none_string)
+            if args_value == none_string:
+                # pawn.console.debug(f"Define the data args -> {req_key}, {req_value}")
+                setattr(args, req_key, req_value)
+    else:
+        # pawn.console.debug(f"New definition: {required}")
+        args = Namespace(**required)
+    return args
```

## pawnlib/utils/__init__.py

```diff
@@ -1,24 +1,33 @@
 from .operate_handler import (
+    ThreadPoolRunner,
     timing,
     get_inspect_module,
     job_start,
     job_done,
     Daemon,
+    run_execute,
+    Spinner,
+    WaitStateLoop,
+    run_with_keyboard_interrupt,
+    handle_keyboard_interrupt_signal,
 )
 from .http import (
     disable_ssl_warnings,
     append_http,
     remove_http,
     append_ws,
     jequest,
     icon_rpc_call,
     IconRpcHelper,
+    IconRpcTemplates,
+    NetworkInfo,
 )
 from .log import (
     CustomLog,
     AppLogger,
 )
 
 from .notify import (
-    send_slack
+    send_slack,
+    send_slack_token
 )
```

## pawnlib/utils/http.py

```diff
@@ -1,151 +1,704 @@
 import re
-import requests
 import json
-from pawnlib.config.globalconfig import pawnlib_config as pawn, global_verbose
-from pawnlib import output
+import sys
+from pawnlib.config.globalconfig import pawnlib_config as pawn, global_verbose, pconf, SimpleNamespace
+from pawnlib.output import NoTraceBackException, dump, syntax_highlight, kvPrint, debug_logging
 from pawnlib.resource import net
-from pawnlib.typing.converter import append_suffix, append_prefix, hex_to_number
+from pawnlib.typing.converter import append_suffix, append_prefix, hex_to_number, FlatDict, FlatterDict, flatten, const
 from pawnlib.typing.constants import const
 from pawnlib.typing.generator import json_rpc, random_token_address
+from pawnlib.typing.check import keys_exists, is_int, is_float, list_depth, is_valid_token_address
+
+try:
+    from pawnlib.utils import icx_signer
+except ImportError:
+    pass
+
+from typing import Union
+
+try:
+    from typing import Literal
+except ImportError:
+    from typing_extensions import Literal
+
+from enum import Enum, auto
+import copy
+import operator as _operator
 import time
-from pawnlib.utils.operate_handler import WaitStateLoop
-from pawnlib import logger
-from functools import partial
+from dataclasses import dataclass, InitVar, field
+import requests
+
+
+ALLOWS_HTTP_METHOD = ["get", "post", "patch", "delete"]
+ALLOW_OPERATOR = ["!=", "==", ">=", "<=", ">", "<", "include", "exclude"]
+
+
+class _ResponseWithElapsed(requests.models.Response):
+    success = False
+
+    def __init__(self):
+        super().__init__()
+
+    def __repr__(self):
+        return f"<Response [{self.status_code}], {self.elapsed}ms, succ={self.success}>"
+
+    def __str__(self):
+        return f"<Response [{self.status_code}], {self.elapsed}ms, succ={self.success}>"
+
+    def as_dict(self):
+
+        if not self.__dict__.get('result'):
+            try:
+                self.__dict__['result'] = self.__dict__['_content'].decode('utf-8')
+            except:
+                pass
+
+        if self.__dict__.get('result') and isinstance(self.__dict__.get('result'), dict):
+            self.__dict__['json'] = self.__dict__['result']
+            self.__dict__['text'] = json.dumps(self.__dict__['result'])
+
+        else:
+            try:
+                self.__dict__['json'] = json.loads(self.__dict__['result'])
+            except:
+                self.__dict__['json'] = {}
+        return self.__dict__
+
+
+requests.models.Response.__str__ = _ResponseWithElapsed.__str__
+requests.models.Response.__repr__ = _ResponseWithElapsed.__repr__
+requests.models.Response.as_dict = _ResponseWithElapsed.as_dict
+
+
+class HttpResponse:
+    def __init__(self, status_code=999, response=None, error=None, elapsed=None, success=False):
+        self.status_code = status_code
+        self.response = response
+        self.error = error
+        self.elapsed = elapsed
+        self.success = success
+        if self.response and self.response.json:
+            self.json = self.response.json
+        else:
+            self.json = {}
+
+        if self.error:
+            self.ok = False
+        else:
+            self.ok = True
+
+    def __str__(self):
+        return f"<HttpResponse> status_code={self.status_code}, response={self.response}, error={self.error}"
+
+    def __repr__(self):
+        return f"<HttpResponse> {self.status_code}, {self.response}, {self.error}"
+
+    def as_dict(self):
+        return self.__dict__
+
+
+class StrEnum(str, Enum):
+    @staticmethod
+    def _generate_next_value_(name, start, count, last_values):
+        return name
+
+    def __repr__(self):
+        return self.name
+
+    def __str__(self):
+        return self.name
+
+
+class AllowsHttpMethod(StrEnum):
+    get = auto()
+    post = auto()
+    patch = auto()
+    delete = auto()
+
+
+class AllowsKey(StrEnum):
+    status_code = auto()
+    headers = auto()
+    raw = auto()
+    url = auto()
+    reason = auto()
+    http_version = auto()
+    r_headers = auto()
+    result = auto()
+    elapsed = auto()
+
+
+@dataclass
+class NetworkInfo:
+    network_name: InitVar[str] = "mainnet"
+    platform: InitVar[str] = "icon"
+    force: InitVar[bool] = False
+    network_api: str = ""
+    planet_api: str = ""
+    nid: str = ""
+    network: str = ""
+    endpoint: str = ""
+    symbol: str = ""
+    valid_network: bool = False
+
+    def __post_init__(self, network_name="", platform="icon", force=False):
+
+        self._platform_info = {
+            "icon": {
+                "symbol": "ICX",
+                "network_info": {
+                    "mainnet": {
+                        "network_api": "https://ctz.solidwallet.io",
+                        "nid": "0x1"
+                    },
+                    "lisbon": {
+                        "network_api": "https://lisbon.net.solidwallet.io",
+                        "nid": "0x2"
+                    },
+                    "cdnet": {
+                        "network_api": "http://20.20.1.122:9000",
+                        "nid": "0x53"
+                    },
+                }
+            },
+            "havah": {
+                "symbol": "HVH",
+                "network_info": {
+                    "mainnet": {
+                        "planet_api": "https://planet.havah.io",
+                        "network_api": "https://ctz.havah.io",
+                        "nid": "0x100"  # 256
+                    },
+                    "vega": {
+                        "planet_api": "https://planet.vega.havah.io",
+                        "network_api": "https://ctz.vega.havah.io",
+                        "nid": "0x101"  # 257
+                    },
+                    "deneb": {
+                        "planet_api": "https://planet.dev.havah.io",
+                        "network_api": "https://ctz.dev.havah.io",
+                        "nid": "0x110"  # 272
+                    },
+                    "svm_havah": {
+                        "network_api": "http://20.20.1.153:9900",
+                        "nid": "0x8361",
+                    },
+                }
+            }
+        }
+        self.network_name = network_name
+        self.platform = platform
+        self.network_info = {}
+        self.static_values = ["nid", "network_api", "endpoint"]
+        if not force:
+            self._initialize()
+
+    def is_set_static_values(self):
+        for static_value in self.static_values:
+            if getattr(self, static_value, None):
+                return True
+
+    def _get_network_info(self, network_name="", platform=""):
+        if network_name:
+            self.network_name = network_name
+        if platform:
+            self.platform = platform
+
+        self.network_name = self.network_name.lower()
+        self.platform = self.platform.lower()
+
+        if not self._platform_info.get(self.platform):
+            raise ValueError(f"Allowed platform - values {list(self._platform_info.keys())}")
+
+        if not self.is_set_static_values():
+            _network_info = self._platform_info[self.platform].get('network_info')
+            if isinstance(_network_info, dict) and not _network_info.get(self.network_name):
+                raise ValueError(f"Allowed network_name in '{self.platform}' - values {list(_network_info.keys())}")
+            self.network_info = self._platform_info[self.platform]['network_info'].get(self.network_name)
+
+        else:
+            _network_info = {}
+
+        self.symbol = self._platform_info[self.platform].get('symbol')
+
+        if self.network_info:
+            self.valid_network = True
+            self.network_info['symbol'] = self.symbol
+            self.network_info['network_name'] = self.network_name
+            self.network_info['platform'] = self.platform
+
+    def _initialize(self, network_name="", platform=""):
+        self._get_network_info(network_name, platform)
+        if self.network_info:
+            this_data = self.network_info
+
+            if this_data.get("network", None) is None:
+                setattr(self, "network", self.network_name)
+            for key, value in this_data.items():
+                object.__setattr__(self, key, this_data.get(key))
+
+    def set_network(self, network_name=None, platform="icon"):
+        if network_name:
+            self._initialize(network_name=network_name, platform=platform)
+
+    def list(self) -> list:
+        return list(self.network_info.keys())
+
+    def get_platform_list(self) -> list:
+        return list(self._platform_info.keys())
+
+    def get_network_list(self, platform="") -> list:
+        if platform:
+            self.platform = platform
+
+        if self._platform_info.get(self.platform):
+            return list(self._platform_info[self.platform]['network_info'].keys())
+
+    def tuple(self) -> tuple:
+        return tuple(self.network_info.keys())
+
+    def to_dict(self, network_name=None):
+        if self.network_info:
+            return self.network_info
+
+        return self.network_info
+
+    def _parse_network_info_string(self):
+        if self.network_info and isinstance(self.network_info, dict):
+            network_info_str = f"network_info={self.network_info}"
+        else:
+            self_dict = copy.deepcopy(self.__dict__)
+            del self_dict['_platform_info']
+            network_info_str = self_dict
+        return network_info_str
+
+    def __repr__(self):
+        return f"<{self.platform.upper()} {self.__class__.__name__}> {self._parse_network_info_string()}"
+
+    def __str__(self):
+        return f"<{self.platform.upper()} {self.__class__.__name__}> {self._parse_network_info_string()}"
+
+
+class IconRpcTemplates:
+    requires_sign_method = ['icx_sendTransaction', 'icx_sendTransaction(SCORE)', 'icx_call']
+    templates = {
+        "main_api": {
+            # "icx_getTotalSupply": json_rpc("icx_getTotalSupply"),
+            "icx_getTotalSupply": {},
+            "icx_getLastBlock": {},
+            "icx_getBalance": {"params": {"address": ""}},
+            "icx_getTransactionResult": {"params": {"txHash": ""}},
+            "icx_getTransactionByHash": {"params": {"txHash": ""}},
+            "icx_getBlockByHeight": {"params": {"height": ""}},
+            "icx_getBlockByHash": {"params": {"hash": ""}},
+            "icx_getScoreApi": {"params": {"address": ""}},
+            "icx_call": {"params": ""},
+            "icx_sendTransaction": {
+                "params": {
+                    "from": "",
+                    "to": "",
+                    "nid": "",
+                    "stepLimit": "",
+                    "value": "",
+                    "version": "0x3",
+                    "nonce": "0x23",
+                }
+            },
+            "icx_sendTransaction(SCORE)": {"method": "icx_sendTransaction"}
+        },
+        "IISS": {
+            "setStake": dict(
+                method="icx_sendTransaction",
+                params={
+                    "method": "setStake",
+                    "params": {
+                        "value": ""
+                    }
+                }
+            ),
+        }
+    }
+
+    def __init__(self, category=None, method=None):
+        self.return_rpc = {}
+        self._category = category
+        self._method = method
+        self._params = {}
+        self.get_rpc()
+
+    def get_category(self):
+        return list(self.templates.keys())
+
+    def get_methods(self, category=None):
+        methods = []
+        for _category in self.get_category():
+            if _category == category:
+                return self.templates.get(_category).keys()
+            methods += self.templates.get(_category).keys()
+        return methods
+
+    def create_rpc(self, params={}, method=None):
+
+        pass
+
+    def is_required_sign(self):
+        if self._method in self.requires_sign_method:
+            return True
+        return False
+
+    def load_template(self):
+        if self._category:
+            _template = self.templates.get(self._category)
+        else:
+            _template = {}
+            for item in self.templates.values():
+                _template.update(item)
+        return _template
+
+    def get_rpc(self, category=None, method=None):
+        if category:
+            self._category = category
+        if method:
+            self._method = method
+
+        # if self._category:
+        #     _template = self.templates.get(self._category)
+        # else:
+        #     _template = self.templates.values()
+        _template = self.load_template()
+
+        if self._method:
+            if _template:
+                _arguments = _template.get(method, {})
+                if not isinstance(_arguments, dict):
+                    raise ValueError(f"[Template Error] Syntax Error -> category={self._category}, method={self._method}")
+
+                if not self._method:
+                    raise ValueError(f"[Template Error] Required method ->  category={self._category}, method={self._method}")
+                self._method = _arguments.get('method', self._method)
+                self._params = _arguments.get('params', {})
+                self.return_rpc = json_rpc(method=self._method, params=self._params)
+
+                # pawn.console.log(f"-- return_rpc {self.return_rpc}")
+
+                return self.return_rpc
+        return {}
+
+    def get_required_params(self):
+        return self._params
 
 
 class IconRpcHelper:
-    def __init__(self, url="", wallet=None):
+    def __init__(self, url="", wallet=None, network_info: NetworkInfo = None, raise_on_failure=False):
+        self.wallet = wallet
+        self.governance_address = None
+        self.request_payload = None
+        self.response = None
+        self.network_info = network_info
+        self.raise_on_failure = raise_on_failure
+
+        if not url and self.network_info:
+            url = self.network_info.network_api
+
         self.url = append_suffix(url, "/api/v3")
         self.debug_url = append_suffix(url, "/api/v3d")
-        self.wallet = wallet
-        self.governance_address = f"cx{'0'*39}1"
+        self.signed_tx = {}
+        self._parent_method = ""
+        self._can_be_signed = False
+        self.on_error = False
+        self.initialize()
 
     def initialize(self):
+        # self._set_governance_address()
         pass
 
+    def _set_governance_address(self, method=None):
+        if self.network_info and not self.governance_address:
+            if self.network_info.platform == "havah":
+                if method and method.startswith("get"):
+                    self.governance_address = const.CHAIN_SCORE_ADDRESS
+                else:
+                    self.governance_address = const.GOVERNANCE_ADDRESS
+            else:
+                self.governance_address = f"cx{'0' * 39}1"
+
     def _decorator_enforce_kwargs(func):
         def from_kwargs(self, *args, **kwargs):
             func_name = func.__name__
             pawn.console.debug(f"Start '{func_name}' function")
             ret = func(self, *args, **kwargs)
             return ret
 
         return from_kwargs
 
-    def rpc_call(self, url=None, method=None, params: dict = {}, payload: dict = {}, print_error=False) -> dict:
+    @staticmethod
+    def _convert_str_to_dict(payload):
+        if isinstance(payload, str):
+            try:
+                payload_dict = json.loads(payload)
+            except:
+                return payload
+            return payload_dict
+
+        return payload
+
+    def _convert_valid_url_format(self, url=None):
+        if url:
+            self.url = url
+        if self.url:
+            self.url = append_http(append_api_v3(self.url))
+        else:
+            raise ValueError('Invalid url: %s' % self.url)
+
+    def _convert_valid_payload_format(self, payload=None, method=None, params=None):
+        if payload:
+            _request_payload = self._convert_str_to_dict(payload)
+        else:
+            _request_payload = json_rpc(method=method, params=params)
+
+        return _request_payload
+
+    def rpc_call(self,
+                 url=None,
+                 method=None,
+                 params: dict = {},
+                 payload: dict = {},
+                 print_error=False,
+                 raise_on_failure=False,
+                 store_request_payload=True
+                 ) -> dict:
         if url:
             _url = url
         else:
             _url = self.url
 
-        if payload:
-            _payload = payload
+        if raise_on_failure:
+            _raise_on_failure = raise_on_failure
         else:
-            _payload = json_rpc(method=method, params=params)
+            _raise_on_failure = self.raise_on_failure
 
-        response = jequest(
-            url=append_api_v3(_url),
-            payload=_payload,
-            method="post"
-        )
-        if print_error and response.get('status_code') != 200:
-            if response.get('json') and response['json'].get('error'):
-                pawn.console.log(f"[red][ERROR] status_code={response['status_code']}, error={response['json']['error']}")
-                pawn.console.log(f"[ERROR] payload={_payload}")
+        _url = append_http(append_api_v3(_url))
+        _request_payload = self._convert_valid_payload_format(payload=payload, method=method, params=params)
+
+        if store_request_payload:
+            self.request_payload = copy.deepcopy(_request_payload)
+
+        # self.response = jequest(
+        #     url=_url,
+        #     payload=_request_payload,
+        #     method="post"
+        # )
+        self.response = CallHttp(
+            url=_url,
+            method="post",
+            timeout=1000,
+            payload=_request_payload,
+            raise_on_failure=_raise_on_failure,
+        ).run().response.as_dict()
+        # pawn.console.log(self.response)
+        # self.response = CallHttp(
+        #     url=_url,
+        #     method="post",
+        #     timeout=1000,
+        #     payload=_request_payload,
+        #     raise_on_failure=_raise_on_failure,
+        # ).run()
+
+        # pawn.console.log(self.response.response)
+        # pawn.console.log(self.response.response.as_dict())
+        # exit()
+
+        if print_error and self.response.get('status_code') != 200:
+            if self.response.get('json') and self.response['json'].get('error'):
+                pawn.console.log(f"[red][ERROR] status_code={self.response['status_code']}, error={self.response['json']['error']}")
+                pawn.console.log(f"[red][ERROR][/red] payload={_request_payload}")
+            elif self.response.get('status_code') == 999:
+                pawn.console.log(f"[red][ERROR][/red] {self.response.get('error')}")
+                # self.exit_on_failure(f"[red][ERROR][/red] {self.response.get('error')}")
             else:
-                pawn.console.log(f"[red]{response.get('status_code')} {response.get('text')}")
-        return response.get('json')
+                pawn.console.log(f"[red][ERROR][/red] status_code={self.response.get('status_code')}, text={self.response.get('text')}")
+        return self.response.get('json')
 
-    def _governance_call(self, url=None, method=None, params={}, governance_address=None):
-        if governance_address:
-            self.governance_address = governance_address
-        response = self.rpc_call(
-            url=url,
-            method="icx_call",
+    def print_response(self, hex_to_int=False):
+        if self.response.get('status_code') != 200:
+            style = "red"
+        else:
+            style = "rule.line"
+        pawn.console.rule(f"<Response {self.response.get('status_code')}>", align='right', style=style, characters="═")
+        if self.response.get('json'):
+            dump(self.response.get('json'), hex_to_int=hex_to_int)
+        else:
+            print(syntax_highlight(self.response.get('text'), name='html'))
+
+    def print_request(self):
+        pawn.console.print("")
+        pawn.console.rule(f"<Request> {self.url}", align='left')
+        pawn.console.print("")
+        print(syntax_highlight(self.request_payload, line_indent='   '))
+
+    def make_params(self, method=None, params={}):
+        json_rpc(
+            method=method,
+            params=params
+        )
+
+    def _is_signable_governance_method(self, method):
+        if self.network_info.platform == "havah" and method:
+            required_sign_methods = ['set', 'register']
+            for required_sign_method in required_sign_methods:
+                if method.startswith(required_sign_method):
+                    pawn.console.debug(f"{method}, It will be signed with the following. required_sign_methods={required_sign_methods}")
+                    return True
+        return False
+
+    def _make_governance_payload(self, method, params):
+
+        if self._can_be_signed is None:
+            self._can_be_signed = self._is_signable_governance_method(method)
+            # pawn.console.log(f"[red] can_be_signed = {self._can_be_signed}")
+
+        if self._can_be_signed:
+            parent_method = "icx_sendTransaction"
+        else:
+            parent_method = "icx_call"
+        _request_payload = self._convert_valid_payload_format(
+            method=parent_method,
             params={
                 "to": self.governance_address,
                 "dataType": "call",
                 "data": {
                     "method": method,
                     "params": params
                 }
             },
-            print_error=True
         )
-        return response.get('result')
+        return _request_payload
+
+    def governance_call(self, url=None, method=None, params={}, governance_address=None, sign=None, store_request_payload=True, is_wait=True):
+        if governance_address:
+            self.governance_address = governance_address
+        else:
+            self._set_governance_address(method=method)
+
+        self._can_be_signed = sign
+        _request_payload = self._make_governance_payload(method, params)
+
+        if self._can_be_signed:
+            _request_payload['params']['value'] = "0x0"
+            self.sign_tx(payload=_request_payload)
+            response = self.sign_send(is_wait=is_wait)
+            return response
+        else:
+            response = self.rpc_call(
+                url=url,
+                payload=_request_payload,
+                print_error=True,
+                store_request_payload=store_request_payload,
+            )
+            return response.get('result', {})
 
-    def get_step_price(self, url=None):
-        response = self._governance_call(url=url, method="getStepPrice")
+    def get_step_price(self, ):
+        response = self.governance_call(method="getStepPrice", governance_address=const.CHAIN_SCORE_ADDRESS, sign=False, store_request_payload=False)
         return response
 
     def _get_step_costs(self, url=None):
-        response = self._governance_call(url=url, method="getStepCosts")
+        response = self.governance_call(method="getStepCosts", governance_address=const.CHAIN_SCORE_ADDRESS, sign=False, store_request_payload=False)
         return response
 
     def get_step_cost(self, step_kind="apiCall"):
         return self._get_step_costs().get(step_kind)
 
     def get_estimate_step(self, url=None, tx=None):
         if url:
-            self.debug_url = url
+            _url = url
+        else:
+            _url = self.debug_url
+
         if isinstance(tx, dict):
             tx['method'] = "debug_estimateStep"
             res = self.rpc_call(
-                url=self.debug_url,
+                url=_url,
                 payload=tx,
+                store_request_payload=False,
                 print_error=True
             )
             res_json = res
-            pawn.console.log(res_json)
             if res_json.get('error'):
-                pawn.console.log(f"[red] debug_estimateStep={res_json.get('error')}")
+                pawn.console.debug(f"[red] An error occurred while running debug_estimateStep, {res_json['error'].get('message')}")
+                sys.exit(-1)
             return res.get('result')
 
         else:
             raise ValueError(f"TX is not dict. tx => {tx}")
 
-    def get_step_limit(self, url=None, tx=None, step_kind="apiCall") :
-        estimate_step = self.get_estimate_step(url, tx)
-        step_cost = self.get_step_cost(step_kind)
-        step_price = self.get_step_price(url)
-        step_limit = hex(hex_to_number(estimate_step) + hex_to_number(step_cost))
-
-        icx_fee = hex_to_number(estimate_step) * hex_to_number(step_price) / const.TINT
-        pawn.console.debug(f"fee = {icx_fee} => estimate[i]({hex_to_number(estimate_step, debug=True)})[/i] * "
-                           f"step_price[i]({hex_to_number(step_price, debug=True)})[/i]")
+    def get_step_limit(self, url=None, tx=None, step_kind="apiCall"):
+        if tx:
+            _tx = tx
+        else:
+            _tx = copy.deepcopy(self.request_payload)
+        unnecessary_keys = ["stepLimit", "signature"]
+        for key in unnecessary_keys:
+            if _tx['params'].get(key, '__NOT_DEFINED__') != "__NOT_DEFINED__":
+                pawn.console.debug(f"Remove the unnecessary '{key}' in payload")
+                del _tx['params'][key]
 
-        pawn.console.debug(f"step_limit => {hex_to_number(step_limit, debug=True)}")
-        return step_limit
+        estimate_step = self.get_estimate_step(tx=_tx)
+        step_cost = self.get_step_cost(step_kind)
+        step_price = self.get_step_price()
+        if estimate_step and step_cost:
+            step_limit = hex(hex_to_number(estimate_step) + hex_to_number(step_cost))
+            icx_fee = hex_to_number(estimate_step) * hex_to_number(step_price) / const.TINT
+            pawn.console.debug(f"fee = {icx_fee} => estimate[i]({hex_to_number(estimate_step, debug=True)})[/i] * "
+                               f"step_price[i]({hex_to_number(step_price, debug=True)})[/i]")
 
+            pawn.console.debug(f"step_limit => {hex_to_number(step_limit, debug=True)}")
+            return step_limit
+        else:
+            pawn.console.log("[red]An error occurred while running get_step_limit")
 
     def get_balance(self, url=None, address=None, is_comma=False):
-        if address:
+        if not address and self.wallet:
+            address = self.wallet.get('address')
+
+        if is_valid_token_address(address):
             response = self.rpc_call(
                 url=url,
                 method="icx_getBalance",
-                params={"address": address}
+                params={"address": address},
+                store_request_payload=False,
             )
-            return hex_to_number(response.get('result'), is_comma=is_comma)
+            _balance = response.get('result')
+            return hex_to_number(_balance, is_comma=is_comma, is_tint=True)
+        else:
+            return self.exit_on_failure(f"Invalid token address - {address}")
 
     def get_tx(self, url=None, tx_hash=None, return_key=None):
         response = self.rpc_call(
             url=url,
             method="icx_getTransactionResult",
             params={"txHash": tx_hash}
         )
         if isinstance(response, dict):
             if return_key:
                 return response.get(return_key)
             return response
         return response.get('text')
 
     def get_tx_wait(self, url=None, tx_hash=None):
+
+        if not tx_hash and keys_exists(self.response, 'json', 'result', 'txHash'):
+            tx_hash = self.response['json']['result']['txHash']
+
+        if not tx_hash:
+            pawn.console.log(f"[red] Not found tx_hash='{tx_hash}'")
+            return
+
         pawn.console.log(f"Check a transaction by {tx_hash}")
-        with pawn.console.status(f"[magenta] Wait for transaction to be generated.") as status:
+        with pawn.console.status("[magenta] Wait for transaction to be generated.") as status:
             count = 0
             while True:
                 resp = self.get_tx(url=url, tx_hash=tx_hash)
                 exit_loop = False
                 prefix_text = f"[bold cyan][Wait TX][{count}][/bold cyan] "
                 if resp.get('error'):
                     exit_msg = ""
@@ -155,28 +708,101 @@
                     text = f"{prefix_text}{exit_msg}[white] {resp['error']['message']}"
 
                 elif resp.get('result'):
                     if resp['result'].get('logsBloom'):
                         resp['result']['logsBloom'] = int(resp['result']['logsBloom'], 16)
 
                     exit_loop = True
-                    text = f"{prefix_text}[OK] {resp['result']}"
+                    text = f"{prefix_text}[OK] {json.dumps(resp['result'])}"
                 else:
                     text = resp
                 status.update(
                     status=f"[bold red]{text}",
                     spinner_style="yellow",
                 )
                 if exit_loop:
                     pawn.console.log(f"[bold green][white] {text}")
                     break
                 count += 1
                 time.sleep(1)
         return resp
 
+    def auto_fill_parameter(self):
+        if isinstance(self.request_payload, dict) and self.request_payload.get('params'):
+            self.request_payload['params']['from'] = self.wallet.get('address')
+
+            if not self.request_payload['params'].get('nonce'):
+                self.request_payload['params']['nonce'] = "0x1"
+
+            if not self.request_payload['params'].get('version'):
+                self.request_payload['params']['version'] = "0x3"
+
+            if not self.request_payload['params'].get('timestamp'):
+                self.request_payload['params']['timestamp'] = hex(icx_signer.get_timestamp_us())
+
+            if self.network_info.nid and not self.request_payload['params'].get('nid'):
+                self.request_payload['params']['nid'] = self.network_info.nid
+
+            if not self.request_payload['params'].get('stepLimit'):
+                self.request_payload['params']['stepLimit'] = self.get_step_limit()
+        else:
+            pawn.console.log(f"[red]Invalid payload - {self.request_payload}")
+
+    def sign_tx(self, wallet=None, payload=None, is_balance=True):
+        self.request_payload = {}
+        self.signed_tx = {}
+        if wallet:
+            self.wallet = wallet
+
+        self.request_payload = self._convert_valid_payload_format(payload=payload)
+        # if not isinstance(payload, dict):
+        #     try:
+        #         payload = json.loads(payload)
+        #     except Exception as e:
+        #         raise ValueError(f"Invalid payload - {e}, payload={payload}")
+
+        private_key = self.wallet.get('private_key')
+        address = self.wallet.get('address')
+
+        if is_balance:
+            _balance = self.get_balance()
+            pawn.console.log(f"<{address}>'s Balance = {_balance} {self.network_info.symbol}")
+
+            if not _balance or _balance == 0:
+                return self.exit_on_failure(f"Insufficient Balance = {_balance} {self.network_info.symbol}")
+
+        self.auto_fill_parameter()
+
+        singer = icx_signer.IcxSigner(data=private_key)
+        self.signed_tx = singer.sign_tx(self.request_payload)
+
+        if address != singer.get_hx_address():
+            raise ValueError(f'Invalid address {address} != {singer.get_hx_address()}')
+
+        return self.signed_tx
+
+    def exit_on_failure(self, exception):
+        self.on_error = True
+        if self.raise_on_failure:
+            raise NoTraceBackException(exception)
+        else:
+            pawn.console.log(f"[red][FAIL][/red] {exception}")
+            return
+
+    def sign_send(self, is_wait=True):
+        if self.signed_tx:
+            response = self.rpc_call(payload=self.signed_tx)
+
+            if not is_wait:
+                return response
+
+            if isinstance(response, dict) and response.get('result'):
+                resp = self.get_tx_wait(tx_hash=response['result'])
+                return resp
+
     @staticmethod
     def _check_tx_result(result):
         if result:
             # print(result)
             response_json = result
             if response_json.get("error"):
                 return False
@@ -243,14 +869,364 @@
     :param url:
     :return:
 
     """
     return re.sub(r"https?://", '', url)
 
 
+def get_operator_truth(inp, relate, cut):
+    ops = {
+        '>': _operator.gt,
+        '<': _operator.lt,
+        '>=': _operator.ge,
+        '<=': _operator.le,
+        '==': _operator.eq,
+        '!=': _operator.ne,
+        'include': lambda y, x: x in y,
+        'exclude': lambda y, x: x not in y
+    }
+    return ops[relate](inp, cut)
+
+
+def guess_key(find_key, data):
+    guessed_result = []
+    if isinstance(data, dict):
+        for k, v in data.keys():
+            if find_key in k:
+                guessed_result.append(k)
+    elif isinstance(data, list):
+        for k in data:
+            if find_key in k:
+                guessed_result.append(k)
+    return guessed_result
+
+
+class SuccessCriteria:
+    def __init__(
+            self,
+            target: str = "",
+            operator: Literal["!=", "==", ">=", "<=", ">", "<", "include", "exclude"] = "",
+            expected: Union[str, int, float] = "",
+            # operator: Literal[tuple(ALLOW_OPERATOR)] = ""
+    ):
+        if target:
+            self.target = target
+        self.operator = operator
+        self.expected = expected
+        self.result = False
+
+        if (self.expected or self.expected == 0) and self.target and self.operator:
+            try:
+                self._set_string_valid_type()
+                self.result = get_operator_truth(self.target, self.operator, self.expected)
+            except:
+                self.result = False
+
+    def _set_string_valid_type(self, ):
+        _debug_message = ""
+        for var_name in ["target", "expected"]:
+            _attr_value_in_class = getattr(self, var_name, "__NOT_NONE__")
+            if _attr_value_in_class != "__NOT_NONE__":
+                if isinstance(_attr_value_in_class, str):
+                    if is_int(_attr_value_in_class):
+                        setattr(self, var_name, int(_attr_value_in_class))
+                    elif is_float(_attr_value_in_class):
+                        setattr(self, var_name, float(_attr_value_in_class))
+
+                _modified_value = getattr(self, var_name)
+                _debug_message += f"{var_name} = {_modified_value} ({type(_modified_value)}) , "
+
+        pawn.console.debug(_debug_message)
+
+    def __str__(self):
+        return "<SuccessCriteria %s>" % self.__dict__
+
+    def __repr__(self):
+        return "<SuccessCriteria %s>" % self.__dict__
+
+    def to_dict(self):
+        return self.__dict__
+
+
+class SuccessResponse(SuccessCriteria):
+    def __init__(
+            self,
+            target_key: str = "",
+            operator: Literal["!=", "==", ">=", "<=", ">", "<", "include", "exclude"] = "",
+            expected: Union[str, int, float] = "",
+            target: dict = {},
+    ):
+        # if not target or not operator or not expected or target_key:
+        #     raise ValueError(f"target: {target}, operator: {operator}, expected: {expected}, target_key: {target_key} ")
+
+        if not isinstance(target, dict):
+            pawn.console.log(f"[red]<Error>[/red] '{target}' is not dict")
+            self.result = False
+            raise ValueError(f"target is not dict - '{target}'")
+
+        self.target_key = target_key
+        self.target = FlatDict(target)
+
+        _selected_flatten_target = self.target.get(self.target_key)
+        super().__init__(target=_selected_flatten_target, operator=operator, expected=expected)
+
+        if not _selected_flatten_target:
+            pawn.console.debug(f"[red]<Error>[/red] '{self.target_key}' is not attribute in {list(self.target.keys())}")
+            pawn.console.debug(
+                f"[red]<Error>[/red] '{self.target_key}' not found. \n Did you mean {guess_key(self.target_key, self.target.keys())} ?")
+            self.result = False
+
+
+class CallHttp:
+    def __init__(self,
+                 url=None,
+                 method: Literal["get", "post", "patch", "delete"] = "get",
+                 # method: Literal[AllowsHttpMethod.get] = "get",
+                 # method: AllowsHttpMethod = AllowsHttpMethod.get,
+                 # method: Literal[tuple(method for method in AllowsHttpMethod)],
+                 payload={},
+                 timeout=1000,
+                 ignore_ssl: bool = False,
+                 verbose: int = 0,
+                 success_criteria: Union[dict, list, str] = None,
+                 success_operator: Literal["and", "or"] = "and",
+                 success_syntax: Literal["operator", "string", "auto"] = "auto",
+                 raise_on_failure: bool = False,
+                 auto_run: bool = True,
+
+                 **kwargs
+                 ):
+
+        self.url = url
+        self.method = method.lower()
+        self.payload = payload
+        self.timeout = timeout / 1000
+        self.ignore_ssl = ignore_ssl
+        self.verbose = verbose
+        self.success_criteria = success_criteria
+        self.success_operator = success_operator
+        self.success_syntax = success_syntax
+
+        self.kwargs = kwargs
+        self.raise_on_failure = raise_on_failure
+        self._DEFAULT_UA = f"CallHttp Agent/{pawn.get('PAWN_VERSION')}"
+        self.on_error = False
+        self.response = requests.models.Response()
+        self.flat_response = None
+
+        self.success = None
+        self._success_results = []
+        self._success_criteria = None
+        self.timing = 0
+        # self.run()
+
+    def _shorten_exception_message_handler(self, exception):
+        _shorten_message_dict = {
+            requests.exceptions.Timeout: {
+                "message": "Timeout Error",
+                "params_message": f"timeout={self.timeout}"
+            },
+            requests.exceptions.HTTPError: "HTTP Error",
+            requests.exceptions.ConnectionError: "DNS lookup Error",
+            requests.exceptions.RequestException: "OOps: Something Else",
+        }
+        _shorten_message = _shorten_message_dict.get(exception)
+        default_msg = f"(url={self.url}, method={self.method}"
+
+        # connection_pool = exception.__context__.pool
+        # hostname = connection_pool.host
+        # port = connection_pool.port
+
+        for req_exception, values in _shorten_message_dict.items():
+            if isinstance(exception, req_exception):
+
+                if isinstance(values, dict) and values.get('message'):
+                    _message = f"<{values.get('message')}>"
+                    _params_message = f" {values.get('params_message', '')}"
+                else:
+                    _message = f"<{values}>"
+                    _params_message = ''
+                return f"{_message}{default_msg}{_params_message})"
+
+        return f"<Unknown Error>{default_msg})"
+
+    def exit_on_failure(self, exception):
+        self.on_error = True
+        self.response = HttpResponse(status_code=999, error=self._shorten_exception_message_handler(exception), elapsed=self.timing)
+        if self.raise_on_failure:
+            raise NoTraceBackException(exception)
+        else:
+            pawn.console.debug(f"[red][FAIL][/red] {exception}")
+            # self.response.status_code = 999
+            # self.response.success = False
+            # self.response.error = self._shorten_exception_message_handler(exception)
+            # print(self.timing)
+            return self.response
+
+    def run(self) -> HttpResponse:
+        self._prepare()
+        start = time.perf_counter()
+        self.fetch_response()
+        end = time.perf_counter()
+        self.timing = int((end - start) * 1000)
+        self._parse_response()
+        self.fetch_criteria()
+        self.response.success = self.is_success()
+
+        return self
+
+    def _prepare(self):
+        self.url = append_http(self.url)
+
+    def fetch_response(self):
+        (json_response, data, http_version, r_headers, error) = ({}, {}, None, None, None)
+        if self.method not in ("get", "post", "patch", "delete"):
+            pawn.error_logger.error(f"unsupported method='{self.method}', url='{self.url}' ") if pawn.error_logger else False
+            # raise ValueError(f"unsupported method={self.method}, url={self.url}")
+            return self.exit_on_failure(f"Unsupported method={self.method}, url={self.url}")
+        try:
+            try:
+                _payload_string = json.dumps(self.payload)
+            except Exception as e:
+                _payload_string = self.payload
+            pawn.console.debug(f"[TRY] url={self.url}, method={self.method}, payload={_payload_string}, kwargs={self.kwargs}")
+            func = getattr(requests, self.method)
+            if self.method == "get":
+                self.response = func(self.url, verify=False, timeout=self.timeout, **self.kwargs)
+            else:
+                self.response = func(self.url, json=self.payload, verify=False, timeout=self.timeout, **self.kwargs)
+        except Exception as e:
+            return self.exit_on_failure(e)
+
+    def _parse_response(self):
+        self.response.timing = self.timing
+        try:
+            _elapsed = int(self.response.elapsed.total_seconds() * 1000)
+        except AttributeError:
+            _elapsed = 0
+        self.response.elapsed = _elapsed
+
+        if getattr(self.response, 'raw', None):
+            self.response.http_version = self.response.raw.version
+        else:
+            self.response.http_version = ""
+        if self.response and not self.on_error:
+            try:
+                self.response.result = self.response.json()
+            except:
+                self.response.result = self.response.text
+
+    def fetch_criteria(self,
+                       success_criteria: Union[dict, list] = None,
+                       success_operator: Literal["and", "or"] = "and",
+                       ):
+        _response_dict = self.response.as_dict()
+        if success_criteria:
+            self.success_criteria = success_criteria
+        if success_operator:
+            self.success_operator = success_operator
+
+        if not self.success_criteria:
+            pawn.console.debug("passing success_criteria")
+        else:
+            if self.success_syntax == "string" or self.success_syntax == "auto":
+                _check_syntax = self._check_criteria_syntax()
+                if _check_syntax:
+                    pawn.console.debug(f"[blue]Try to convert[/blue] {type(self.success_criteria)}, _check_criteria_syntax={_check_syntax}")
+                    self._recursive_convert_criteria()
+
+            depth = list_depth(self.success_criteria)
+            if depth == 1:
+                self.success_criteria = [self.success_criteria]
+
+            for criteria in self.success_criteria:
+                pawn.console.debug(f"{type(criteria)} {criteria}")
+                if isinstance(criteria, list):
+                    _criteria = copy.deepcopy(criteria)
+                    _criteria.append(_response_dict)
+                    self._success_results.append(SuccessResponse(*_criteria))
+                elif isinstance(criteria, dict):
+                    criteria['target'] = _response_dict
+                    self._success_results.append(SuccessResponse(**criteria))
+            pawn.console.debug(self._success_results)
+
+    @staticmethod
+    def _find_operator(string):
+        for operator in ALLOW_OPERATOR:
+            if operator in string:
+                return True
+        return False
+
+    def _check_criteria_syntax(self, criteria=None):
+        if not criteria:
+            criteria = self.success_criteria
+
+        if isinstance(criteria, str):
+            if self._find_operator(criteria):
+                return True
+            return False
+
+        elif isinstance(criteria, list):
+            for ct in criteria:
+                return self._check_criteria_syntax(ct)
+
+    def _recursive_convert_criteria(self, string_criteria=None, depth=None):
+
+        if not string_criteria:
+            string_criteria = self.success_criteria
+
+        if string_criteria and isinstance(string_criteria, str):
+            self.success_criteria = self._convert_criteria(string_criteria)
+            return self.success_criteria
+
+        elif isinstance(self.success_criteria, list):
+            string_criteria_in_list = []
+            for string_criteria in string_criteria:
+                converted_criteria = self._recursive_convert_criteria(string_criteria)
+                if converted_criteria:
+                    string_criteria_in_list.append(converted_criteria)
+
+            if len(string_criteria_in_list) > 0:
+                self.success_criteria = string_criteria_in_list
+
+    def _convert_criteria(self, argument):
+        for operator in ALLOW_OPERATOR:
+            if operator in argument:
+                result = argument.split(operator)
+                if any(word in result[0] for word in ALLOW_OPERATOR + ['=']):
+                    pawn.console.log(f"[red]Invalid operator - '{argument}', {result}")
+                    raise ValueError(f"Invalid operator - '{argument}', {result}")
+                result.insert(1, operator)
+                return result
+        return False
+
+    def _convert_list_criteria(self, arguments):
+        result = []
+        for argument in arguments:
+            criteria = self._convert_criteria(argument)
+            if criteria:
+                result.append(criteria)
+        return result
+
+    def is_success(self):
+        success_count = 0
+        expected_count = len(self._success_results)
+
+        if isinstance(self._success_results, list):
+            for _result in self._success_results:
+                if _result.result:
+                    success_count += 1
+
+        if self.success_operator == "and" and success_count == expected_count:
+            return True
+        elif self.success_operator == "or" and success_count > 0:
+            return True
+        return False
+
+
 def jequest(url, method="get", payload={}, elapsed=False, print_error=False, timeout=None, ipaddr=None, **kwargs) -> dict:
     """
     This functions will be called the http requests.
 
     :param url:
     :param method:
     :param payload:
@@ -293,49 +1269,49 @@
             response = func(url, json=payload, verify=False, timeout=timeout, **kwargs)
         http_version = response.raw.version
         r_headers = response.headers
 
     except requests.exceptions.HTTPError as errh:
         error = errh
         if global_verbose > 0:
-            output.kvPrint("Http Error:", errh)
+            kvPrint("Http Error:", errh)
         pawn.error_logger.error(f"Http Error:{errh}") if pawn.error_logger else False
 
     except requests.exceptions.ConnectionError as errc:
         error = errc
         if ("[Errno 11001] getaddrinfo failed" in str(errc) or  # Windows
                 "[Errno -2] Name or service not known" in str(errc) or  # Linux
                 "[Errno 8] nodename nor servname " in str(errc)):  # OS X
             errc = "DNSLookupError"
         if global_verbose > 0:
-            output.kvPrint("Error Connecting:", errc, "FAIL")
+            kvPrint("Error Connecting:", errc, "FAIL")
         pawn.error_logger.error(f"Error Connecting:{errc}, {url}") if pawn.error_logger else False
 
     except requests.exceptions.Timeout as errt:
         error = errt
         if global_verbose > 0:
-            output.kvPrint("Timeout Error:", errt, "FAIL")
+            kvPrint("Timeout Error:", errt, "FAIL")
         pawn.error_logger.error(f"Timeout Connecting:{errt}, {url}") if pawn.error_logger else False
 
     except requests.exceptions.RequestException as err:
         error = err
         if global_verbose > 0:
-            output.kvPrint("OOps: Something Else", err, "FAIL")
+            kvPrint("OOps: Something Else", err, "FAIL")
         pawn.error_logger.error(f"OOps: Something Else:{err}, {url}") if pawn.error_logger else False
 
     # cprint(f"----> {url}, {method}, {payload} , {response.status_code}", "green")
 
     try:
         response_code = response.status_code
     except:
         response_code = 999
 
     json_payload = json.dumps(payload)
     if global_verbose > 1:
-        output.debug_logging(f"{url}, {method}, {json_payload} , {response_code}")
+        debug_logging(f"{url}, {method}, {json_payload} , {response_code}")
 
     if response_code != 999:
         try:
             json_response = response.json()
         except:
             json_response = {}
             data["text"] = response.text
@@ -354,13 +1330,16 @@
     data["r_headers"] = r_headers
     data["json"] = json_response
     data["error"] = error
     if print_error:
         if error:
             pawn.error_logger.error(f"{error}") if pawn.error_logger else False
 
+    if isinstance(payload, dict):
+        payload = json.dumps(payload)
+
     pawn.console.debug(f"url={url}, method={method}, payload={payload}, kwargs={kwargs}, error={error}")
 
     return data
 
 
 icon_rpc_call = IconRpcHelper().rpc_call
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## pawnlib/utils/icx_signer.py

```diff
@@ -1,52 +1,329 @@
 #!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 import time
 import hashlib
 import base64
 from os import path
 from secp256k1 import PrivateKey, PublicKey
-from pawnlib.typing import check
+from pawnlib.typing import check, date_utils, random_private_key, Namespace, fill_required_data_arguments
 from pawnlib.config import pawnlib_config as pawn
-from eth_keyfile import create_keyfile_json, extract_key_from_keyfile
+from pawnlib.output import is_file, is_json, open_json, check_file_overwrite, NoTraceBackException
+from pawnlib.config import pawn, pconf, NestedNamespace
+from pawnlib.input import PromptWithArgument, PrivateKeyValidator, StringCompareValidator, PrivateKeyOrJsonValidator
+import json
+import glob
+
+from eth_keyfile import create_keyfile_json, extract_key_from_keyfile, decode_keyfile_json
+from copy import deepcopy
+from typing import Optional
 
-
-"""secp256k1 library should be used only in this module.
 """
+secp256k1 library should be used only in this module.
+"""
+compressed = False
+
+translator = str.maketrans({
+    "\\": "\\\\",
+    "{": "\\{",
+    "}": "\\}",
+    "[": "\\[",
+    "]": "\\]",
+    ".": "\\."
+})
+
+
+def guess_wallet_type(data):
+
+    if isinstance(data, str) and len(data) == 66 or len(data) == 64:
+        pawn.console.log("Wallet type is PrivateKey")
+        return "private_key"
+    elif is_json(data):
+        pawn.console.log("Wallet type is JSON")
+        return "json"
+    else:
+        pawn.console.log("Unknown wallet type")
+        return None
+
 
-def store_keystore_file_on_the_path(file_path, json_string):
+class WalletCli:
+    def __init__(self, args=None):
+
+        self._args = args
+        required_args = dict(
+            load_type="",
+            keystore="",
+            base_dir="./",
+            password=""
+        )
+        self._args = fill_required_data_arguments(required=required_args)
+        self._wallet = ""
+
+    def load(self):
+        keystore_json = {}
+        if getattr(self._args, "keystore", None):
+            if isinstance(self._args.keystore, str):
+                self._args.load_type = "text"
+            else:
+                self._args.load_type = "file"
+            load_type = self._args.load_type
+        else:
+            load_type = PromptWithArgument(
+                message="How to load the keystore ?",
+                choices=
+                [
+                    {"name": "[file] From JSON file", "value": "file"},
+                    {"name": "[text] From text (Copy&Paste)", "value": "text"},
+                ],
+                long_instruction="\nUse the up/down keys to select",
+                type="list",
+                max_height="40%",
+                default="",
+                argument="load_type",
+                # verbose=True
+            ).select()
+
+        _required_password = False
+        _keystore = ""
+        _password = ""
+
+        if load_type == "file":
+            regex_file = f"{self._args.base_dir}/*.json"
+            json_file_list = glob.glob(regex_file)
+            if len(json_file_list) <= 0:
+                raise ValueError(f"[red] Cannot found JSON file - '{regex_file}'")
+
+            _keystore = PromptWithArgument(
+                message="Select the keystore file",
+                choices=json_file_list,
+                long_instruction="Use the up/down keys to select",
+                instruction=f"(base_dir={self._args.base_dir})",
+                type="list",
+                default="",
+                argument="keystore",
+            ).select()
+            _required_password = True
+
+        elif load_type == "text":
+            _keystore = PromptWithArgument(
+                message="Input the keystore json or private key text",
+                default="",
+                argument="keystore",
+                validate=StringCompareValidator(operator=">=", length=1),
+            ).prompt()
+
+        if _keystore:
+            keystore = str(_keystore).strip()
+            if is_file(keystore) and is_json(keystore):
+                pawn.console.debug(f"Found Keystore JSON file - {keystore}")
+                try:
+                    keystore_json = open_json(keystore)
+                except ValueError:
+                    pawn.console.log(f"[red]Invalid JSON file - {keystore}")
+                _required_password = True
+            elif is_private_key(keystore):
+                pawn.console.log("Found Private key")
+                keystore_json = keystore
+                _required_password = False
+            else:
+                try:
+                    keystore_json = json.loads(keystore)
+                    if isinstance(keystore_json, dict):
+                        pawn.console.log("[green][OK] Loaded keystore file - JSON object")
+                    else:
+                        raise ValueError("Invalid JSON or Keystore text")
+                    _required_password = True
+                except Exception as e:
+                    raise ValueError(f"[red][Error] cannot load - {e}")
+
+        if _required_password:
+            _password = PromptWithArgument(
+                message="Enter password for private key",
+                type="password",
+                default="",
+                argument="password",
+                invalid_message="Requires at least one character.",
+                validate=lambda result: len(result) >= 1,
+            ).prompt()
+
+        if keystore_json:
+            self._wallet = load_wallet_key(keystore_json, _password)
+            if self._wallet:
+                self.print_wallet()
+            else:
+                pawn.console.log(f"[red][ERROR] Not Loaded wallet")
+
+        return self._wallet
+
+    def create(self):
+
+        PromptWithArgument(
+            message="Enter your private key (default: empty is random)",
+            type="input",
+            default="",
+            argument="private_key",
+            validate=PrivateKeyValidator(allow_none=True),
+            # verbose=0,
+        ).prompt()
+
+        PromptWithArgument(
+            message="Enter password for private key",
+            type="password",
+            default="",
+            argument="password",
+            invalid_message="Requires at least one character.",
+            validate=lambda result: len(result) >= 1,
+        ).prompt()
+
+        if not self._args.private_key:
+            self._args.private_key = random_private_key()
+
+        wallet = load_wallet_key(self._args.private_key, password=self._args.password)
+        _wallet_address = wallet.get('address')
+        self.print_wallet()
+
+        default_filename = f"{wallet.get('address')}_{date_utils.todaydate('ms_text')}.json"
+        PromptWithArgument(
+            message="Enter the name of JSON file to be saved.",
+            default=default_filename,
+            argument="keystore",
+            invalid_message="Requires at least one character.",
+            validate=lambda result: len(result) >= 1,
+        ).prompt()
+        check_file_overwrite(filename=self._args.keystore)
+
+        try:
+            wallet = generate_wallet(
+                file_path=self._args.keystore,
+                password=self._args.password,
+                overwrite=False,
+                private_key=self._args.private_key,
+                expected_address=_wallet_address,
+            )
+            pawn.console.log(f"Generate Wallet - {wallet.get_hx_address()} to '{self._args.keystore}'")
+        except Exception as e:
+            pawn.console.log(f"[red][ERROR] Generate wallet - {e}")
+
+    def print_wallet(self):
+        if self._wallet:
+            pawn.console.print(f"\n"
+                               f" 🔑 address={self._wallet.get('address')}\n"
+                               f" 🔑 public_key={self._wallet.get('public_key')}")
+            if pawn.get('PAWN_DEBUG'):
+                pawn.console.print(f" 🔑 public_key_long={self._wallet.get('public_key_long')}")
+                pawn.console.print(f" 🔑 private_key={self._wallet.get('private_key')}")
+            pawn.console.print("")
+
+
+def store_keystore_file_on_the_path(file_path, json_string, overwrite=False):
     """Stores a created keystore string data which is JSON format on the file path.
     :param file_path: The path where the file will be saved. type(str)
     :param json_string: Contents of the keystore.
     """
-    if path.isfile(file_path):
+    if not overwrite and path.isfile(file_path):
         raise FileExistsError
 
     with open(file_path, 'wt') as f:
         f.write(json_string)
 
 
-def load_wallet_key(file_path, password):
-    pawn.console.debug(f"Load wallet from keystore file : {file_path}", "green")
-    with open(file_path, 'rb') as file:
-        try:
-            private_key: bytes = extract_key_from_keyfile(file, bytes(password, 'utf-8'))
-            wallet = PrivateKey(private_key)
-            public_key: bytes = wallet.public_key.format(compressed=False)
-            address = f'hx{sha3_256(public_key[1:]).digest()[-20:].hex()}'
-            return {
-                "private_key": "0x" + private_key.hex(),
-                "address": address,
-                "public_key": public_key.hex()
-            }
+def generate_wallet(file_path=None, password=None, overwrite=False, private_key=None, expected_address=None):
+    singer = IcxSigner(data=private_key)
+    if not file_path:
+        file_path = f"{singer.get_hx_address()}_{date_utils.todaydate('ms_text')}.json"
+    singer.store(file_path, password, overwrite, expected_address=expected_address)
+    return singer
 
+
+def _parse_keystore_key(file=None, password=None, private_key_hex=None):
+    if private_key_hex:
+        if private_key_hex.startswith("0x"):
+            private_key_hex = private_key_hex[2:]
+        private_key = bytes.fromhex(private_key_hex)
+    else:
+        try:
+            private_key: bytes = decode_keyfile_json(file, bytes(password, 'utf-8'))
         except ValueError as e:
             if "MAC mismatch" in str(e):
-                e = "\t Wrong password"
-            pawn.console.log(f"[bold red] Error {e}")
+                e = "Wrong password"
+            raise ValueError(e)
+
+    wallet = PrivateKey(private_key)
+    public_key_long: bytes = wallet.pubkey.serialize(compressed=False)
+    public_key: bytes = wallet.pubkey.serialize(compressed=True)
+    address = f"hx{get_address(pubkey_bytes=public_key_long).hex()}"
+    pawn.console.debug(f"address={address}")
+    wallet_dict = {
+        # "private_key": "0x" + private_key.hex(),
+        "private_key": private_key.hex(),
+        "address": address,
+        "public_key": public_key.hex(),
+        "public_key_long": public_key_long.hex()
+    }
+    pawn.console.debug(wallet_dict)
+    return wallet_dict
+
+
+def is_private_key(private_key):
+    if isinstance(private_key, str):
+        if (len(private_key) == 64 or len(private_key) == 66) and check.is_hex(private_key):
+            return True
+    return False
+
+
+def exit_on_failure(raise_on_failure, exception):
+    if raise_on_failure:
+        raise NoTraceBackException(exception)
+    else:
+        pawn.console.log(f"[red][ERROR][/red] {exception}")
+
+
+def load_wallet_key(file_or_object=None, password=None, raise_on_failure=True):
+    if isinstance(password, dict) or isinstance(password, list) or isinstance(password, tuple):
+        raise ValueError(f"Wrong password type => {password} ({type(password)})")
+    pawn.console.log(f"[red]Load wallet ")
+    _keystore_params = dict()
+
+    if isinstance(file_or_object, dict):
+        pawn.console.debug(f"Load wallet from keystore file - JSON dict")
+        _keystore_params = dict(
+            file=file_or_object,
+            password=password,
+        )
+    elif is_file(file_or_object):
+        try:
+            pawn.console.debug(f"Load wallet from keystore file : {file_or_object}")
+            _keystore_params = dict(
+                file=open_json(file_or_object),
+                password=password,
+            )
+        except ValueError as e:
+            pawn.console.log(f"[bold red] Open File - {e}")
+
+    elif is_private_key(file_or_object):
+        pawn.console.debug("Load wallet from Private Key")
+        _keystore_params = dict(
+            private_key_hex=file_or_object,
+        )
+    else:
+        pawn.console.debug("Load wallet from JSON")
+        try:
+            file_json = json.loads(file_or_object)
+            _keystore_params = dict(
+                file=file_json,
+                password=password,
+            )
+        except Exception as e:
+            pawn.console.log(f"[bold red] Load json - {e}")
+
+    if _keystore_params:
+        try:
+            return _parse_keystore_key(**_keystore_params)
+        except Exception as e:
+            exit_on_failure(raise_on_failure=raise_on_failure, exception=e)
 
     return {}
 
 
 def generate_keys():
     """generate privkey and pubkey pair.
 
@@ -122,17 +399,18 @@
     def __init__(self, data=None, raw=True):
         """Constructor
 
         Args:
             data(object): bytes or der
             raw(bool): True(bytes) False(der)
         """
-        self._check_private_key(data)
         self._private_key_hex = None
         self._private_key_bytes = None
+        if data:
+            self._check_private_key(data)
 
         self.__privkey = PrivateKey(self._private_key_bytes, raw)
 
     def _check_private_key(self, private_key=None):
 
         if isinstance(private_key, bytes):
             self._private_key_hex = private_key.hex()
@@ -141,14 +419,15 @@
         else:
             raise ValueError(f"Invalid Private Key - {private_key}")
 
         if self._private_key_hex.startswith("0x"):
             self._private_key_hex = self._private_key_hex[2:]
 
         self._private_key_bytes = bytes.fromhex(self._private_key_hex)
+        # pawn.console.debug(f"[green] {self._private_key_bytes}")
 
     def set_privkey_bytes(self, data):
         """Set private key using private key data in bytes.
 
         Args:
             data(bytes): private key data
         """
@@ -159,39 +438,40 @@
 
         Returns:
             bytes: private key data (32 bytes)
         """
         return self.__privkey.private_key
 
     def get_pubkey_bytes(self):
-        return self.__privkey.pubkey.serialize(compressed=False)
+        return self.__privkey.pubkey.serialize(compressed=compressed)
 
-    def get_address(self):
+    def get_address(self) -> bytes:
         """Create an address with pubkey.
         address is made from pubkey.
 
         Returns:
             str: address represented in hexadecimal string starting with '0x'
         """
-        pubkey_bytes = self.__privkey.pubkey.serialize(compressed=False)
+        pubkey_bytes = self.get_pubkey_bytes()
         return get_address(pubkey_bytes)
 
     def get_hx_address(self):
         """Create an address with pubkey.
         address is made from pubkey.
 
         Returns:
             str: address represented in hexadecimal string starting with '0x'
         """
 
         return f"hx{self.get_address().hex()}"
 
     def sign_tx(self, tx=None):
         if isinstance(tx, dict) and tx.get('params'):
-            tx_hash_bytes = get_tx_hash("icx_sendTransaction", tx['params'])
+            # tx_hash_bytes = get_tx_hash("icx_sendTransaction", tx['params'])
+            tx_hash_bytes = get_tx_hash( params=tx['params'])
             signature_bytes, recovery_id = self.sign_recoverable(tx_hash_bytes)
             signature_bytes_big = bytes(bytearray(signature_bytes) + recovery_id.to_bytes(1, 'big'))
             tx['params']['signature'] = base64.b64encode(signature_bytes_big).decode()
         return tx
 
     def sign(self, msg_hash):
         """Make a signature using the hash value of msg.
@@ -202,31 +482,34 @@
         Returns:
             bytes: signature bytes
         """
         privkey = self.__privkey
         signature = privkey.ecdsa_sign(msg_hash, raw=True)
         return privkey.ecdsa_serialize(signature)
 
-    def store(self, file_path: str, password: str):
+    def store(self, file_path: str, password: str, overwrite: bool = False, expected_address: str = None):
         try:
             key_store_contents = create_keyfile_json(
                 self.get_privkey_bytes(),
                 bytes(password, 'utf-8'),
                 iterations=16384,
                 kdf="scrypt"
             )
             key_store_contents['address'] = self.get_hx_address()
             key_store_contents['coinType'] = 'icx'
 
             # validate the  contents of a keystore file.
+            if expected_address and expected_address != self.get_hx_address():
+                raise ValueError(f"Not expected address => expected({expected_address}) != real({self.get_hx_address()})")
+
             import json
             if key_store_contents:
                 json_string_keystore_data = json.dumps(key_store_contents)
-                store_keystore_file_on_the_path(file_path, json_string_keystore_data)
-                pawn.console.debug(f"Stored Wallet. Address: {self.get_address()}, File path: {file_path}")
+                store_keystore_file_on_the_path(file_path, json_string_keystore_data, overwrite)
+                pawn.console.debug(f"Stored Wallet. Address: {self.get_hx_address()}, File path: {file_path}")
         except FileExistsError:
             raise ValueError("File already exists.")
         except PermissionError:
             raise ValueError("Not enough permission.")
         except FileNotFoundError:
             raise ValueError("File not found.")
         except IsADirectoryError:
@@ -277,15 +560,15 @@
     def get_address(self):
         """Create an address with pubkey.
         address is made from pubkey.
 
         Returns:
             str: address represented in hexadecimal string starting with '0x'
         """
-        pubkey_bytes = self.__pubkey.serialize(compressed=False)
+        pubkey_bytes = self.__pubkey.serialize(compressed=compressed)
         return get_address(pubkey_bytes)
 
     def verify(self, msg_hash, signature_bytes):
         """Check whether signature is valid or not.
 
         Args:
             pubkey_bytes(bytes): byte data of pubkey
@@ -334,27 +617,27 @@
 def get_string_decimal(value, place):
     """value를 10의 place 제곱으로 나눈 값을 string으로 변환하여 반환
 
     Args:
         value(int)
         place : 10의 몇 제곱을 나눌지 입력받음
     """
-    str_value = str(value)
+    strValue = str(value)
     if value >= 10 ** place:
-        str_int = str_value[:len(str_value) - place]
-        str_decimal = str_value[len(str_value) - place:]
-        result = f'{str_int}.{str_decimal}'
+        strInt = strValue[:len(strValue) - place]
+        strDecimal = strValue[len(strValue) - place:]
+        result = f'{strInt}.{strDecimal}'
         return result
 
     else:
         zero = "0."
-        val_point = len(str_value)  #val_point : 몇자릿수인지 계산
-        point_difference = place - val_point
-        str_zero = "0" * point_difference
-        result = f'{zero}{str_zero}{value}'
+        valPoint = len(strValue)  # valPoint : 몇자릿수인지 계산
+        pointDifference = place - valPoint
+        strZero = "0" * pointDifference
+        result = f'{zero}{strZero}{value}'
         return result
 
 
 def sha3_256(data):
     """Get hash value using sha3_256 hash function
 
     Args:
@@ -362,41 +645,57 @@
 
     Returns:
         bytes: 256bit hash value (32 bytes)
     """
     return hashlib.sha3_256(data).digest()
 
 
-def get_tx_hash(method, params):
+# def get_tx_hash(method, params):
+#     """Create tx_hash from params object.
+#
+#     Args:
+#         params(dict): the value of 'params' key in jsonrpc
+#
+#     Returns:
+#         bytes: sha3_256 hash value
+#         :param params:
+#         :param method:
+#     """
+#     # tx_phrase = get_tx_phrase(method, params)
+#     tx_phrase = serialize(params)
+#
+#     pawn.console.debug(f"serialize tx={tx_phrase}")
+#     return sha3_256(tx_phrase.encode())
+
+def get_tx_hash(params=None):
     """Create tx_hash from params object.
 
-    :param method: the value of 'method' key in jsonrpc
-    :param params: the value of 'params' key in jsonrpc
+    Args:
+        params(dict): the value of 'params' key in jsonrpc
 
     Returns:
         bytes: sha3_256 hash value
-
+        :param params:
     """
-    tx_phrase = get_tx_phrase(method, params)
+    tx_phrase = serialize(params)
     pawn.console.debug(f"serialize tx={tx_phrase}")
-    return sha3_256(tx_phrase.encode())
+    return sha3_256(tx_phrase)
 
 
 def get_tx_phrase(method, params):
     """Create tx phrase from method and params.
     tx_phrase means input text to create tx_hash.
 
-    :param method: the value of 'method' key in jsonrpc
-    :param params: the value of 'params' key in jsonrpc
-
+    Args:
+        params(dict): the value of 'params' key in jsonrpc
 
     Returns:
         str: sha3_256 hash format without '0x' prefix
     """
-    keys = [ key for key in params ]
+    keys = [key for key in params]
     keys.sort()
 
     key_count = len(keys)
     if key_count == 0:
         return method
 
     phrase = f'{keys[0]}.{params[keys[0]]}'
@@ -405,19 +704,100 @@
         phrase += f'.{key}.{params[key]}'
 
     return f'{method}.{phrase}'
 
 
 def sign_recoverable(privkey_bytes, tx_hash_bytes):
     """
-    :param privkey_bytes:
-    :param tx_hash_bytes: 32byte tx_hash data
+    Args:
+        tx_hash(bytes): 32byte tx_hash data
 
     Returns:
         bytes: signature_bytes + recovery_id(1)
-
     """
     signer = IcxSigner.from_bytes(privkey_bytes)
     signature_bytes, recovery_id = signer.sign_recoverable(tx_hash_bytes)
 
     # append recover_id(1 byte) to signature_bytes.
     return bytes(bytearray(signature_bytes) + recovery_id.to_bytes(1, 'big'))
+
+
+def __make_params_serialized(json_data: dict) -> str:
+
+    def encode(data) -> str:
+        if isinstance(data, dict):
+            return encode_dict(data)
+        elif isinstance(data, list):
+            return encode_list(data)
+        else:
+            return escape(data)
+
+    def encode_dict(data: dict) -> str:
+        result = ".".join(_encode_dict(data))
+        return "{" + result + "}"
+
+    def _encode_dict(data: dict) -> list:
+        for key in sorted(data.keys()):
+            yield key
+            yield encode(data[key])
+
+    def encode_list(data: list) -> str:
+        result = ".".join(_encode_list(data))
+        return f"[" + result + "]"
+
+    def _encode_list(data: list) -> list:
+        for item in data:
+            yield encode(item)
+
+    def escape(data) -> str:
+        if data is None:
+            return "\\0"
+
+        data = str(data)
+        return data.translate(translator)
+
+    return ".".join(_encode_dict(json_data))
+
+
+def serialize(params: dict) -> bytes:
+    """
+    Serialized params of an original JSON request starting with `icx_sendTransaction`
+    to generate a message hash for a signature.
+    :param params: params in a original JSON request for transaction.
+    :return: serialized params.
+    For example, data like `icx_sendTransaction.<key1>.<value1>.<key2>.<value2>` is converted to bytes.
+    """
+    copy_tx = deepcopy(params)
+    key_name_for_tx_hash = __get_key_name_for_tx_hash(params)
+
+    if key_name_for_tx_hash in copy_tx:
+        del copy_tx[key_name_for_tx_hash]
+
+    if 'signature' in copy_tx:
+        del copy_tx['signature']
+
+    partial_serialized_params = __make_params_serialized(copy_tx)
+    return f"icx_sendTransaction.{partial_serialized_params}".encode()
+
+
+def generate_message(params: dict) -> str:
+    """
+    Generates transaction's message hash from params in request for transaction.
+    :param params: params in request for transaction.
+    :return: the 256 bit hash digest of a message. Hexadecimal encoded.
+    """
+    bytes_message_hash = serialize(params)
+    return sha3_256(bytes_message_hash).hexdigest()
+
+
+def __get_key_name_for_tx_hash(params: dict) -> Optional[str]:
+    if __get_tx_version(params) == hex(2):
+        return "tx_hash"
+    else:
+        return None
+
+
+def __get_tx_version(params: dict) -> str:
+    if 'version' not in params:
+        return hex(2)
+    else:
+        return params['version']
```

## pawnlib/utils/notify.py

```diff
@@ -1,12 +1,12 @@
 import requests
 from pawnlib.config.globalconfig import pawnlib_config as pawn
 from pawnlib.output import color_print
 from pawnlib.resource import net
-from pawnlib.typing import date_utils
+from pawnlib.typing import date_utils, shorten_text
 from pawnlib.utils import http
 
 
 def get_level_color(c_level):
     default_color = "5be312"
     return dict(
         info="5be312",
@@ -24,18 +24,20 @@
     :param url: webhook url
     :param msg_text:
     :param title:
     :param send_user_name:
     :param msg_level:
     :return:
     """
+
     if title:
         msg_title = title
     else:
-        msg_title = msg_text
+        msg_title = shorten_text(msg_text, width=50)
+
     msg_level = msg_level.lower()
 
     if url is None:
         color_print.cprint("[ERROR] slack webhook url is None", "red")
         return False
     p_color = get_level_color(msg_level)
 
@@ -47,45 +49,77 @@
             {"type": "divider"}
         ],
         "attachments": [
             {
                 "color": "#" + p_color,
                 "blocks": [
                     {
-                        "type": "section",
+                        "type": "header",
                         "text": {
                             "type": "plain_text",
-                            "text": f'Job Title : {msg_title}'
+                            "text": msg_title
                         }
                     },
                     {
                         "type": "section",
                         "text": {
                             "type": "plain_text",
                             "text": f'{"+ [HOST]":^12s} : {net.get_hostname()}, {net.get_public_ip()}'
                         }
                     },
                     {
                         "type": "section",
                         "text": {
                             "type": "plain_text",
-                            "text": f'{"+ [DATE]":^12s} : {(date_utils.todaydate("time"))}'
+                            "text": f'{"+ [DATE]":^12s} : {(date_utils.todaydate("log"))}'
                         }
                     },
-                    {
-                        "type": "section",
-                        "text": {
-                            "type": "plain_text",
-                            "text": f'{"+ [DESC]":^12s} : {msg_text}'
-                        }
-                    }
+                    # {
+                    #     "type": "section",
+                    #     "text": {
+                    #         "type": "plain_text",
+                    #         "text": f'{"+ [DESC]":^12s} : {msg_text}'
+                    #     }
+                    # }
                 ]
             }
         ]
     }
+
+    def _make_attachment(key=None, value=None):
+
+        if key and value:
+            text = f'💡{key:<12s}: {value}'
+        elif not key:
+            text = f'{"💡[DESC]":^12s} : {msg_text}'
+        else:
+            text = ""
+
+        return {
+            "type": "section",
+            "text": {
+                "type": "plain_text",
+                "text": text
+            },
+        }
+    _attachments = []
+    for attachment in payload["attachments"]:
+        if isinstance(msg_text, dict):
+            for key, value in msg_text.items():
+                if key and value:
+                    attachment['blocks'].append(_make_attachment(key, value))
+        elif isinstance(msg_text, list):
+            for value_in_list in msg_text:
+                if value_in_list:
+                    attachment['blocks'].append(_make_attachment(value=value_in_list))
+        elif msg_text:
+            attachment['blocks'].append(_make_attachment(value=msg_text))
+        _attachments.append(attachment)
+    payload["attachments"] = _attachments
+
     try:
         post_result = requests.post(url, json=payload, verify=False, timeout=15)
         if post_result and post_result.status_code == 200 and post_result.text == "ok":
             pawn.app_logger.info(f"[OK][Slack] Send slack")
             return True
         else:
             pawn.error_logger.error(f"[ERROR][Slack] Got errors, status_code={post_result.status_code}, text={post_result.text}")
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## pawnlib/utils/operate_handler.py

```diff
@@ -5,22 +5,53 @@
 import errno
 import signal
 import atexit
 import subprocess
 import threading
 import itertools
 from typing import Callable, List, Dict, Union
+from concurrent.futures import ThreadPoolExecutor
 
 from pawnlib.output import dump, debug_print, bcolors
 from pawnlib import typing
 from functools import wraps
 
 from pawnlib.config.globalconfig import pawnlib_config as pawn
 
 
+class ThreadPoolRunner:
+    def __init__(self, func=None, tasks=[], max_workers=20, verbose=0, sleep=1):
+        self.func = func
+        self.tasks = tasks
+        self.max_workers = max_workers
+        self.results = []
+        self.sleep = sleep
+        self.verbose = verbose
+
+    def initializer_worker(self):
+        pass
+
+    def run(self):
+        self.results = []
+        with ThreadPoolExecutor(max_workers=self.max_workers, initializer=self.initializer_worker) as pool:
+            self.results = pool.map(self.func, self.tasks)
+
+
+
+            if self.verbose > 0:
+                for result in self.results:
+                    if result:
+                        pawn.console.log(result)
+
+    def forever_run(self):
+        while True:
+            self.run()
+            time.sleep(self.sleep)
+
+
 class Daemon(object):
     """
     A generic daemon class.
     Usage 1: subclass the Daemon class and override the run() method
     Usage 2: subclass the Daemon class and use func parameter
 
     :param pidfile: pid file location
@@ -714,7 +745,14 @@
     try:
         if callable(command):
             command(*args, **kwargs)
         else:
             pawn.console.print(f"\n[red] {command} not callable ")
     except KeyboardInterrupt:
         pawn.console.print(f"\n\n[red] ^C KeyboardInterrupt - {command.__name__}{str(args)[:-1]}{kwargs}) \n")
+
+def handle_keyboard_interrupt_signal():
+    import signal
+    def handle_ctrl_c(_signal, _frame):
+        pawn.console.rule(f"[red] KeyboardInterrupt, Going down! Signal={_signal}")
+        sys.exit(0)
+    signal.signal(signal.SIGINT, handle_ctrl_c)
```

## Comparing `pawnlib-0.1.9.dist-info/METADATA` & `pawnlib-0.2.0.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,39 +1,41 @@
 Metadata-Version: 2.1
 Name: pawnlib
-Version: 0.1.9
+Version: 0.2.0
 Summary: pawnlib is a collection of libraries for IaC.
 Home-page: https://github.com/jinwoo-j/pawnlib
 Author: Jinwoo Jeong
-Author-email: jinwoo@iconloop.com
+Author-email: jinwoo@parametacorp.com
 License: MIT
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 Requires-Dist: asttokens (>=2.0.5)
-Requires-Dist: certifi (>=2022.6.15)
+Requires-Dist: certifi (>=2020.12.15)
 Requires-Dist: charset-normalizer (>=2.1.0)
 Requires-Dist: devtools (>=0.8.0)
 Requires-Dist: executing (>=0.8.3)
 Requires-Dist: idna (>=2.5)
 Requires-Dist: parameterized (>=0.8.1)
-Requires-Dist: PyYAML (>=6.0)
+Requires-Dist: PyYAML (>=5.3.1)
 Requires-Dist: requests (>=2.25.1)
-Requires-Dist: six (>=1.16.0)
+Requires-Dist: six (>=1.15.0)
 Requires-Dist: termcolor (>=1.1.0)
 Requires-Dist: urllib3 (>=1.26.10)
 Requires-Dist: asyncio (>=3.4.3)
 Requires-Dist: aiometer (>=0.3.0)
 Requires-Dist: pyfiglet (>=0.8.post1)
-Requires-Dist: deprecated
+Requires-Dist: deprecated (~=1.2.13)
 Requires-Dist: argparse (>=1.4.0)
-Requires-Dist: Jinja2 (>=3.1.2)
+Requires-Dist: Jinja2 (>=3.0.3)
 Requires-Dist: rich (>=12.0.1)
+Requires-Dist: Pygments (>=2.14.0)
+Requires-Dist: inquirerpy (==0.3.4)
 
 # pawnlib
 
 pawnlib is a collection of libraries for IaC.
 
 utils, globals vars, logging, http, network, pretty printing, resource, converter ...
```

## Comparing `pawnlib-0.1.9.dist-info/RECORD` & `pawnlib-0.2.0.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,44 +1,48 @@
 pawnlib/__init__.py,sha256=FXDHsJ3zZkGKwHLxXvy0z-DLH9UwQvGh7SoLiigPptw,1188
 pawnlib/__main__.py,sha256=wmMMh9f5l39HY6p_IfARRZwRDcK1rnfENZdCb9tzJYg,1224
-pawnlib/__version__.py,sha256=WRpOMFQni8aLTOUrOqiQDzuk2SSwfYK9tlQyzwwF-hM,292
+pawnlib/__version__.py,sha256=Fhln7WMC7iu8zoe2cgzYWbZ7_4TycU4R0EjJ1dMOfNI,296
 pawnlib/asyncio/__init__.py,sha256=ToWEND0eBP0YeJw4xZaBPLgQ-BGSeIvIApyysQMCsgo,19
-pawnlib/asyncio/run.py,sha256=S5WG6HuT_JF2FqaxYbEDvzTzwxdFS3thPs8eF19cRQA,2952
+pawnlib/asyncio/run.py,sha256=WnZ8JWa5hnntds4wItvPtYy7HbJ7fLMvHbP04uXi05o,4261
 pawnlib/builder/__init__.py,sha256=2uuVV8xTTPsD8SCN1PDLhAcKOKISEZLQCQgOeritMrE,36
 pawnlib/builder/generator.py,sha256=4nsaQvZpzaLpIYLovIqmofBmyItj6nApae9zFdmvIuQ,5382
 pawnlib/builder/templates/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-pawnlib/builder/templates/app_with_logging.tmpl,sha256=1x2OfxuzVzuKV0dSCGj9gpCR3WEoQtd5TudEktNAlRE,2195
+pawnlib/builder/templates/app_with_logging.tmpl,sha256=UpxeQgys681Q1B-mADpEpRaG47RccWwwsdKigHL-ECU,2343
 pawnlib/cli/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pawnlib/cli/aws.py,sha256=7vM9CDAe6qqXyqLRpwktw_qWfLEs4hOHp9D2f1eKF3g,1328
-pawnlib/cli/icon.py,sha256=fFEAjFKKU_pVL5LMlLtm4-Po13TtbK9h-VPV44TAHkY,2904
+pawnlib/cli/http.py,sha256=GZPmoZve3vj2LkWwWUL3QIPv_PFIS-sN27cAR2Ka5-A,9975
+pawnlib/cli/icon.py,sha256=xaLVmfeOsqvT0JoJa6oquugqBp88tbTAOWJ5gLtkiCg,2910
 pawnlib/cli/init.py,sha256=GuRT6zIDWIegLvYznQEG4Dc3oOaHSD5QE8WItSVwj5w,1305
-pawnlib/cli/main_cli.py,sha256=ZfWTmWct1iuBG2CH0eI1iTV9f6mgsjbVc-NjZAJS7P0,4079
+pawnlib/cli/main_cli.py,sha256=BiVY0xtYEoZ3uhH-_gdH9rQ7tPaTHLh7-pTgi6izlMo,5242
 pawnlib/cli/proxy.py,sha256=iR0zwjMibFeHTn3x7N4vqM-Yzx5u0ETFM3D1ZmbdbFw,6605
+pawnlib/cli/wallet.py,sha256=mHIBMkdRzc8y3UaitnJyKCqc5IKUnlKStG7Gea1_wN8,3269
 pawnlib/config/__fix_import.py,sha256=RcDVfb9fdwYrba68s18UpHdUXD1xalA5NhLzbq-33z4,1380
-pawnlib/config/__init__.py,sha256=A9ACNY1LsPkVaCgTGw-ZrFMN_UoD8pgmKRSWUi6nTJI,108
+pawnlib/config/__init__.py,sha256=Z25cxP0bILcaUfpjx0kJubGH_8s3cOn_wBc8ixLXhCw,121
 pawnlib/config/configure.py,sha256=ARDGd3oanqDhhfW_oyXkw9stJ5ZlOMO0tSZA2gwuG_I,4523
 pawnlib/config/console.py,sha256=QKBEN-dn8qNbv5H_rz_-GYu6EX--L58mvZ8MG9hPh5A,4165
-pawnlib/config/globalconfig.py,sha256=05PngWC_0yP163ryiIxvuE8lbiBQXhkYDAe2b6Bhqdw,26200
-pawnlib/output/__init__.py,sha256=jsh9F1I8h5-HAR8fa9u--jMToDveCX3v2AeZ5HfXRUE,545
-pawnlib/output/color_print.py,sha256=khpzk8XYYuXMpc3mJm80PAyRitBVxW6meIhEb0kirWY,20445
+pawnlib/config/globalconfig.py,sha256=b4Z2IWEKFFV8iUfCePEJKBL4jExjfgJOnF-GtwP3c5E,29830
+pawnlib/input/__init__.py,sha256=uagiBVVJrEfeBCmFL1rJK-cFcML8uTyoUMF1vwYy7eQ,432
+pawnlib/input/prompt.py,sha256=yDmEw7Y6o-5BcozxAFYYlfAykXn8luk53YtAjw8IyGg,21792
+pawnlib/output/__init__.py,sha256=oV_KTI_jcFfV3v9Y6tfx0abpu5rOL9J0_pmUFLSoXVE,650
+pawnlib/output/color_print.py,sha256=3eIblGE9rtHDqbdh2rJfWEQ7ko5vXM2nAaoZInoPKZY,37342
 pawnlib/output/file.py,sha256=V2_kYLQo5EG-PTeQa-HtYFhWagCGoV5PTkPUh8K0vUI,6198
-pawnlib/resource/__init__.py,sha256=0ijpoXW4ZYN3IaQWExMHtukZZWn5DUPu5bWYz4gx5Hk,288
+pawnlib/resource/__init__.py,sha256=s2u4U2LZF5ntbo65WivN9d74R_Hlh-DQTgmL8Zd_RzY,445
 pawnlib/resource/net.py,sha256=W8TwyXkXzhiTEqgZi-0l_alljzOw7bo4OC7iNkvb5wE,6568
 pawnlib/resource/server.py,sha256=T3_qcSL3TCxJ5AT9d3kBw_EQARYTpooxVjDdF-5Lo7w,11387
-pawnlib/typing/__init__.py,sha256=MHmQz-2kVsBTIvfghHOOHQYBE4Ztx9dfdtsjkQbZpxM,1653
-pawnlib/typing/check.py,sha256=O0R_jVATbv-bkQpreayhZZgUVG-eMGW8gU2zjBNOJ30,4402
-pawnlib/typing/constants.py,sha256=Rzm92LOI55JT2-nmR1BtZRNFzDEvHa4qDUxecB9MClo,689
-pawnlib/typing/converter.py,sha256=YlGmg9yv4Hnyw6CwTVpJUoPT_hhAZRLlssSA2cIWnd0,54524
+pawnlib/typing/__init__.py,sha256=IVCs20A-AFyHGejhzctvphouVEnNIdWY4WCx7PWdSSA,2022
+pawnlib/typing/check.py,sha256=GTYRaQ1ubMYTEiKa1463SWub_oitBjSFFltnOCDdRvg,9094
+pawnlib/typing/constants.py,sha256=9mbzRKWZw9p2ByzWairAT1zZv-qgd_7WVOEIVwUbX_0,823
+pawnlib/typing/converter.py,sha256=9E3nM8e40Fi5Qb0vdVc5FwzcH-wfX8VabD_djHArF1k,59328
 pawnlib/typing/date_utils.py,sha256=nNpliOVgREsQiBlynoqI26jWIc8NdZ7QaXjNmXGCj0U,7137
-pawnlib/typing/defines.py,sha256=rub1puD3M_WHUcwR0hG59lu9df_jQA0LzrT1HxYpyYQ,1898
+pawnlib/typing/defines.py,sha256=V3NbriLXzb0iEKitUv47VoHtGhEOvwCg4krt9Y_qmnc,3365
 pawnlib/typing/generator.py,sha256=tAzkL5hJt0le958oYkVjTMbRGmlOwP3gE7mZaD-yXJY,12711
-pawnlib/utils/__init__.py,sha256=NqR4yzkjOYz1rMI2EIe0nti2URz8PFWUNbjkHSMDdek,349
-pawnlib/utils/http.py,sha256=PV0R-N3-3tHdsThpglnSP8EdATFCvW1etA3ujYjMaVo,12506
-pawnlib/utils/icx_signer.py,sha256=-NJIKOv6BR9Uc8LVK6R9G7VQmJb1Em-AXlUDppX4VbM,12365
+pawnlib/utils/__init__.py,sha256=nO-vGtRB4UIImOLlJO-gN7SWoXYLcXqfc3LLyoCEAxM,552
+pawnlib/utils/http.py,sha256=J30cG7FlCT0DcFTtUKtRlptu0KnjEWXHQfqaOHwNKkY,48448
+pawnlib/utils/icx_signer.py,sha256=ELnAB98vI7JOvDKlVWSlT5mqCy5tRvLDysk0EIRmlBw,25587
 pawnlib/utils/log.py,sha256=zYClSlvFJt9ZxZpApWvFZ7EcFRFtwUIyCyrtmUdfiLI,12172
-pawnlib/utils/notify.py,sha256=UlQyJSfH7_NYxIcec84SDFDV3lBhbQE1CbTsxOHPvQ8,5929
-pawnlib/utils/operate_handler.py,sha256=603oZfZhDB3yWyxeJoZZ-y_HPTu6inP74Q0g9LPWzFo,22138
-pawnlib-0.1.9.dist-info/METADATA,sha256=Tsl2vnNvtXveq1s3vG0jLnktIsm0buQv5SEiE1vG-T8,5042
-pawnlib-0.1.9.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-pawnlib-0.1.9.dist-info/entry_points.txt,sha256=gfwAzqk-lzSb_VFiXmGg4Xn-8TUu_TMcM3QBjdyEAAE,52
-pawnlib-0.1.9.dist-info/top_level.txt,sha256=a6t_hQ3MagyRwwliF91xPgBk12g6a7O84C4GiY3fKQE,8
-pawnlib-0.1.9.dist-info/RECORD,,
+pawnlib/utils/notify.py,sha256=MybDFmnnwMm2AYp9pHmKatFnPO1IGpw65ZWF2MTcYds,7014
+pawnlib/utils/operate_handler.py,sha256=LMf41828PACtmmxnkR_zz0VD7s8F--Cqcdl9Efk4hV0,23248
+pawnlib-0.2.0.dist-info/METADATA,sha256=d3Q421DCA-95elO-cGr5CnZSdSPXKy07BU-LRel1U3w,5131
+pawnlib-0.2.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+pawnlib-0.2.0.dist-info/entry_points.txt,sha256=gfwAzqk-lzSb_VFiXmGg4Xn-8TUu_TMcM3QBjdyEAAE,52
+pawnlib-0.2.0.dist-info/top_level.txt,sha256=a6t_hQ3MagyRwwliF91xPgBk12g6a7O84C4GiY3fKQE,8
+pawnlib-0.2.0.dist-info/RECORD,,
```

